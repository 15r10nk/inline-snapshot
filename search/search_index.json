{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-inline-snapshot","title":"Welcome to inline-snapshot","text":"<p>inline-snapshot can be used for different things:</p> <ul> <li>golden master/approval/snapshot testing.   The idea is that you have a function with a currently unknown result and you want to write a tests, which ensures that the result does not change during refactoring.</li> <li>Compare things which are complex like lists with lot of numbers or complex data structures.</li> <li>Things which might change during the development like error messages.</li> </ul> <p><code>inline-snapshot</code> automates the process of recording, storing and updating the value you want to compare with. The value is converted with <code>repr()</code> and stored in the source file as argument of the <code>snapshot()</code> function.</p>"},{"location":"#usage","title":"Usage","text":"<p>You can use <code>snapshot()</code> instead of the value which you want to compare with and run the tests to record the correct values.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p>Your tests will break, if you change your code by adding <code>// 18</code>. Maybe that is correct and you should fix your code, or your code is correct and you want to update your test results.</p> changed code--inline-snapshot=fix <p> <pre><code>def something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p> <pre><code>def something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(1590054)\n</code></pre></p> <p>Please verify the new results. <code>git diff</code> will give you a good overview over all changed results. Use <code>pytest -k test_something --inline-snapshot=fix</code> if you only want to change one test.</p>"},{"location":"#supported-operations","title":"Supported operations","text":"<p>You can use <code>snapshot(x)</code> like you can use <code>x</code> in your assertion with a limited set of operations:</p> <ul> <li><code>value == snapshot()</code> to compare with something,</li> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</li> </ul> <p>Warning</p> <p>One snapshot can only be used with one operation. The following code will not work:  <pre><code>def test_something():\n    s = snapshot(5)\n    assert 5 &lt;= s\n    assert 5 == s\n\n\n# Error:\n# &gt;       assert 5 == s\n# E       TypeError: This snapshot cannot be use with `==`, because it was previously used with `x &lt;= snapshot`\n</code></pre></p>"},{"location":"#supported-usage","title":"Supported usage","text":"<p>It is possible to place <code>snapshot()</code> anywhere in the tests and reuse it multiple times.</p> original code--inline-snapshot=create <p> <pre><code>def something():\n    return 21 * 2\n\n\nresult = snapshot()\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p> <pre><code>def something():\n    return 21 * 2\n\n\nresult = snapshot(42)\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p><code>snapshot()</code> can also be used in loops:</p> original code--inline-snapshot=create <p> <pre><code>def test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot()\n</code></pre></p> <p> <pre><code>def test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot(3)\n</code></pre></p> <p>or passed as an argument to a function:</p> original code--inline-snapshot=create <p> <pre><code>def check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot())\n    check_string_len(\"1234\", snapshot())\n    check_string_len(\".......\", snapshot())\n</code></pre></p> <p> <pre><code>def check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot(3))\n    check_string_len(\"1234\", snapshot(4))\n    check_string_len(\".......\", snapshot(7))\n</code></pre></p>"},{"location":"#feedback","title":"Feedback","text":"<p>inline-snapshot provides some advanced ways to work with snapshots.</p> <p>I would like to know how these features are used to further improve this small library. Let me know if you've found interesting use cases for this library via twitter, fosstodon or in the github discussions.</p>"},{"location":"#sponsors","title":"Sponsors","text":"<p>I would like to thank my sponsors. Without them, I would not be able to invest so much time in my projects.</p>"},{"location":"#bronze-sponsor","title":"Bronze sponsor \ud83e\udd49","text":""},{"location":"#issues","title":"Issues","text":"<p>If you encounter any problems, please report an issue along with a detailed description.</p>"},{"location":"categories/","title":"Categories","text":"<p>Each snapshot change is assigned to a different category. This is done because inline-snapshot supports more than just <code>==</code> checks.</p> <p>There are changes which:</p> <ul> <li>create new snapshot values</li> <li>fix your tests</li> <li>update only the syntax to a new representation</li> <li>trim unused pieces from your snapshots</li> </ul> <p>Create and fix are mainly used, but it is good to know what type of change you are approving, because it helps with the decision if this changes should be applied.</p>"},{"location":"categories/#categories","title":"Categories","text":""},{"location":"categories/#create","title":"Create","text":"<p>These changes are made when new snapshots are created.</p> <p>The result of each comparison is <code>True</code>, which allows to run the whole test to fill all new snapshots with values.</p> <p>Example:</p> <pre><code>def test_something():\n    assert 5 == snapshot()\n\n    assert 5 &lt;= snapshot()\n\n    assert 5 in snapshot()\n\n    s = snapshot()\n    assert 5 == s[\"key\"]\n</code></pre> <pre><code>def test_something():\n    assert 5 == snapshot(5)\n\n    assert 5 &lt;= snapshot(5)\n\n    assert 5 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 5 == s[\"key\"]\n</code></pre>"},{"location":"categories/#fix","title":"Fix","text":"<p>These changes are made when the snapshots comparison does not return <code>True</code> any more (depending on the operation <code>==</code>, <code>&lt;=</code>, <code>in</code>). The result of each comparison is <code>True</code> if you change something from this category, which allows to run the whole test and to fix other snapshots.</p> <pre><code>def test_something():\n    assert 8 == snapshot(5)\n\n    assert 8 &lt;= snapshot(5)\n\n    assert 8 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 8 == s[\"key\"]\n</code></pre> <pre><code>def test_something():\n    assert 8 == snapshot(8)\n\n    assert 8 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key\": 8})\n    assert 8 == s[\"key\"]\n</code></pre> <p>Info</p> <p>The main reason for the different categories is to make the number of changes in the fix category as small as possible. The changes in the fix category are the only changes which change the value of the snapshots and should be reviewed carefully.</p>"},{"location":"categories/#trim","title":"Trim","text":"<p>These changes are made when parts of the snapshots are removed which are no longer needed, or if limits can be reduced.</p> <pre><code>def test_something():\n    assert 2 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key1\": 1, \"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <pre><code>def test_something():\n    assert 2 &lt;= snapshot(2)\n\n    assert 8 in snapshot([8])\n\n    s = snapshot({\"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <p>There might be problems in cases where you use the same snapshot in different tests, run only one test and trim the snapshot with <code>pytest -k test_a --inline-snapshot=trim</code> in this case:</p> <pre><code>s = snapshot(5)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <pre><code>s = snapshot(2)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <p>The value of the snapshot is reduced to <code>2</code>, because <code>test_a()</code> was the only test running and inline-snapshot does not know about <code>5 &lt;= s</code>. It is recommended to use trim only if you run your complete test suite.</p>"},{"location":"categories/#update","title":"Update","text":"<p>Changes in the update category do not change the value in the code, just the representation. The reason might be that <code>repr()</code> of the object has changed or that inline-snapshot provides some new logic which changes the representation. Like with the strings in the following example:</p> <pre><code>class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\"a\\nb\\nc\\n\")\n\n    assert 5 == snapshot(4 + 1)\n\n    assert Vector(1, 2) == snapshot(Vector(x=1, y=2))\n</code></pre> <pre><code>class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\n        \"\"\"\\\na\nb\nc\n\"\"\"\n    )\n\n    assert 5 == snapshot(5)\n\n    assert Vector(1, 2) == snapshot(Vector(1, 2))\n</code></pre> <p>The approval of this type of changes is easier, because inline-snapshot assures that the value has not changed.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v0110-2024-07-07","title":"v0.11.0 (2024-07-07)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>check if the result of copy.deepcopy() is equal to the copied value</li> <li>support for <code>enum.Enum</code>, <code>enum.Flag</code>, <code>type</code> and omitting of default values (#73)</li> </ul>"},{"location":"changelog/#v0102-2024-05-28","title":"v0.10.2 (2024-05-28)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>changed how --inline-snapshot=disable works in combination with xdist (#90)</li> <li>fix typo, rename 'theme' with 'them'</li> </ul>"},{"location":"changelog/#v0101-2024-05-26","title":"v0.10.1 (2024-05-26)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>trigger no update for trailing comma changes</li> </ul>"},{"location":"changelog/#v0100-2024-05-21","title":"v0.10.0 (2024-05-21)","text":""},{"location":"changelog/#breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>removed support for python 3.7</li> <li>removed <code>--inline-snapshot-disable</code> option and replaced it with <code>--inline-snapshot=disable</code></li> </ul>"},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>new flags: disable, short-report, report and review</li> <li>added config option and environment variable to specify default flags</li> <li>show diff of changed snapshots in pytest report</li> <li>interactive review mode</li> </ul>"},{"location":"changelog/#v090-2024-05-07","title":"v0.9.0 (2024-05-07)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>check if inline-snapshot is used in combination with xdist and notify the user that this is not possible</li> </ul>"},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>change the quoting of strings does not trigger an update</li> </ul>"},{"location":"changelog/#v082-2024-04-24","title":"v0.8.2 (2024-04-24)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>removed restriction that the snapshot functions has to be called snapshot (#72)</li> <li>report error in tear down for sub-snapshots with missing values (#70)</li> <li>element access in sub-snapshots does not create new values</li> </ul>"},{"location":"changelog/#v081-2024-04-22","title":"v0.8.1 (2024-04-22)","text":""},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>make typing less strict</li> </ul>"},{"location":"changelog/#v080-2024-04-09","title":"v0.8.0 (2024-04-09)","text":""},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>prevent dirty-equal values from triggering of updates</li> <li>fix lists by calculating the alignment of the changed values</li> <li>insert dict items</li> <li>delete dict items</li> <li>preserve not changed dict-values and list-elements</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>update with UndecidedValue</li> <li>handle dicts with mulitple insertions and deletions</li> <li>handle lists with mulitple insertions and deletions</li> <li>fixed typing and coverage</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>removed old needs* logic</li> <li>removed get_result</li> <li>use _get_changes api for DictValue</li> <li>use _get_changes api for CollectionValue</li> <li>use _get_changes api for MinMaxValue</li> <li>use _get_changes</li> <li>moved some functions</li> </ul>"},{"location":"changelog/#v070-2024-02-27","title":"v0.7.0 (2024-02-27)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>removed old --update-snapshots option</li> </ul>"},{"location":"changelog/#v061-2024-01-28","title":"v0.6.1 (2024-01-28)","text":""},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>use utf-8 encoding to read and write source files</li> </ul>"},{"location":"changelog/#v060-2023-12-10","title":"v0.6.0 (2023-12-10)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li>store snapshot values in external files</li> </ul>"},{"location":"changelog/#v052-2023-11-13","title":"v0.5.2 (2023-11-13)","text":""},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>remove upper bound from dependencies in pyproject.toml</li> </ul>"},{"location":"changelog/#v051-2023-10-20","title":"v0.5.1 (2023-10-20)","text":""},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>show better error messages</li> </ul>"},{"location":"changelog/#v050-2023-10-15","title":"v0.5.0 (2023-10-15)","text":""},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>support 3.12</li> </ul>"},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>do not change empty snapshot if it is not used</li> </ul>"},{"location":"changelog/#v040-2023-09-29","title":"v0.4.0 (2023-09-29)","text":""},{"location":"changelog/#feat_7","title":"Feat","text":"<ul> <li>escaped linebreak at the start/end of multiline strings</li> </ul>"},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>added py.typed</li> </ul>"},{"location":"changelog/#v032-2023-07-31","title":"v0.3.2 (2023-07-31)","text":""},{"location":"changelog/#fix_11","title":"Fix","text":"<ul> <li>handle update flag in sub-snapshots correctly</li> <li>fixed some edge cases where sub-snapshots had problems with some flags</li> <li>string literal concatenation should trigger no update</li> </ul>"},{"location":"changelog/#v031-2023-07-14","title":"v0.3.1 (2023-07-14)","text":""},{"location":"changelog/#fix_12","title":"Fix","text":"<ul> <li>added <code>__all__</code> to inline_snapshot</li> <li>flags fix/trim/create/update are changing the matching snapshots</li> </ul>"},{"location":"changelog/#v030-2023-07-12","title":"v0.3.0 (2023-07-12)","text":""},{"location":"changelog/#breaking-change_1","title":"BREAKING CHANGE","text":"<ul> <li>values have to be copyable with <code>copy.deepcopy</code></li> </ul>"},{"location":"changelog/#fix_13","title":"Fix","text":"<ul> <li>snapshot the current value of mutable objects   <pre><code>l = [1]\nassert l == snapshot([1])  # old behaviour: snapshot([1, 2])\nl.append(2)\nassert l == snapshot([1, 2])\n</code></pre></li> </ul>"},{"location":"changelog/#v021-2023-07-09","title":"v0.2.1 (2023-07-09)","text":""},{"location":"changelog/#fix_14","title":"Fix","text":"<ul> <li>black configuration files are respected</li> </ul>"},{"location":"changelog/#v020-2023-06-20","title":"v0.2.0 (2023-06-20)","text":""},{"location":"changelog/#feat_8","title":"Feat","text":"<ul> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li> <p><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</p> </li> <li> <p>convert strings with newlines to triple quoted strings   <pre><code>assert \"a\\nb\\n\" == snapshot(\n    \"\"\"a\nb\n\"\"\"\n)\n</code></pre></p> </li> <li>preserve black formatting</li> </ul>"},{"location":"changelog/#v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":""},{"location":"changelog/#fix_15","title":"Fix","text":"<ul> <li>updated executing</li> </ul>"},{"location":"changelog/#v011-2022-12-08","title":"v0.1.1 (2022-12-08)","text":""},{"location":"changelog/#fix_16","title":"Fix","text":"<ul> <li>fixed typo in pytest plugin name</li> </ul>"},{"location":"changelog/#v010-2022-07-25","title":"v0.1.0 (2022-07-25)","text":""},{"location":"changelog/#feat_9","title":"Feat","text":"<ul> <li>first inline-snapshot version</li> </ul>"},{"location":"cmp_snapshot/","title":"x <= snapshot()","text":""},{"location":"cmp_snapshot/#general","title":"General","text":"<p>A snapshot can be compared against any value with <code>&lt;=</code> or <code>&gt;=</code>. This can be used to create a upper/lower bound for some result. The snapshot value can be trimmed to the lowest/largest valid value.</p> <p>Example:</p> original code--inline-snapshot=createoptimized code --inline-snapshot=trim <p> <pre><code>def gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot()\n    assert iterations &lt;= snapshot()\n</code></pre></p> <p> <pre><code>def gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>def gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>def gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(3)\n</code></pre></p> <p>Warning</p> <p>This should not be used to check for any flaky values like the runtime of some code, because it will randomly break your tests.</p> <p>The same snapshot value can also be used in multiple assertions.</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    value = snapshot()\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p> <p> <pre><code>def test_something():\n    value = snapshot(6)\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p>"},{"location":"cmp_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the new value and store it in the source code if it is contradicts the comparison.</li> <li><code>trim</code> record the new value and store it in the source code if it is more strict than the old one.</li> </ul>"},{"location":"code_generation/","title":"Code generation","text":"<p>You can use almost any python datatype and also complex values like <code>datatime.date</code>, because <code>repr()</code> is used to convert the values to source code. The default <code>__repr__()</code> behaviour can be customized. It might be necessary to import the right modules to match the <code>repr()</code> output.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot(\n        {\n            \"name\": \"hello\",\n            \"one number\": 5,\n            \"numbers\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            \"sets\": {1, 2, 15},\n            \"datetime\": datetime.date(1, 2, 22),\n            \"complex stuff\": (3 + 5j),\n            \"bytes\": b\"byte abc\\n\\x16\",\n        }\n    )\n</code></pre></p> <p>The code is generated in the following way:</p> <ol> <li>The value is copied with <code>value = copy.deepcopy(value)</code> and it is checked if the copied value is equal to the original value.</li> <li>The code is generated with <code>repr(value)</code> (which can be customized)</li> <li> <p>Strings which contain newlines are converted to triple quoted strings.</p> <p>Note</p> <p>Missing newlines at start or end are escaped (since 0.4.0).</p> original code--inline-snapshot=update <p> <pre><code>def test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"first line\nsecond line\"\"\"\n    )\n</code></pre></p> <p> <pre><code>def test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"\\\nfirst line\nsecond line\\\n\"\"\"\n    )\n</code></pre></p> </li> <li> <p>The code is formatted with black.</p> </li> <li> <p>The whole file is formatted with black if it was formatted before.</p> <p>Note</p> <p>The black formatting of the whole file could not work for the following reasons:</p> <ol> <li>black is configured with cli arguments and not in a configuration file. Solution: configure black in a configuration file</li> <li>inline-snapshot uses a different black version. Solution: specify which black version inline-snapshot should use by adding black with a specific version to your dependencies.</li> </ol> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Default configuration:</p> <pre><code>[tool.inline-snapshot]\nhash-length=15\ndefault-flags=[\"short-report\"]\n</code></pre> <ul> <li>hash-length: specifies the length of the hash used by <code>external()</code> in the code representation.     This does not affect the hash length used to store the data.     The hash should be long enough to avoid hash collisions.</li> <li>default-flags: defines which flags should be used if there are no flags specified with <code>--inline-snapshot=...</code>.     You can also use the environment variable <code>INLINE_SNAPSHOT_DEFAULT_FLAGS=...</code> to specify the flags and to override those in the configuration file.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Please create an issue before writing a pull request so we can discuss what needs to be changed.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>The code can be tested with nox</p> <ul> <li><code>nox</code> can be used to test all supported python versions and to check for coverage.</li> <li><code>nox -e test-3.10 -- --sw</code> runs pytest for python 3.10 with the <code>--sw</code> argument.</li> </ul>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>This project has a hard coverage requirement of 100%. The goal here is to find different edge cases which might have bugs.</p> <p>However, it is possible to exclude some code from the coverage.</p> <p>Code can be marked with <code>pragma: no cover</code>, if it can not be tested for some reason. This makes it easy to spot uncovered code in the source.</p> <p>Impossible conditions can be handled with <code>assert False</code>. <pre><code>if some_condition:\n    ...\nif some_other_codition:\n    ...\nelse:\n    assert False, \"unreachable because ...\"\n</code></pre> This serves also as an additional check during runtime.</p>"},{"location":"contributing/#commits","title":"Commits","text":"<p>Please use pre-commit for your commits.</p>"},{"location":"customize_repr/","title":"@customize_repr","text":"<p><code>repr()</code> can be used to convert a python object into a source code representation of the object, but this does not work for every type. Here are some examples: <pre><code>&gt;&gt;&gt; repr(int)\n\"&lt;class 'int'&gt;\"\n\n&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; E = Enum(\"E\", [\"a\", \"b\"])\n&gt;&gt;&gt; repr(E.a)\n'&lt;E.a: 1&gt;'\n</code></pre></p> <p><code>customize_repr</code> can be used to overwrite the default <code>repr()</code> behaviour.</p> <p>The implementation for <code>Enum</code> looks like this:</p> <pre><code>@customize_repr\ndef _(value: Enum):\n    return f\"{type(value).__qualname__}.{value.name}\"\n</code></pre> <p>This implementation is then used by inline-snapshot if <code>repr()</code> is called during the code generation, but not in normal code.</p> <pre><code>from enum import Enum\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # normal repr\n    assert repr(E.a) == \"&lt;E.a: 1&gt;\"\n\n    # the special implementation to convert the Enum into a code\n    assert E.a == snapshot(E.a)\n</code></pre>"},{"location":"customize_repr/#builtin-datatypes","title":"builtin datatypes","text":"<p>inline-snapshot comes with a special implementation for the following types: <ul> <li><code>builtins.dict</code></li> <li><code>builtins.frozenset</code></li> <li><code>builtins.list</code></li> <li><code>builtins.set</code></li> <li><code>builtins.tuple</code></li> <li><code>builtins.type</code></li> <li><code>collections.defaultdict</code></li> <li><code>dataclass</code></li> <li><code>enum.Enum</code></li> <li><code>enum.Flag</code></li> <li><code>namedtuple</code></li> </ul></p> <p>Container types like <code>dict</code> or <code>dataclass</code> need a special implementation because it is necessary that the implementation uses <code>repr()</code> for the child elements.</p> <pre><code>@customize_repr\ndef _(value: list):\n    return \"[\" + \", \".join(map(repr, value)) + \"]\"\n</code></pre> <p>Note</p> <p>using <code>f\"{obj!r}\"</code> or <code>PyObject_Repr()</code> will not work, because inline-snapshot replaces <code>builtins.repr</code> during the code generation.</p>"},{"location":"customize_repr/#customize","title":"customize","text":"<p>You can also use <code>repr()</code> inside <code>__repr__()</code>, if you want to make your own type compatible with inline-snapshot.</p> <pre><code>from enum import Enum\n\n\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def __repr__(self):\n        # this would not work\n        # return f\"Pair({self.a!r}, {self.b!r})\"\n\n        # you have to use repr()\n        return f\"Pair({repr(self.a)}, {repr(self.b)})\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Pair):\n            return NotImplemented\n        return self.a == other.a and self.b == other.b\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # the special repr implementation is used recursive here\n    # to convert every Enum to the correct representation\n    assert Pair(E.a, [E.b]) == snapshot(Pair(E.a, [E.b]))\n</code></pre> <p>you can also customize the representation of datatypes in other libraries:</p> <pre><code>from inline_snapshot import customize_repr\nfrom other_lib import SomeType\n\n\n@customize_repr\ndef _(value: SomeType):\n    return f\"SomeType(x={repr(value.x)})\"\n</code></pre>"},{"location":"eq_snapshot/","title":"x == snapshot()","text":""},{"location":"eq_snapshot/#general","title":"General","text":"<p>A snapshot can be compared with any value using <code>==</code>. The value can be recorded with <code>--inline-snapshot=create</code> if the snapshot is empty. The value can later be changed with <code>--inline-snapshot=fix</code> if the value the snapshot is compared with has changed.</p> <p>Example:</p> original code--inline-snapshot=createvalue changed--inline-snapshot=fix <p> <pre><code>def test_something():\n    assert 2 + 4 == snapshot()\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 2 + 4 == snapshot(6)\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 2 + 40 == snapshot(4)\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 2 + 40 == snapshot(42)\n</code></pre></p>"},{"location":"eq_snapshot/#dirty-equals","title":"dirty-equals","text":"<p>It might be, that larger snapshots with many lists and dictionaries contain some values which change frequently and are not relevant for the test. They might be part of larger data structures and be difficult to normalize.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\"date\": datetime.datetime(2024, 3, 14, 0, 0), \"payload\": \"some data\"}\n    )\n</code></pre></p> <p>inline-snapshot tries to change only the values that it needs to change in order to pass the equality comparison. This allows to replace parts of the snapshot with dirty-equals expressions. This expressions are preserved as long as the <code>==</code> comparison with them is <code>True</code>.</p> <p>Example:</p> using IsDatetime()changed payload--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"data changed for some good reason\",\n        }\n    )\n</code></pre></p> <p>Note</p> <p>The current implementation looks only into lists, dictionaries and tuples and not into the representation of other data structures.</p>"},{"location":"eq_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the value parts and store them in the source code if it is different from the current one.</li> <li><code>update</code> update parts of the value if their representation has changed.   Parts which are replaced with dirty-equals expressions are not updated.</li> </ul>"},{"location":"getitem_snapshot/","title":"snapshot()[key]","text":""},{"location":"getitem_snapshot/#general","title":"General","text":"<p>It is possible to generate sub-snapshots during runtime. This sub-snapshots can be used like a normal snapshot.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    s = snapshot()\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p> <pre><code>def test_something():\n    s = snapshot({\"a\": 4, \"b\": 5})\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p><code>s[key]</code> can be used with every normal snapshot operation including <code>s[key1][key2]</code>.</p>"},{"location":"getitem_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined or create a new sub-snapshot if one is missing.</li> <li><code>trim</code> remove sub-snapshots if they are not needed any more.</li> </ul> <p>The flags <code>fix</code> and <code>update</code> are applied recursive to all sub-snapshots.</p>"},{"location":"in_snapshot/","title":"x in snapshot()","text":""},{"location":"in_snapshot/#general","title":"General","text":"<p>It is possible to check if an value is in a snapshot. The value of the generated snapshot will be a list of all values which are tested.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    s = snapshot()\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p> <p> <pre><code>def test_something():\n    s = snapshot([5, 8, \"a\", \"b\"])\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p>"},{"location":"in_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> adds a value to the list if it is missing.</li> <li><code>trim</code> removes a value from the list if it is not necessary.</li> </ul>"},{"location":"outsource/","title":"outsource(data)","text":""},{"location":"outsource/#general","title":"General","text":"<p>Storing snapshots in the source code is the main feature of inline snapshots. This has the advantage that you can easily see changes in code reviews. But it also has some problems:</p> <ul> <li>It is problematic to snapshot a lot of data, because it takes up a lot of space in your tests.</li> <li>Binary data or images are not readable in your tests.</li> </ul> <p>The <code>outsource()</code> function solves this problem and integrates itself nicely with the inline snapshot. It stores the data in a special <code>external()</code> object that can be compared in snapshots. The object is represented by the hash of the data. The actual data is stored in a separate file in your project.</p> <p>This allows the test to be renamed and moved around in your code without losing the connection to the stored data.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import external\n\n\ndef test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot(\n        external(\"f5a956460453*.txt\")\n    )\n</code></pre></p> <p>The <code>external</code> object can be used inside other data structures.</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import external\n\n\ndef test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot(\n        [\n            external(\"362ad8374ed6*.txt\"),\n            external(\"5755afea3f8d*.txt\"),\n            external(\"f5a956460453*.txt\"),\n        ]\n    )\n</code></pre></p>"},{"location":"outsource/#api","title":"API","text":""},{"location":"outsource/#inline_snapshot._external.outsource","title":"<code>outsource(data, *, suffix=None)</code>","text":"<p>Outsource some data into an external file.</p> <pre><code>&gt;&gt;&gt; png_data = b\"some_bytes\"  # should be the replaced with your actual data\n&gt;&gt;&gt; outsource(png_data, suffix=\".png\")\nexternal(\"212974ed1835*.png\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes]</code> <p>data which should be outsourced. strings are encoded with <code>\"utf-8\"</code>.</p> required <code>suffix</code> <code>Optional[str]</code> <p>overwrite file suffix. The default is <code>\".bin\"</code> if data is an instance of <code>bytes</code> and <code>\".txt\"</code> for <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>external</code> <p>The external data.</p>"},{"location":"outsource/#inline_snapshot._external.external","title":"<code> external        </code>","text":""},{"location":"outsource/#inline_snapshot._external.external.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":"<p>Two external objects are equal if they have the same hash and suffix.</p>"},{"location":"outsource/#inline_snapshot._external.external.__init__","title":"<code>__init__(self, name)</code>  <code>special</code>","text":"<p>External objects are used as a representation for outsourced data. You should not create them directly.</p> <p>The external data is stored inside <code>&lt;pytest_config_dir&gt;/.inline_snapshot/external</code>, where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any. Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the external stored object.</p> required"},{"location":"outsource/#inline_snapshot._external.external.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Returns the representation of the external object.</p> <p>The length of the hash can be specified in the config.</p>"},{"location":"outsource/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>trim</code> removes every snapshots form the storage which is not referenced with <code>external(...)</code> in the code.</li> </ul>"},{"location":"pytest/","title":"pytest integration","text":"<p>inline-snapshot provides one pytest option with different flags (create, fix, trim, update, short-report, report, disable).</p> <p>Snapshot comparisons return always <code>True</code> if you use one of the flags create, fix or review. This is necessary because the whole test needs to be run to fix all snapshots like in this case:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot(5)\n    assert 2 &lt;= snapshot(5)\n</code></pre> <p>Note</p> <p>Every flag with the exception of disable and short-report disables the pytest assert-rewriting.</p>"},{"location":"pytest/#-inline-snapshotcreatefixtrimupdate","title":"--inline-snapshot=create,fix,trim,update","text":"<p>Approve the changes of the given category. These flags can be combined with report and review.</p> test_something.py<pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot()\n    assert 2 &lt;= snapshot(5)\n</code></pre> <pre><code>&gt; pytest test_something.py --inline-snapshot=create,report\nenvironment: line 10: pytest: command not found\n</code></pre>"},{"location":"pytest/#-inline-snapshotshort-report","title":"--inline-snapshot=short-report","text":"<p>give a short report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=short-report\n/usr/local/bin/python: No module named pytest\n</code></pre> <p>Info</p> <p>short-report exists mainly to show that snapshots have changed with enabled pytest assert-rewriting. This option will be replaced with report when this restriction is lifted.</p>"},{"location":"pytest/#-inline-snapshotreport","title":"--inline-snapshot=report","text":"<p>Shows a diff report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=report\nenvironment: line 10: pytest: command not found\n</code></pre>"},{"location":"pytest/#-inline-snapshotreview","title":"--inline-snapshot=review","text":"<p>Shows a diff report for each category and ask if you want to apply the changes</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=review\nenvironment: line 10: pytest: command not found\n</code></pre>"},{"location":"pytest/#-inline-snapshotdisable","title":"--inline-snapshot=disable","text":"<p>Disables all the snapshot logic. <code>snapshot(x)</code> will just return <code>x</code>. This can be used if you think exclude that snapshot logic causes a problem in your tests, or if you want to speedup your CI.</p> <p>deprecation</p> <p>This option was previously called <code>--inline-snapshot-disable</code></p>"}]}