{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-inline-snapshot","title":"Welcome to inline-snapshot","text":"<p>inline-snapshot can be used for different things:</p> <ul> <li>golden master/approval/snapshot testing.   The idea is that you have a function with a currently unknown result and you want to write a test, which ensures that the result does not change during refactoring.</li> <li>Compare things which are complex like lists with lot of numbers or complex data structures.</li> <li>Things which might change during the development like error messages.</li> </ul> <p><code>inline-snapshot</code> automates the process of recording, storing and updating the value you want to compare with. The value is converted with <code>repr()</code> and stored in the source file as argument of the <code>snapshot()</code> function.</p> <p>News</p> <p>Hello, I would like to inform you about some changes.</p> <p>I have started to offer insider features for inline-snapshot. I will only release features as insider features if they will not cause problems for you when used in an open source project.</p> <p>I hope this will allow me to spend more time working on open source projects. Thank you for using inline-snapshot, the future will be \ud83d\ude80.</p> <p>The first feature is that inline-snapshot can now also fix normal assertions which do not use <code>snapshot()</code> like:</p> <pre><code>assert 1 + 1 == 3\n</code></pre> <p>You can learn here more about this feature.</p>"},{"location":"#usage","title":"Usage","text":"<p>You can use <code>snapshot()</code> instead of the value which you want to compare with and run the tests to record the correct values.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p>Your tests will break, if you change your code by adding <code>// 18</code>. Maybe that is correct and you should fix your code, or your code is correct and you want to update your test results.</p> changed code--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(1590054)\n</code></pre></p> <p>Please verify the new results. <code>git diff</code> will give you a good overview over all changed results. Use <code>pytest -k test_something --inline-snapshot=fix</code> if you only want to change one test.</p>"},{"location":"#supported-operations","title":"Supported operations","text":"<p>You can use <code>snapshot(x)</code> like you can use <code>x</code> in your assertion with a limited set of operations:</p> <ul> <li><code>value == snapshot()</code> to compare with something,</li> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</li> </ul> <p>Warning</p> <p>One snapshot can only be used with one operation. The following code will not work:  <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot(5)\n    assert 5 &lt;= s\n    assert 5 == s\n\n\n# Error:\n# &gt;       assert 5 == s\n# E       TypeError: This snapshot cannot be use with `==`, because it was previously used with `x &lt;= snapshot`\n</code></pre></p>"},{"location":"#supported-usage","title":"Supported usage","text":"<p>It is possible to place <code>snapshot()</code> anywhere in the tests and reuse it multiple times.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 21 * 2\n\n\nresult = snapshot()\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 21 * 2\n\n\nresult = snapshot(42)\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p><code>snapshot()</code> can also be used in loops:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot(3)\n</code></pre></p> <p>or passed as an argument to a function:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot())\n    check_string_len(\"1234\", snapshot())\n    check_string_len(\".......\", snapshot())\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot(3))\n    check_string_len(\"1234\", snapshot(4))\n    check_string_len(\".......\", snapshot(7))\n</code></pre></p>"},{"location":"#feedback","title":"Feedback","text":"<p>inline-snapshot provides some advanced ways to work with snapshots.</p> <p>I would like to know how these features are used to further improve this small library. Let me know if you've found interesting use cases for this library via twitter, fosstodon or in the github discussions.</p>"},{"location":"#sponsors","title":"Sponsors","text":"<p>I would like to thank my sponsors. Without them, I would not be able to invest so much time in my projects.</p>"},{"location":"#silver-sponsor","title":"Silver sponsor \ud83e\udd48","text":"<p>I have also started to offer insider features for inline-snapshot. I will only release features as insider features if they will not cause problems for you when used in an open source project. I hope sponsoring will allow me to spend more time working on open source projects. Thank you for using inline-snapshot, the future will be \ud83d\ude80.</p>"},{"location":"#issues","title":"Issues","text":"<p>If you encounter any problems, please report an issue along with a detailed description.</p>"},{"location":"alternatives/","title":"Alternatives","text":"<p>inline-snapshot is not the only snapshot testing library for python. There are several others to:</p> <ul> <li>syrupy</li> <li>snapshottest</li> <li>pytest-snapshot</li> <li>pytest-insta</li> </ul> <p>All of them have things that make them unique. What sets inline-snapshot apart is the ability to store snapshots directly in the source code. This leads to less indirections in the code which improves readability and code-reviews.</p> <p>If you miss a feature that is available in other libraries, please let me know.</p> <p> </p>"},{"location":"categories/","title":"Categories","text":"<p>Each snapshot change is assigned to a different category. This is done because inline-snapshot supports more than just <code>==</code> checks.</p> <p>There are changes which:</p> <ul> <li>create new snapshot values</li> <li>fix your tests</li> <li>update only the syntax to a new representation</li> <li>trim unused pieces from your snapshots</li> </ul> <p>Create and fix are mainly used, but it is good to know what type of change you are approving, because it helps with the decision if this changes should be applied.</p>"},{"location":"categories/#categories","title":"Categories","text":""},{"location":"categories/#create","title":"Create","text":"<p>These changes are made when new snapshots are created.</p> <p>The result of each comparison is <code>True</code>, which allows to run the whole test to fill all new snapshots with values.</p> <p>Example:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 5 == snapshot()\n\n    assert 5 &lt;= snapshot()\n\n    assert 5 in snapshot()\n\n    s = snapshot()\n    assert 5 == s[\"key\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 5 == snapshot(5)\n\n    assert 5 &lt;= snapshot(5)\n\n    assert 5 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 5 == s[\"key\"]\n</code></pre>"},{"location":"categories/#fix","title":"Fix","text":"<p>These changes are made when the snapshots comparison does not return <code>True</code> any more (depending on the operation <code>==</code>, <code>&lt;=</code>, <code>in</code>). The result of each comparison is <code>True</code> if you change something from this category, which allows to run the whole test and to fix other snapshots.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 8 == snapshot(5)\n\n    assert 8 &lt;= snapshot(5)\n\n    assert 8 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 8 == s[\"key\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 8 == snapshot(8)\n\n    assert 8 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key\": 8})\n    assert 8 == s[\"key\"]\n</code></pre> <p>Info</p> <p>The main reason for the different categories is to make the number of changes in the fix category as small as possible. The changes in the fix category are the only changes which change the value of the snapshots and should be reviewed carefully.</p>"},{"location":"categories/#trim","title":"Trim","text":"<p>These changes are made when parts of the snapshots are removed which are no longer needed, or if limits can be reduced.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key1\": 1, \"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 &lt;= snapshot(2)\n\n    assert 8 in snapshot([8])\n\n    s = snapshot({\"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <p>There might be problems in cases where you use the same snapshot in different tests, run only one test and trim the snapshot with <code>pytest -k test_a --inline-snapshot=trim</code> in this case:</p> <pre><code>from inline_snapshot import snapshot\n\ns = snapshot(5)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\ns = snapshot(2)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <p>The value of the snapshot is reduced to <code>2</code>, because <code>test_a()</code> was the only test running and inline-snapshot does not know about <code>5 &lt;= s</code>. It is recommended to use trim only if you run your complete test suite.</p>"},{"location":"categories/#update","title":"Update","text":"<p>Changes in the update category do not change the value of the snapshot, just its representation. These updates are not shown by default in your reports and can be enabled with show-updates. The reason might be that <code>repr()</code> of the object has changed or that inline-snapshot provides some new logic which changes the representation. Like with the strings in the following example:</p> original--inline-snapshot=update <p> <pre><code>from inline_snapshot import snapshot\n\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\"a\\nb\\nc\\n\")\n\n    assert 5 == snapshot(4 + 1)\n\n    assert Vector(1, 2) == snapshot(Vector(x=1, y=2))\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\n        \"\"\"\\\na\nb\nc\n\"\"\"\n    )\n\n    assert 5 == snapshot(5)\n\n    assert Vector(1, 2) == snapshot(Vector(1, 2))\n</code></pre></p> <p>The approval of this type of changes is easier, because inline-snapshot assures that the value has not changed.</p> <p>The goal of inline-snapshot is to generate the values for you in the correct format so that no manual editing is required. This improves your productivity and saves time. Keep in mind that any changes you make to your snapshots will likely need to be redone if your program's behaviour (and expected values) change. Inline-snapshot uses the update category to let you know when it has a different opinion than you about how the code should look. You can agree with inline-snapshot and accept the changes or you can use one of the following options to tell inline-snapshot what the code should look like:</p> <ol> <li> <p>change the <code>__repr__</code> implementation of your object or use customize repr if the class is not part of your codebase.</p> </li> <li> <p>define a format-command if another tool has a different opinion about how your code should look. Inline-snapshot will apply this formatting before reporting an update.</p> </li> <li> <p>inline-snapshot manages everything within <code>snapshot(...)</code>, but you can take control by using Is() in cases where you want to use custom code (like local variables) in your snapshots.</p> </li> <li> <p>you can also open an issue if you have a specific problem with the way inline-snapshot generates the code.</p> </li> </ol> <p>!!! note:     #177 will give the developer more control about how snapshots are created. update will them become much more useful.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#exec-1--upcoming-version-no-tag-matching-configuration-could-be-found","title":"upcoming version (No tag matching configuration could be found.","text":"<p>Possible causes: - version in configuration is not the current version - tag_format or legacy_tag_formats is missing, check them using 'git tag --list'</p> <p>? Is this the first tag created? (Y/n)</p> <pre><code>                                    ? Is this the first tag created? (Y/n))\n</code></pre>"},{"location":"changelog/#exec-1--removed","title":"Removed","text":"<ul> <li>removed support for python 3.8 and 3.9 because they are end-of-life</li> </ul>"},{"location":"changelog/#exec-1--0311-2025-11-07","title":"0.31.1 \u2014 2025-11-07","text":""},{"location":"changelog/#exec-1--fixed","title":"Fixed","text":"<ul> <li>Format commands with pipelines (using <code>|</code>) now properly fail when any command in the pipeline returns a non-zero exit code (#320). Previously, only the last command's exit code was considered, which could allow formatting to succeed even when intermediate commands failed.</li> </ul>"},{"location":"changelog/#exec-1--0310-2025-10-27","title":"0.31.0 \u2014 2025-10-27","text":""},{"location":"changelog/#exec-1--changed","title":"Changed","text":"<ul> <li> <p>BREAKING CHANGE: An exception is now raised when you use <code>external()</code> in files that are not inside your <code>tests/</code> directory (or any other directory that you can configure with tool.inline-snapshot.test-dir).</p> </li> <li> <p>Users are now notified if they use the same UUID for multiple external snapshots, which can happen when copying one test as a template for a new test. The snapshots should be reset to an empty <code>external()</code> and recreated with inline-snapshot.</p> </li> </ul>"},{"location":"changelog/#exec-1--fixed_1","title":"Fixed","text":"<ul> <li> <p>Updated <code>--snapshot</code> flag to <code>--inline-snapshot</code> in session hints (#316).</p> </li> <li> <p>The lookup for external snapshots has been improved (#292).</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0301-2025-10-20","title":"0.30.1 \u2014 2025-10-20","text":""},{"location":"changelog/#exec-1--fixed_2","title":"Fixed","text":"<ul> <li>Disable ensure ascii in json.dump to support non-ASCII characters in external files</li> </ul>"},{"location":"changelog/#exec-1--0300-2025-10-15","title":"0.30.0 \u2014 2025-10-15","text":""},{"location":"changelog/#exec-1--added","title":"Added","text":"<ul> <li> <p>The <code>test-dir</code> config option can now also be a list of paths (#307)</p> </li> <li> <p>added Python 3.14 support</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0294-2025-10-13","title":"0.29.4 \u2014 2025-10-13","text":""},{"location":"changelog/#exec-1--changed_1","title":"Changed","text":"<ul> <li><code>External.run_inline()</code> now uses the same logic as <code>External.run_pytest</code>.</li> </ul>"},{"location":"changelog/#exec-1--fixed_3","title":"Fixed","text":"<ul> <li>inline-snapshot now supports different Python file encodings and recognizes encoding comments such as <code># -*- coding: windows-1251 -*-</code> (#305).</li> </ul>"},{"location":"changelog/#exec-1--0293-2025-10-04","title":"0.29.3 \u2014 2025-10-04","text":""},{"location":"changelog/#exec-1--fixed_4","title":"Fixed","text":"<ul> <li>xdist is now detected properly.</li> </ul>"},{"location":"changelog/#exec-1--0292-2025-10-01","title":"0.29.2 \u2014 2025-10-01","text":""},{"location":"changelog/#exec-1--fixed_5","title":"Fixed","text":"<ul> <li> <p>fixed string formatting with black which caused invalid snapshots (#301)</p> <pre><code>assert \" a \" == snapshot(\"a\")\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0291-2025-09-24","title":"0.29.1 \u2014 2025-09-24","text":""},{"location":"changelog/#exec-1--changed_2","title":"Changed","text":"<ul> <li><code>Example.run_inline</code> can now be used with <code>[\"--inline-snapshot=disable\"]</code>.</li> </ul>"},{"location":"changelog/#exec-1--fixed_6","title":"Fixed","text":"<ul> <li><code>--inline-snapshot=report</code> now shows the same changes for external snapshots as <code>--inline-snapshot=review</code> (#298).</li> <li>Fixed a crash when generating reports for <code>external_file(\"some_non_existing_file.txt\")</code>.</li> </ul>"},{"location":"changelog/#exec-1--0290-2025-09-15","title":"0.29.0 \u2014 2025-09-15","text":""},{"location":"changelog/#exec-1--fixed_7","title":"Fixed","text":"<ul> <li>handle in cases where <code>pytest_unconfigure</code> is called but not <code>pytest_configure</code> (#293)</li> </ul>"},{"location":"changelog/#exec-1--0280-2025-08-24","title":"0.28.0 \u2014 2025-08-24","text":""},{"location":"changelog/#exec-1--added_1","title":"Added","text":"<ul> <li>Added <code>get_snapshot_value()</code>, which removes all snapshot-specific wrappers and returns only the value of the snapshot.</li> </ul>"},{"location":"changelog/#exec-1--0272-2025-08-11","title":"0.27.2 \u2014 2025-08-11","text":""},{"location":"changelog/#exec-1--changed_3","title":"Changed","text":"<ul> <li>Improved documentation for <code>inline_snapshot.testing.Example</code>.</li> </ul>"},{"location":"changelog/#exec-1--fixed_8","title":"Fixed","text":"<ul> <li>inline-snapshot generates no longer triple quoted strings when it fixes cases like this (#281):     <pre><code>from inline_snapshot import snapshot\n\n\ndef test_a():\n    assert \"\" == snapshot(\n        \"\"\"\na\nb\\\n\"\"\"\n    )\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0271-2025-08-08","title":"0.27.1 \u2014 2025-08-08","text":""},{"location":"changelog/#exec-1--fixed_9","title":"Fixed","text":"<ul> <li>Added explicit type hints to the <code>outsource()</code> function</li> </ul>"},{"location":"changelog/#exec-1--0270-2025-08-05","title":"0.27.0 \u2014 2025-08-05","text":""},{"location":"changelog/#exec-1--added_2","title":"Added","text":"<ul> <li> <p>Added <code>inline_snapshot.extra.Transformed</code> and <code>inline_snapshot.extra.transformation</code> which can be used to transform values inside of snapshots.</p> </li> <li> <p>exposed <code>@declare_unmanaged</code> which allows you to create your own unmanaged types.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0260-2025-07-31","title":"0.26.0 \u2014 2025-07-31","text":""},{"location":"changelog/#exec-1--changed_4","title":"Changed","text":"<ul> <li>You now have to specify <code>test-dir</code> in your pyproject.toml when you save your tests in a folder other than <code>tests/</code> in your project root (#272).</li> </ul>"},{"location":"changelog/#exec-1--fixed_10","title":"Fixed","text":"<ul> <li><code>pyproject.toml</code> is now also located based on the current directory and the <code>pytest-root</code>, which solves problems when you use inline-snapshot with uv-workspaces (#272).</li> </ul>"},{"location":"changelog/#exec-1--0253-2025-07-27","title":"0.25.3 \u2014 2025-07-27","text":""},{"location":"changelog/#exec-1--fixed_11","title":"Fixed","text":"<ul> <li>cleanup temporary path</li> </ul>"},{"location":"changelog/#exec-1--0252-2025-07-25","title":"0.25.2 \u2014 2025-07-25","text":""},{"location":"changelog/#exec-1--fixed_12","title":"Fixed","text":"<ul> <li>Terminal with is preserved (#212)</li> <li> <p>solved incompatibility with pytest_pretty (#265)</p> </li> <li> <p>improved performance by checking for <code>\"external\"</code> in the code string before parsing the code and checking the AST (#272).</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0251-2025-07-24","title":"0.25.1 \u2014 2025-07-24","text":""},{"location":"changelog/#exec-1--changed_5","title":"Changed","text":"<ul> <li>Removed unnecessary uuid7 dependency introduced in 0.25.0</li> </ul>"},{"location":"changelog/#exec-1--fixed_13","title":"Fixed","text":"<ul> <li><code>external_file()</code> now follows the aliases defined by <code>register_format_alias()</code>.</li> </ul>"},{"location":"changelog/#exec-1--0250-2025-07-23","title":"0.25.0 \u2014 2025-07-23","text":""},{"location":"changelog/#exec-1--added_3","title":"Added","text":"<ul> <li>New <code>external()</code> implementation with support for different data formats.</li> <li>Ability to declare custom external formats with <code>@register_format</code>.</li> <li><code>external()</code> can now be used without <code>snapshot()</code>, such as <code>assert \"long text\" == external()</code> or inside snapshots like dirty-equals.</li> </ul>"},{"location":"changelog/#exec-1--changed_6","title":"Changed","text":"<ul> <li> <p>BREAKING CHANGE: You now have to declare format aliases if you used <code>outsource()</code> with a different suffix than <code>.txt</code> or <code>.bin</code> in the past.</p> <pre><code>from inline_snapshot import register_format_alias, external\n\n# Can be declared in conftest.py\nregister_format_alias(\".html\", \".txt\")\n\n\ndef test_html():\n    assert outsource(\"&lt;html&gt;&lt;/html&gt;\", suffix=\".html\") == snapshot()\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0240-2025-07-15","title":"0.24.0 \u2014 2025-07-15","text":""},{"location":"changelog/#exec-1--added_4","title":"Added","text":"<ul> <li> <p>Add/fix reproducible standard repr for functions</p> </li> <li> <p>added <code>llms.txt</code> to make the documentation for llms more accessible.</p> </li> </ul>"},{"location":"changelog/#exec-1--changed_7","title":"Changed","text":"<ul> <li> <p>Improved the explanation of what it means when snapshots are disabled in CI runs (#226).</p> </li> <li> <p>Added extra information to the reported failure when snapshots are fixed or created (#240).</p> </li> </ul>"},{"location":"changelog/#exec-1--fixed_14","title":"Fixed","text":"<ul> <li> <p>fixed the representation of empty strings in sub-snapshots from triple-quotes to single-quotes <code>assert \"\"==snapshot({5: \"\"})[5]</code> (#258).</p> </li> <li> <p>fix: changed format-command default to <code>\"\"</code> (#256).</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0232-2025-05-28","title":"0.23.2 \u2014 2025-05-28","text":""},{"location":"changelog/#exec-1--fixed_15","title":"Fixed","text":"<ul> <li>The <code>readline</code> module doesn't have to be installed on non-windows systems.</li> </ul>"},{"location":"changelog/#exec-1--0231-2025-05-26","title":"0.23.1 \u2014 2025-05-26","text":""},{"location":"changelog/#exec-1--changed_8","title":"Changed","text":"<ul> <li>changed how the <code>Snapshot[T]</code> type is implemented.</li> </ul>"},{"location":"changelog/#exec-1--fixed_16","title":"Fixed","text":"<ul> <li>command line flags work again in CI (#242)</li> </ul>"},{"location":"changelog/#exec-1--0230-2025-04-25","title":"0.23.0 \u2014 2025-04-25","text":""},{"location":"changelog/#exec-1--changed_9","title":"Changed","text":"<ul> <li>snapshot updates are now disabled by default. They be enabled with <code>show-updates=true</code> in your config. This is done because they can confuse new inline-snapshot users and does not fit the way how most users work with inline-snapshot. updates will become much more useful when (#177) is implemented.</li> </ul>"},{"location":"changelog/#exec-1--0223-2025-04-14","title":"0.22.3 \u2014 2025-04-14","text":""},{"location":"changelog/#exec-1--fixed_17","title":"Fixed","text":"<ul> <li>A pycharm environment is no longer incorrectly recognized as a CI environment.</li> </ul>"},{"location":"changelog/#exec-1--0222-2025-04-14","title":"0.22.2 \u2014 2025-04-14","text":""},{"location":"changelog/#exec-1--fixed_18","title":"Fixed","text":"<ul> <li>show correct diff when <code>pytest --inline-snapshot=report -vv</code> is used (#231)</li> </ul>"},{"location":"changelog/#exec-1--0221-2025-04-11","title":"0.22.1 \u2014 2025-04-11","text":""},{"location":"changelog/#exec-1--fixed_19","title":"Fixed","text":"<ul> <li> <p>The environment variable <code>INLINE_SNAPSHOT_DEFAULT_FLAGS</code> now takes precedence over all default flags defined in pyproject.toml.</p> </li> <li> <p>inline-snapshot can now be used in combination with <code>pytester.runpytest()</code></p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0220-2025-04-03","title":"0.22.0 \u2014 2025-04-03","text":""},{"location":"changelog/#exec-1--added_5","title":"Added","text":"<ul> <li>You can now use the config option <code>skip-snapshot-updates-for-now</code> to skip the reporting of updates.   But be aware that this option might not be there forever. Please create an issue if you think that the creation of snapshots can be improved.</li> </ul>"},{"location":"changelog/#exec-1--0213-2025-04-02","title":"0.21.3 \u2014 2025-04-02","text":""},{"location":"changelog/#exec-1--fixed_20","title":"Fixed","text":"<ul> <li>Allowed inline-snapshot to work when pytest-xdist is disabled with <code>-n 0</code>.</li> </ul>"},{"location":"changelog/#exec-1--0212-2025-03-31","title":"0.21.2 \u2014 2025-03-31","text":""},{"location":"changelog/#exec-1--fixed_21","title":"Fixed","text":"<ul> <li><code>repr(Is(x))</code> returns the same value as <code>repr(x)</code> to provide nice pytest outputs (#217)</li> </ul>"},{"location":"changelog/#exec-1--0211-2025-03-29","title":"0.21.1 \u2014 2025-03-29","text":""},{"location":"changelog/#exec-1--changed_10","title":"Changed","text":"<ul> <li>trailing white spaces in multi-line strings are now terminated with an <code>\\n\\</code>.     <pre><code>def test_something():\n    assert \"a   \\nb\\n\" == snapshot(\n        \"\"\"\\\na   \\n\\\nb\n\"\"\"\n    )\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0210-2025-03-28","title":"0.21.0 \u2014 2025-03-28","text":""},{"location":"changelog/#exec-1--changed_11","title":"Changed","text":"<ul> <li> <p>inline-snapshot uses now <code>--inline-snapshot=disable</code> during CI runs by default.     This improves performance because <code>snapshot()</code> is then equal to:     <pre><code>def snapshot(x):\n    return x\n</code></pre>     It also has benefits for the accuracy of your tests as it is less likely that inline snapshot will affect your tests in CI.</p> </li> <li> <p>The default flags have changed for cpython &gt;= 3.11:</p> <ul> <li><code>--inline-snapshot=create,review</code> is used in an interactive terminal and</li> <li><code>--inline-snapshot=report</code> otherwise.</li> </ul> </li> <li> <p>The categories in the terminal output are now links to the documentation if it is supported by the terminal.</p> </li> </ul>"},{"location":"changelog/#exec-1--fixed_22","title":"Fixed","text":"<ul> <li>Hide update section if the diff is empty because the change is reverted by the format-command.</li> </ul>"},{"location":"changelog/#exec-1--02010-2025-03-26","title":"0.20.10 \u2014 2025-03-26","text":""},{"location":"changelog/#exec-1--fixed_23","title":"Fixed","text":"<ul> <li>Use of the correct snapshot category (update/fix) when deleting dataclass arguments.</li> </ul>"},{"location":"changelog/#exec-1--0209-2025-03-23","title":"0.20.9 \u2014 2025-03-23","text":""},{"location":"changelog/#exec-1--fixed_24","title":"Fixed","text":"<ul> <li><code>--inline-snapshot=create</code> preserves test failures now.</li> </ul>"},{"location":"changelog/#exec-1--0208-2025-03-20","title":"0.20.8 \u2014 2025-03-20","text":""},{"location":"changelog/#exec-1--fixed_25","title":"Fixed","text":"<ul> <li>inline-snapshot now also works if you use <code>--no-summary</code> (which pycharm does if you run your tests from the IDE).</li> </ul>"},{"location":"changelog/#exec-1--0207-2025-03-14","title":"0.20.7 \u2014 2025-03-14","text":""},{"location":"changelog/#exec-1--changed_12","title":"Changed","text":"<ul> <li>Tests with failed snapshot comparisons now always result in a pytest <code>Error</code>, even if snapshots have been fixed or created.</li> </ul>"},{"location":"changelog/#exec-1--0206-2025-03-13","title":"0.20.6 \u2014 2025-03-13","text":""},{"location":"changelog/#exec-1--fixed_26","title":"Fixed","text":"<ul> <li>Do not skip snapshots in conditional marked xfail tests.   <pre><code>@pytest.mark.xfail(False, reason=\"...\")\ndef test_a():\n    assert 5 == snapshot(3)  # &lt;- this will be fixed\n\n\n@pytest.mark.xfail(True, reason=\"...\")\ndef test_b():\n    assert 5 == snapshot(3)  # &lt;- this not\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0205-2025-03-04","title":"0.20.5 \u2014 2025-03-04","text":""},{"location":"changelog/#exec-1--fixed_27","title":"Fixed","text":"<ul> <li>correct normalization of \"python3.9\" to \"python\" in tests</li> </ul>"},{"location":"changelog/#exec-1--0204-2025-03-03","title":"0.20.4 \u2014 2025-03-03","text":""},{"location":"changelog/#exec-1--fixed_28","title":"Fixed","text":"<ul> <li>Prevent a crash if a value cannot be copied and a UsageError is raised.</li> </ul>"},{"location":"changelog/#exec-1--0203-2025-02-28","title":"0.20.3 \u2014 2025-02-28","text":""},{"location":"changelog/#exec-1--fixed_29","title":"Fixed","text":"<ul> <li>Use the black API directly to format python code.   This solves issues with the upcoming click 8.2.0 (#202) and problems in multithreading (https://github.com/15r10nk/inline-snapshot/pull/193#issuecomment-2660393512).</li> </ul>"},{"location":"changelog/#exec-1--0202-2025-02-13","title":"0.20.2 \u2014 2025-02-13","text":""},{"location":"changelog/#exec-1--fixed_30","title":"Fixed","text":"<ul> <li> <p>snapshots inside tests which are marked as xfail are now ignored (#184)</p> </li> <li> <p>Fixed a crash caused by the following code:</p> </li> </ul> <pre><code>snapshot(tuple())\n# or\nsnapshot(dict())\n</code></pre> <p></p>"},{"location":"changelog/#exec-1--0201-2025-02-04","title":"0.20.1 \u2014 2025-02-04","text":""},{"location":"changelog/#exec-1--fixed_31","title":"Fixed","text":"<ul> <li>Fixed a windows bug with the readline module (#189)</li> </ul>"},{"location":"changelog/#exec-1--0200-2025-02-01","title":"0.20.0 \u2014 2025-02-01","text":""},{"location":"changelog/#exec-1--changed_13","title":"Changed","text":"<ul> <li> <p>pytest assert rewriting works now together with inline-snapshot if you use <code>cpython&gt;=3.11</code></p> </li> <li> <p><code>...</code> is now a special value to create snapshot values.    The value change in <code>assert [5,4] == snapshot([5,...])</code> is now a create (previously it was a fix)</p> </li> </ul>"},{"location":"changelog/#exec-1--fixed_32","title":"Fixed","text":"<ul> <li> <p>fixed some issues with dataclass arguments</p> </li> <li> <p>fixed an issue where --inline-snapshot=review discarded the user input and never formatted   the code if you used cpython 3.13.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0193-2025-01-15","title":"0.19.3 \u2014 2025-01-15","text":""},{"location":"changelog/#exec-1--fixed_33","title":"Fixed","text":"<ul> <li>raise no assertion for positional arguments inside constructor methods.</li> </ul>"},{"location":"changelog/#exec-1--0192-2025-01-15","title":"0.19.2 \u2014 2025-01-15","text":""},{"location":"changelog/#exec-1--fixed_34","title":"Fixed","text":"<ul> <li> <p>fixed a crash when you changed the snapshot to use a custom constructor method for dataclass/pydantic models.</p> <p>example: <pre><code>from inline_snapshot import snapshot\nfrom pydantic import BaseModel\n\n\nclass A(BaseModel):\n    a: int\n\n    @classmethod\n    def from_str(cls, s):\n        return cls(a=int(s))\n\n\ndef test_something():\n    assert A(a=2) == snapshot(A.from_str(\"1\"))\n</code></pre></p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0191-2025-01-12","title":"0.19.1 \u2014 2025-01-12","text":""},{"location":"changelog/#exec-1--added_6","title":"Added","text":"<ul> <li>added the optional <code>inline-snapshot[dirty-equals]</code> dependency to depend on the dirty-equals version which works in combination with inline-snapshot.</li> </ul>"},{"location":"changelog/#exec-1--fixed_35","title":"Fixed","text":"<ul> <li> <p>snapshots with pydantic models can now be compared multiple times</p> <pre><code>class A(BaseModel):\n    a: int\n\n\ndef test_something():\n    for _ in [1, 2]:\n        assert A(a=1) == snapshot(A(a=1))\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0190-2025-01-10","title":"0.19.0 \u2014 2025-01-10","text":""},{"location":"changelog/#exec-1--added_7","title":"Added","text":"<ul> <li>You can now specify which tool you want to use to format your code by setting a <code>format-command</code> in your configuration.</li> </ul>"},{"location":"changelog/#exec-1--changed_14","title":"Changed","text":"<ul> <li>BREAKING-CHANGE you have to install <code>inline-snapshot[black]</code> now if you want to format your code like in the previous versions. This option is not required if you use a <code>format-command</code>.</li> </ul>"},{"location":"changelog/#exec-1--fixed_36","title":"Fixed","text":"<ul> <li>Load default config values even if <code>[tool.inline-snapshot]</code> is missing.   This makes the documented default shortcuts <code>--review</code> and <code>--fix</code> work.</li> </ul>"},{"location":"changelog/#exec-1--0182-2025-01-02","title":"0.18.2 \u2014 2025-01-02","text":""},{"location":"changelog/#exec-1--changed_15","title":"Changed","text":"<ul> <li>added <code>[dependency-groups]</code> to pyproject.toml and use uv and pytest to run tests in CI.</li> </ul>"},{"location":"changelog/#exec-1--fixed_37","title":"Fixed","text":"<ul> <li>use '.model_fields' on pydantic model class and not instance. This fixes a deprecation warning in the upcoming pydantic v2.11 (#169)</li> </ul>"},{"location":"changelog/#exec-1--0181-2024-12-22","title":"0.18.1 \u2014 2024-12-22","text":""},{"location":"changelog/#exec-1--fixed_38","title":"Fixed","text":"<ul> <li>uv is now only used during test time if you run the inline-snapshot tests with <code>pytest --use-uv</code>   This solves a problem if you want to package inline-snapshot in distributions (#165)</li> </ul>"},{"location":"changelog/#exec-1--0180-2024-12-21","title":"0.18.0 \u2014 2024-12-21","text":""},{"location":"changelog/#exec-1--added_8","title":"Added","text":"<ul> <li>Support for a new <code>storage-dir</code> configuration option, to tell inline-snapshot where to store data files such as external snapshots.</li> </ul>"},{"location":"changelog/#exec-1--fixed_39","title":"Fixed","text":"<ul> <li> <p>pydantic v1 is supported again. pydantic v1 &amp; v2 create now the same snapshots. You can use <code>.dict()</code> to get the same snapshots like in inline-snapshot-0.15.0 for pydantic v1.</p> <pre><code>class M(BaseModel):\n    name: str\n\n\ndef test_pydantic():\n    m = M(name=\"Tom\")\n    assert m == snapshot(M(name=\"Tom\"))\n    assert m.dict() == snapshot({\"name\": \"Tom\"})\n</code></pre> </li> <li> <p>Find <code>pyproject.toml</code> file in parent directories, not just next to the Pytest configuration file.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0171-2024-12-17","title":"0.17.1 \u2014 2024-12-17","text":""},{"location":"changelog/#exec-1--fixed_40","title":"Fixed","text":"<ul> <li>Code generation for sets is now deterministic.   <pre><code>def test():\n    assert {1j, 2j, 1, 2, 3} == snapshot({1, 1j, 2, 2j, 3})\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0170-2024-12-14","title":"0.17.0 \u2014 2024-12-14","text":""},{"location":"changelog/#exec-1--added_9","title":"Added","text":"<ul> <li> <p>attrs can now contain unmanaged values</p> <pre><code>import datetime as dt\nimport uuid\nimport attrs\nfrom dirty_equals import IsDatetime\nfrom inline_snapshot import Is, snapshot\n\n\n@attrs.define\nclass Attrs:\n    ts: dt.datetime\n    id: uuid.UUID\n\n\ndef test():\n    id = uuid.uuid4()\n\n    assert Attrs(dt.datetime.now(), id) == snapshot(\n        Attrs(ts=IsDatetime(), id=Is(id))\n    )\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0160-2024-12-12","title":"0.16.0 \u2014 2024-12-12","text":""},{"location":"changelog/#exec-1--added_10","title":"Added","text":"<ul> <li><code>inline_snapshot.extra.warns</code> to captures warnings and compares them against expected warnings.     <pre><code>def test_warns():\n    with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n        warn(\"some problem\")\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0151-2024-12-10","title":"0.15.1 \u2014 2024-12-10","text":""},{"location":"changelog/#exec-1--fixed_41","title":"Fixed","text":"<ul> <li>solved a bug caused by a variable inside a snapshot (#148)</li> </ul>"},{"location":"changelog/#exec-1--0150-2024-12-10","title":"0.15.0 \u2014 2024-12-10","text":""},{"location":"changelog/#exec-1--added_11","title":"Added","text":"<ul> <li> <p>snapshots inside snapshots are now supported.</p> <pre><code>assert get_schema() == snapshot(\n    [\n        {\n            \"name\": \"var_1\",\n            \"type\": snapshot(\"int\") if version &lt; 2 else snapshot(\"string\"),\n        }\n    ]\n)\n</code></pre> </li> <li> <p>runtime values can now be part of snapshots.</p> <pre><code>from inline_snapshot import snapshot, Is\n\ncurrent_version = \"1.5\"\nassert request() == snapshot(\n    {\"data\": \"page data\", \"version\": Is(current_version)}\n)\n</code></pre> </li> <li> <p>f-strings can now also be used within snapshots, but are currently not fixed by inline-snapshot.</p> </li> </ul>"},{"location":"changelog/#exec-1--changed_16","title":"Changed","text":"<ul> <li>dirty-equals expressions are now treated like runtime values or snapshots within snapshots and are not modified by inline-snapshot.</li> </ul>"},{"location":"changelog/#exec-1--fixed_42","title":"Fixed","text":"<ul> <li> <p>inline-snapshot checks now if the given command line flags (<code>--inline-snapshot=...</code>) are valid</p> </li> <li> <p><code>Example(...).run_pytest(raise=snapshot(...))</code> uses now the flags from the current run and not the flags from the Example.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0142-2024-12-07","title":"0.14.2 \u2014 2024-12-07","text":""},{"location":"changelog/#exec-1--fixed_43","title":"Fixed","text":"<ul> <li>do not crash when handling raw f-strings (<code>rf\"\"</code>,<code>RF\"\"</code>,...) (#143)</li> </ul>"},{"location":"changelog/#exec-1--0141-2024-12-04","title":"0.14.1 \u2014 2024-12-04","text":""},{"location":"changelog/#exec-1--fixed_44","title":"Fixed","text":"<ul> <li> <p>Don't crash for snapshots like <code>snapshot(f\"\")</code> (#139)   It first appeared with pytest-8.3.4, but already existed before for cpython-3.11.   f-strings in snapshots are currently not official supported, but they should not lead to crashes.</p> </li> <li> <p>skip formatting if black returns an error (#138)</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0140-2024-11-10","title":"0.14.0 \u2014 2024-11-10","text":""},{"location":"changelog/#exec-1--removed_1","title":"Removed","text":"<ul> <li>removed the <code>\"Programming Language :: Python :: Implementation :: PyPy\"</code> classifier which was incorrect, because inline-snapshot can not fix snapshots on pypy.   inline-snapshot now enforces <code>--inline-snapshot=disable</code> when used with an implementation other than cpython, which allows it to be used in packages that want to support pypy.</li> </ul>"},{"location":"changelog/#exec-1--added_12","title":"Added","text":"<ul> <li>command line shortcuts can be defined to simplify your workflows. <code>--review</code> and <code>--fix</code> are defined by default. See the documentation for details.</li> </ul>"},{"location":"changelog/#exec-1--changed_17","title":"Changed","text":"<ul> <li><code>--inline-snapshot=create/fix/trim/update</code> will no longer show reports for other categories.   You can use <code>--inline-snapshot=create,report</code> if you want to use the old behaviour.</li> </ul>"},{"location":"changelog/#exec-1--0134-2024-11-07","title":"0.13.4 \u2014 2024-11-07","text":""},{"location":"changelog/#exec-1--changed_18","title":"Changed","text":"<ul> <li>use tomli instead of toml (#130)</li> </ul>"},{"location":"changelog/#exec-1--0133-2024-09-24","title":"0.13.3 \u2014 2024-09-24","text":""},{"location":"changelog/#exec-1--fixed_45","title":"Fixed","text":"<ul> <li>removed non-optional dirty-equals dependency (#118)</li> </ul>"},{"location":"changelog/#exec-1--0132-2024-09-24","title":"0.13.2 \u2014 2024-09-24","text":""},{"location":"changelog/#exec-1--changed_19","title":"Changed","text":"<ul> <li>star-expressions in list or dicts where never valid and cause a warning now.     <pre><code>    other=[2]\n    assert [5,2]==snapshot([5,*other])\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--fixed_46","title":"Fixed","text":"<ul> <li> <p>A snapshot which contains an dirty-equals expression can now be compared multiple times.</p> <pre><code>def test_something():\n    greeting = \"hello\"\n    for name in [\"alex\", \"bob\"]:\n        assert (name, greeting) == snapshot((IsString(), \"hello\"))\n</code></pre> </li> </ul>"},{"location":"changelog/#exec-1--v0131-2024-09-18","title":"v0.13.1 (2024-09-18)","text":""},{"location":"changelog/#exec-1--fix","title":"Fix","text":"<ul> <li>Use tomllib instead of PyPI toml on Python 3.11 and later</li> </ul>"},{"location":"changelog/#exec-1--v0130-2024-09-10","title":"v0.13.0 (2024-09-10)","text":""},{"location":"changelog/#exec-1--feat","title":"Feat","text":"<ul> <li>added extra.prints</li> <li>3.13 support</li> <li>strings with one line-break at the end become no multiline strings</li> </ul>"},{"location":"changelog/#exec-1--v0121-2024-08-05","title":"v0.12.1 (2024-08-05)","text":""},{"location":"changelog/#exec-1--fix_1","title":"Fix","text":"<ul> <li>add license to project metadata and some other fixes in pyproject.toml (#104)</li> </ul>"},{"location":"changelog/#exec-1--v0120-2024-07-22","title":"v0.12.0 (2024-07-22)","text":""},{"location":"changelog/#exec-1--feat_1","title":"Feat","text":"<ul> <li>implement extra.raises</li> <li>added inline_snapshot.testing.Example which can be used to test 3rd-party extensions</li> </ul>"},{"location":"changelog/#exec-1--v0110-2024-07-07","title":"v0.11.0 (2024-07-07)","text":""},{"location":"changelog/#exec-1--feat_2","title":"Feat","text":"<ul> <li>check if the result of copy.deepcopy() is equal to the copied value</li> <li>support for <code>enum.Enum</code>, <code>enum.Flag</code>, <code>type</code> and omitting of default values (#73)</li> </ul>"},{"location":"changelog/#exec-1--v0102-2024-05-28","title":"v0.10.2 (2024-05-28)","text":""},{"location":"changelog/#exec-1--fix_2","title":"Fix","text":"<ul> <li>changed how --inline-snapshot=disable works in combination with xdist (#90)</li> <li>fix typo, rename 'theme' with 'them'</li> </ul>"},{"location":"changelog/#exec-1--v0101-2024-05-26","title":"v0.10.1 (2024-05-26)","text":""},{"location":"changelog/#exec-1--fix_3","title":"Fix","text":"<ul> <li>trigger no update for trailing comma changes</li> </ul>"},{"location":"changelog/#exec-1--v0100-2024-05-21","title":"v0.10.0 (2024-05-21)","text":""},{"location":"changelog/#exec-1--breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>removed support for python 3.7</li> <li>removed <code>--inline-snapshot-disable</code> option and replaced it with <code>--inline-snapshot=disable</code></li> </ul>"},{"location":"changelog/#exec-1--feat_3","title":"Feat","text":"<ul> <li>new flags: disable, short-report, report and review</li> <li>added config option and environment variable to specify default flags</li> <li>show diff of changed snapshots in pytest report</li> <li>interactive review mode</li> </ul>"},{"location":"changelog/#exec-1--v090-2024-05-07","title":"v0.9.0 (2024-05-07)","text":""},{"location":"changelog/#exec-1--feat_4","title":"Feat","text":"<ul> <li>check if inline-snapshot is used in combination with xdist and notify the user that this is not possible</li> </ul>"},{"location":"changelog/#exec-1--fix_4","title":"Fix","text":"<ul> <li>change the quoting of strings does not trigger an update</li> </ul>"},{"location":"changelog/#exec-1--v082-2024-04-24","title":"v0.8.2 (2024-04-24)","text":""},{"location":"changelog/#exec-1--fix_5","title":"Fix","text":"<ul> <li>removed restriction that the snapshot functions has to be called snapshot (#72)</li> <li>report error in tear down for sub-snapshots with missing values (#70)</li> <li>element access in sub-snapshots does not create new values</li> </ul>"},{"location":"changelog/#exec-1--v081-2024-04-22","title":"v0.8.1 (2024-04-22)","text":""},{"location":"changelog/#exec-1--fix_6","title":"Fix","text":"<ul> <li>make typing less strict</li> </ul>"},{"location":"changelog/#exec-1--v080-2024-04-09","title":"v0.8.0 (2024-04-09)","text":""},{"location":"changelog/#exec-1--feat_5","title":"Feat","text":"<ul> <li>prevent dirty-equal values from triggering of updates</li> <li>fix lists by calculating the alignment of the changed values</li> <li>insert dict items</li> <li>delete dict items</li> <li>preserve not changed dict-values and list-elements</li> </ul>"},{"location":"changelog/#exec-1--fix_7","title":"Fix","text":"<ul> <li>update with UndecidedValue</li> <li>handle dicts with multiple insertions and deletions</li> <li>handle lists with multiple insertions and deletions</li> <li>fixed typing and coverage</li> </ul>"},{"location":"changelog/#exec-1--refactor","title":"Refactor","text":"<ul> <li>removed old needs* logic</li> <li>removed get_result</li> <li>use _get_changes api for DictValue</li> <li>use _get_changes api for CollectionValue</li> <li>use _get_changes api for MinMaxValue</li> <li>use _get_changes</li> <li>moved some functions</li> </ul>"},{"location":"changelog/#exec-1--v070-2024-02-27","title":"v0.7.0 (2024-02-27)","text":""},{"location":"changelog/#exec-1--feat_6","title":"Feat","text":"<ul> <li>removed old --update-snapshots option</li> </ul>"},{"location":"changelog/#exec-1--v061-2024-01-28","title":"v0.6.1 (2024-01-28)","text":""},{"location":"changelog/#exec-1--fix_8","title":"Fix","text":"<ul> <li>use utf-8 encoding to read and write source files</li> </ul>"},{"location":"changelog/#exec-1--v060-2023-12-10","title":"v0.6.0 (2023-12-10)","text":""},{"location":"changelog/#exec-1--feat_7","title":"Feat","text":"<ul> <li>store snapshot values in external files</li> </ul>"},{"location":"changelog/#exec-1--v052-2023-11-13","title":"v0.5.2 (2023-11-13)","text":""},{"location":"changelog/#exec-1--fix_9","title":"Fix","text":"<ul> <li>remove upper bound from dependency in pyproject.toml</li> </ul>"},{"location":"changelog/#exec-1--v051-2023-10-20","title":"v0.5.1 (2023-10-20)","text":""},{"location":"changelog/#exec-1--fix_10","title":"Fix","text":"<ul> <li>show better error messages</li> </ul>"},{"location":"changelog/#exec-1--v050-2023-10-15","title":"v0.5.0 (2023-10-15)","text":""},{"location":"changelog/#exec-1--feat_8","title":"Feat","text":"<ul> <li>support 3.12</li> </ul>"},{"location":"changelog/#exec-1--fix_11","title":"Fix","text":"<ul> <li>do not change empty snapshot if it is not used</li> </ul>"},{"location":"changelog/#exec-1--v040-2023-09-29","title":"v0.4.0 (2023-09-29)","text":""},{"location":"changelog/#exec-1--feat_9","title":"Feat","text":"<ul> <li>escaped linebreak at the start/end of multiline strings</li> </ul>"},{"location":"changelog/#exec-1--fix_12","title":"Fix","text":"<ul> <li>added py.typed</li> </ul>"},{"location":"changelog/#exec-1--v032-2023-07-31","title":"v0.3.2 (2023-07-31)","text":""},{"location":"changelog/#exec-1--fix_13","title":"Fix","text":"<ul> <li>handle update flag in sub-snapshots correctly</li> <li>fixed some edge cases where sub-snapshots had problems with some flags</li> <li>string literal concatenation should trigger no update</li> </ul>"},{"location":"changelog/#exec-1--v031-2023-07-14","title":"v0.3.1 (2023-07-14)","text":""},{"location":"changelog/#exec-1--fix_14","title":"Fix","text":"<ul> <li>added <code>__all__</code> to inline_snapshot</li> <li>flags fix/trim/create/update are changing the matching snapshots</li> </ul>"},{"location":"changelog/#exec-1--v030-2023-07-12","title":"v0.3.0 (2023-07-12)","text":""},{"location":"changelog/#exec-1--breaking-change_1","title":"BREAKING CHANGE","text":"<ul> <li>values have to be copyable with <code>copy.deepcopy</code></li> </ul>"},{"location":"changelog/#exec-1--fix_15","title":"Fix","text":"<ul> <li>snapshot the current value of mutable objects   <pre><code>l = [1]\nassert l == snapshot([1])  # old behaviour: snapshot([1, 2])\nl.append(2)\nassert l == snapshot([1, 2])\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--v021-2023-07-09","title":"v0.2.1 (2023-07-09)","text":""},{"location":"changelog/#exec-1--fix_16","title":"Fix","text":"<ul> <li>black configuration files are respected</li> </ul>"},{"location":"changelog/#exec-1--v020-2023-06-20","title":"v0.2.0 (2023-06-20)","text":""},{"location":"changelog/#exec-1--feat_10","title":"Feat","text":"<ul> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li> <p><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</p> </li> <li> <p>convert strings with newlines to triple quoted strings   <pre><code>assert \"a\\nb\\n\" == snapshot(\n    \"\"\"a\nb\n\"\"\"\n)\n</code></pre></p> </li> <li>preserve black formatting</li> </ul>"},{"location":"changelog/#exec-1--v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":""},{"location":"changelog/#exec-1--fix_17","title":"Fix","text":"<ul> <li>updated executing</li> </ul>"},{"location":"changelog/#exec-1--v011-2022-12-08","title":"v0.1.1 (2022-12-08)","text":""},{"location":"changelog/#exec-1--fix_18","title":"Fix","text":"<ul> <li>fixed typo in pytest plugin name</li> </ul>"},{"location":"changelog/#exec-1--v010-2022-07-25","title":"v0.1.0 (2022-07-25)","text":""},{"location":"changelog/#exec-1--feat_11","title":"Feat","text":"<ul> <li>first inline-snapshot version</li> </ul>"},{"location":"cmp_snapshot/","title":"x <= snapshot()","text":""},{"location":"cmp_snapshot/#general","title":"General","text":"<p>A snapshot can be compared against any value with <code>&lt;=</code> or <code>&gt;=</code>. This can be used to create a upper/lower bound for some result. The snapshot value can be trimmed to the lowest/largest valid value.</p> <p>Example:</p> original code--inline-snapshot=createoptimized code --inline-snapshot=trim <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot()\n    assert iterations &lt;= snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(3)\n</code></pre></p> <p>Warning</p> <p>This should not be used to check for any flaky values like the runtime of some code, because it will randomly break your tests.</p> <p>The same snapshot value can also be used in multiple assertions.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    value = snapshot()\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    value = snapshot(6)\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p>"},{"location":"cmp_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the new value and store it in the source code if it is contradicts the comparison.</li> <li><code>trim</code> record the new value and store it in the source code if it is more strict than the old one.</li> </ul>"},{"location":"code_generation/","title":"Code generation","text":"<p>You can use almost any python data type and also complex values like <code>datetime.date</code>, because <code>repr()</code> is used to convert the values to source code. The default <code>__repr__()</code> behaviour can be customized. It might be necessary to import the right modules to match the <code>repr()</code> output.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot(\n        {\n            \"name\": \"hello\",\n            \"one number\": 5,\n            \"numbers\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            \"sets\": {1, 2, 15},\n            \"datetime\": datetime.date(1, 2, 22),\n            \"complex stuff\": (3 + 5j),\n            \"bytes\": b\"byte abc\\n\\x16\",\n        }\n    )\n</code></pre></p> <p>The code is generated in the following way:</p> <ol> <li>The value is copied with <code>value = copy.deepcopy(value)</code> and it is checked if the copied value is equal to the original value.</li> <li>The code is generated with:<ul> <li><code>repr(value)</code> (which can be customized)</li> <li>or a special internal implementation for container types to support unmanaged snapshot values.   This can currently not be customized.</li> </ul> </li> <li> <p>Strings which contain newlines are converted to triple quoted strings.</p> <p>Note</p> <p>Missing newlines at start or end are escaped (since 0.4.0).</p> original code--inline-snapshot=update <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"first line\nsecond line\"\"\"\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"\\\nfirst line\nsecond line\\\n\"\"\"\n    )\n</code></pre></p> </li> <li> <p>The new code fragments are formatted with black if it is installed.</p> <p>Note</p> <p>Black is an optional dependency since inline-snapshot v0.19.0. You can install it with: <pre><code>pip install inline-snapshot[black]\n</code></pre></p> </li> <li> <p>The whole file is formatted</p> <ul> <li> <p>with black if it was formatted with black before.</p> <p>Note</p> <p>The black formatting of the whole file could not work for the following reasons:</p> <ol> <li>black is configured with cli arguments and not in a configuration file. Solution: configure black in a configuration file</li> <li>inline-snapshot uses a different black version. Solution: specify which black version inline-snapshot should use by adding black with a specific version to your dependencies.</li> <li>black is not installed. Black is an optional dependency since inline-snapshot v0.19.0</li> </ol> </li> <li> <p>or with the format-command if you defined one.</p> </li> </ul> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Default configuration:</p> <pre><code>[tool.inline-snapshot]\nhash-length=15\ndefault-flags=[\"report\"]\ndefault-flags-tui=[\"create\", \"review\"]\ndefault-flags-ide=[\"create\", \"report\"]\nformat-command=\"\"\nshow-updates=false\ndefault-storage=\"uuid\"\n\n[tool.inline-snapshot.shortcuts]\nreview=[\"review\"]\nfix=[\"create\",\"fix\"]\n</code></pre> <p>Note</p> <p>The default flags are different if you use cpython&lt;3.11 due to technical limitations: <pre><code>[tool.inline-snapshot]\ndefault-flags=[\"short-report\"]\ndefault-flags-tui=[\"short-report\"]\ndefault-flags-ide=[\"short-report\"]\n</code></pre></p> <p>Changing these flags will disable pytest assert rewriting for older python versions.</p> <ul> <li>hash-length: specifies the length of the hash used by <code>external()</code> in the code representation.     This does not affect the hash length used to store the data.     The hash should be long enough to avoid hash collisions.</li> <li> <p>default-flags: defines which flags should be used if there are no flags specified with <code>--inline-snapshot=...</code> and default-flags-ide or default-flags-tui are note used.     You can also use the environment variable <code>INLINE_SNAPSHOT_DEFAULT_FLAGS=...</code> to specify the flags and to override those in the configuration file.</p> </li> <li> <p>default-flags-tui: defines which flags should be used if you run pytest in an interactive terminal.     inline-snapshot creates all snapshots by default in this case and asks when there are values to change.     This feature requires cpython&gt;=3.11</p> </li> <li> <p>default-flags-ide: (insider only) defines which flags should be used if you run your tests with the \"run test\" button in PyCharm.     inline-snapshot creates in this case all snapshots by default and reports other changes.     The review flag is not supported here because inline-snapshot is not able to read user input.</p> <p>Danger</p> <p>You can use <code>[\"create\",\"fix\"]</code> if this fits your work flow, but keep in mind that this will change your snapshot values every time you press the \"run test\" button and you will have to undo these changes if they are incorrect.</p> <p>What you can do instead is to replace the incorrect values with <code>...</code> and run your test again. The change from <code>...</code> to the new value is part of the create category, which is enabled by default.</p> </li> <li> <p>shortcuts: allows you to define custom commands to simplify your workflows.     <code>--fix</code> and <code>--review</code> are defined by default, but this configuration can be changed to fit your needs.</p> </li> <li> <p>storage-dir: allows you to define the directory where inline-snapshot stores data files such as external snapshots stored with the <code>hash:</code> protocol.     By default, it will be <code>&lt;pytest_config_dir&gt;/.inline-snapshot</code>,     where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any.     External snapshots will be stored in the <code>external</code> subfolder of the storage directory.</p> </li> <li> <p>format-command: allows you to specify a custom command which is used to format the python code after code is changed.</p> ruff formatruff format &amp; lintblackno command (default) <pre><code>[tool.inline-snapshot]\nformat-command=\"ruff format --stdin-filename {filename}\"\n</code></pre> <pre><code>[tool.inline-snapshot]\nformat-command=\"ruff check --fix-only --stdin-filename {filename} | ruff format --stdin-filename {filename}\"\n</code></pre> <pre><code>[tool.inline-snapshot]\nformat-command=\"black --stdin-filename {filename} -\"\n</code></pre> <p>inline-snapshot will format only the snapshot values with black when you specify no format command, but requires black to be installed with <code>inline-snapshot[black]</code>.</p> <p>The placeholder <code>{filename}</code> can be used to specify the filename if it is needed to find the correct formatting options for this file.</p> <p>Important</p> <p>The command should not format the file on disk. The current file content (with the new code changes) is passed to stdin and the formatted content should be written to stdout.</p> </li> <li> <p>show-updates: shows updates in reviews and reports.</p> </li> <li> <p>default-storage: defines the default storage protocol to be used when creating snapshots without an explicit storage protocol, such as <code>external()</code>.     Possible values are <code>hash</code> and <code>uuid</code>.     External snapshots created by <code>outsource()</code> do not currently support this setting due to some internal limitations and will always use the old <code>hash</code> protocol.</p> </li> <li> <p>test-dir: can be used to define where your tests are located.     The default is <code>&lt;pytest_config_dir&gt;/tests</code> if it exists,     where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any.     This directory is used to search through all test files for <code>external()</code> calls and to check whether the currently saved external objects are still used in the source.     It is therefore required if you want to trim unused externals.     You can also specify a list of folders.</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Please create an issue before writing a pull request so we can discuss what needs to be changed.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>The code can be tested with hatch</p> <ul> <li><code>hatch test</code> can be used to test all supported python versions and to check for coverage.</li> <li><code>hatch test -py 3.10 -- --sw</code> runs pytest for python 3.10 with the <code>--sw</code> argument.</li> </ul> <p>The preferred way to test inline-snapshot is by using <code>inline-snapshot.texting.Example</code>. You will see some other fixtures which are used inside the tests (<code>project</code>, <code>source</code>, <code>check_code</code>), but these are old ways to write the tests and I try to use the new <code>Example</code> class to write new tests.</p>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>This project has a hard coverage requirement of 100% (which is checked in CI). You can also check the coverage locally with <code>hatch test -acp</code>. The goal here is to find different edge cases which might have bugs.</p> <p>However, it is possible to exclude some code from the coverage.</p> <p>Code can be marked with <code>pragma: no cover</code>, if it can not be tested for some reason. This makes it easy to spot uncovered code in the source.</p> <p>Impossible conditions can be handled with <code>assert False</code>. <pre><code>if some_condition:\n    ...\nif some_other_condition:\n    ...\nelse:\n    assert False, \"unreachable because ...\"\n</code></pre> This serves also as an additional check during runtime.</p>"},{"location":"contributing/#commits","title":"Commits","text":"<p>Please use pre-commit for your commits.</p>"},{"location":"customize_repr/","title":"@customize_repr","text":"<p><code>repr()</code> can be used to convert a python object into a source code representation of the object, but this does not work for every type. Here are some examples:</p> <pre><code>&gt;&gt;&gt; repr(int)\n\"&lt;class 'int'&gt;\"\n\n&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; E = Enum(\"E\", [\"a\", \"b\"])\n&gt;&gt;&gt; repr(E.a)\n'&lt;E.a: 1&gt;'\n</code></pre> <p><code>customize_repr</code> can be used to overwrite the default <code>repr()</code> behaviour.</p> <p>The implementation for <code>Enum</code> looks like this:</p> <pre><code>@customize_repr\ndef _(value: Enum):\n    return f\"{type(value).__qualname__}.{value.name}\"\n</code></pre> <p>This implementation is then used by inline-snapshot if <code>repr()</code> is called during the code generation, but not in normal code.</p> <pre><code>from inline_snapshot import snapshot\nfrom enum import Enum\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # normal repr\n    assert repr(E.a) == \"&lt;E.a: 1&gt;\"\n\n    # the special implementation to convert the Enum into a code\n    assert E.a == snapshot(E.a)\n</code></pre>"},{"location":"customize_repr/#built-in-data-types","title":"built-in data types","text":"<p>inline-snapshot comes with a special implementation for the following types:</p> <ul> <li><code>builtins.builtin_function_or_method</code></li> <li><code>builtins.frozenset</code></li> <li><code>builtins.function</code></li> <li><code>builtins.set</code></li> <li><code>builtins.type</code></li> <li><code>enum.Enum</code></li> <li><code>enum.Flag</code></li> </ul> <p>Please open an issue if you found a built-in type which is not supported by inline-snapshot.</p> <p>Note</p> <p>Container types like <code>dict</code>, <code>list</code>, <code>tuple</code> or <code>dataclass</code> are handled in a different way, because inline-snapshot also needs to inspect these types to implement unmanaged snapshot values.</p>"},{"location":"customize_repr/#customize-recursive-repr","title":"customize recursive repr","text":"<p>You can also use <code>repr()</code> inside <code>__repr__()</code>, if you want to make your own type compatible with inline-snapshot.</p> <pre><code>from inline_snapshot import snapshot\nfrom enum import Enum\n\n\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def __repr__(self):\n        # this would not work\n        # return f\"Pair({self.a!r}, {self.b!r})\"\n\n        # you have to use repr()\n        return f\"Pair({repr(self.a)}, {repr(self.b)})\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Pair):\n            return NotImplemented\n        return self.a == other.a and self.b == other.b\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # the special repr implementation is used recursive here\n    # to convert every Enum to the correct representation\n    assert Pair(E.a, [E.b]) == snapshot(Pair(E.a, [E.b]))\n</code></pre> <p>Note</p> <p>using <code>f\"{obj!r}\"</code> or <code>PyObject_Repr()</code> will not work, because inline-snapshot replaces <code>builtins.repr</code> during the code generation. The only way to use the custom repr implementation is to use the <code>repr()</code> function.</p> <p>Note</p> <p>This implementation allows inline-snapshot to use the custom <code>repr()</code> recursively, but it does not allow you to use unmanaged snapshot values like <code>Pair(Is(some_var),5)</code></p> <p>you can also customize the representation of data types in other libraries:</p> <pre><code>from inline_snapshot import customize_repr\nfrom other_lib import SomeType\n\n\n@customize_repr\ndef _(value: SomeType):\n    return f\"SomeType(x={repr(value.x)})\"\n</code></pre>"},{"location":"eq_snapshot/","title":"x == snapshot()","text":""},{"location":"eq_snapshot/#general","title":"General","text":"<p>A snapshot can be compared with any value using <code>==</code>. The value can be recorded with <code>--inline-snapshot=create</code> if the snapshot is empty. The value can later be changed with <code>--inline-snapshot=fix</code> if the value the snapshot is compared with has changed.</p> <p>Example:</p> original code--inline-snapshot=createvalue changed--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 4 == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 4 == snapshot(6)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 40 == snapshot(4)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 40 == snapshot(42)\n</code></pre></p>"},{"location":"eq_snapshot/#unmanaged-snapshot-values","title":"unmanaged snapshot values","text":"<p>inline-snapshots manages everything inside <code>snapshot(...)</code>, which means that the developer should not change these parts, but there are cases where it is useful to give the developer the control over the snapshot content back.</p> <p>Therefor some types will be ignored by inline-snapshot and will not be updated or fixed, even if they cause tests to fail.</p> <p>These types are:</p> <ul> <li>dirty-equals expressions,</li> <li>dynamic code inside <code>Is(...)</code>,</li> <li>snapshots inside snapshots and</li> <li>f-strings.</li> </ul> <p>You can also create your own unmanaged types with <code>@declare_unmanaged</code></p> <pre><code>from inline_snapshot import declare_unmanaged, snapshot\n\n\n@declare_unmanaged\nclass AllEqual:\n    def __init__(self, value):\n        self.value = value\n\n    def __eq__(self, other):\n        return all(o == self.value for o in other)\n\n\ndef test_all_equal():\n    assert {\"text\": \"hello\", \"values\": [1, 1, 1]} == snapshot(\n        {\"text\": \"hello\", \"values\": AllEqual(snapshot(1))}\n    )\n</code></pre> <p>You have to put <code>AllEqual</code> manually into the snapshot and inline-snapshot will not touch it in the future when it has to fix the code, but it will change the value in the snapshot argument of <code>AllEqual</code>, because this is another snapshot. This allows you to specify what should be under your control and which code should be controlled and changed by inline-snapshot.</p> <p>inline-snapshot is able to handle these types within the following containers:</p> <ul> <li>list</li> <li>tuple</li> <li>dict</li> <li>namedtuple</li> <li>dataclass</li> <li>attrs</li> </ul> <p>Other types are converted with a customizable <code>repr()</code> into code. It is not possible to use unmanaged snapshot values within these objects.</p>"},{"location":"eq_snapshot/#dirty-equals","title":"dirty-equals","text":"<p>dirty-equals is a library of special objects for comparing types declaratively in unit tests. inline-snapshot supports dirty-equals expressions inside snapshots, making it easier to write snapshots that contain data that varies between test runs, such as timestamps, database IDs, or other runtime values.</p> <p>To use dirty-equals with inline-snapshot, pull in a compatible version with the <code>dirty-equals</code> extra dependency. For example, with Pip:</p> <pre><code>pip install inline-snapshot[dirty-equals]\n</code></pre> <p>Then you can start using dirty-equals expressions inside snapshots.</p> <p>For example, say you have a function that returns a dictionary that contains a variable <code>datetime</code>. You could initialize a test like this:</p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot()\n</code></pre> <p>If you use <code>--inline-snapshot=create</code>, inline-snapshot will record the current <code>datetime</code> in the snapshot:</p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\"date\": datetime.datetime(2024, 3, 14, 0, 0), \"payload\": \"some data\"}\n    )\n</code></pre> <p>To avoid the test failing in future runs, replace the <code>datetime</code> with dirty-equals' <code>IsDatetime()</code>:</p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre> <p>Say a different part of the return data changes, such as the <code>payload</code> value:</p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre> <p>Re-running the test with <code>--inline-snapshot=fix</code> will update the snapshot to match the new value of <code>payload</code>, while keeping the <code>date</code> as a dirty-equals expression:</p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"data changed for some good reason\",\n        }\n    )\n</code></pre>"},{"location":"eq_snapshot/#snapshot-inside-dirty-equals-expressions","title":"<code>snapshot()</code> inside dirty-equals expressions","text":"<p><code>snapshot()</code> can also be used inside dirty-equals containers, such as with <code>IsJson()</code>:</p> <pre><code>from dirty_equals import IsJson\nfrom inline_snapshot import snapshot\n\n\ndef test_foo():\n    assert {\"json_data\": '{\"value\": 1}'} == snapshot(\n        {\"json_data\": IsJson(snapshot())}\n    )\n</code></pre> <p>Running this test with <code>--inline-snapshot=create</code> will record the snapshot value inside the <code>IsJson()</code> call:</p> <pre><code>from dirty_equals import IsJson\nfrom inline_snapshot import snapshot\n\n\ndef test_foo():\n    assert {\"json_data\": '{\"value\": 1}'} == snapshot(\n        {\"json_data\": IsJson(snapshot({\"value\": 1}))}\n    )\n</code></pre> <p>The general rule is that functions to which you pass a snapshot can only use <code>==</code> (or other snapshot operations) on the value.</p> <p>Important</p> <p>You cannot use a snapshot for every dirty-equals argument, but only for those that also support dirty equals values.</p>"},{"location":"eq_snapshot/#is","title":"Is(...)","text":"<p><code>Is()</code> can be used to put runtime values inside snapshots. It tells inline-snapshot that the developer wants control over some part of the snapshot.</p> <pre><code>from inline_snapshot import snapshot, Is\n\ncurrent_version = \"1.5\"\n\n\ndef request():\n    return {\"data\": \"page data\", \"version\": current_version}\n\n\ndef test_function():\n    assert request() == snapshot(\n        {\"data\": \"page data\", \"version\": Is(current_version)}\n    )\n</code></pre> <p>The snapshot does not need to be fixed when <code>current_version</code> changes in the future, but <code>\"page data\"</code> will still be fixed if it changes.</p> <p><code>Is()</code> can also be used when the snapshot is evaluated multiple times, which is useful in loops or parametrized tests.</p> original code--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot, Is\n\n\ndef test_function():\n    for c in \"abc\":\n        assert [c, \"correct\"] == snapshot([Is(c), \"wrong\"])\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, Is\n\n\ndef test_function():\n    for c in \"abc\":\n        assert [c, \"correct\"] == snapshot([Is(c), \"correct\"])\n</code></pre></p>"},{"location":"eq_snapshot/#inner-snapshots","title":"inner snapshots","text":"<p>Snapshots can be used inside other snapshots in different use cases.</p>"},{"location":"eq_snapshot/#conditional-snapshots","title":"conditional snapshots","text":"<p>It is also possible to use snapshots inside snapshots.</p> <p>This is useful to describe version specific parts of snapshots by replacing the specific part with <code>snapshot() if some_condition else snapshot()</code>. The test has to be executed in each specific condition to fill the snapshots.</p> <p>The following example shows how this can be used to run a tests with two different library versions:</p> my_lib.py v1my_lib.py v2 <p> <pre><code>version = 1\n\n\ndef get_schema():\n    return [{\"name\": \"var_1\", \"type\": \"int\"}]\n</code></pre></p> <p> <pre><code>version = 2\n\n\ndef get_schema():\n    return [{\"name\": \"var_1\", \"type\": \"string\"}]\n</code></pre></p> <pre><code>from inline_snapshot import snapshot\nfrom my_lib import version, get_schema\n\n\ndef test_function():\n    assert get_schema() == snapshot(\n        [\n            {\n                \"name\": \"var_1\",\n                \"type\": snapshot(\"int\") if version &lt; 2 else snapshot(\"string\"),\n            }\n        ]\n    )\n</code></pre> <p>The advantage of this approach is that the test uses always the correct values for each library version.</p> <p>You can also extract the version logic into its own function.</p> <pre><code>from inline_snapshot import snapshot, Snapshot\nfrom my_lib import version, get_schema\n\n\ndef version_snapshot(v1: Snapshot, v2: Snapshot):\n    return v1 if version &lt; 2 else v2\n\n\ndef test_function():\n    assert get_schema() == snapshot(\n        [\n            {\n                \"name\": \"var_1\",\n                \"type\": version_snapshot(\n                    v1=snapshot(\"int\"), v2=snapshot(\"string\")\n                ),\n            }\n        ]\n    )\n</code></pre>"},{"location":"eq_snapshot/#common-snapshot-parts","title":"common snapshot parts","text":"<p>Another use case is the extraction of common snapshot parts into an extra snapshot:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef some_data(name):\n    return {\"header\": \"really long header\\n\" * 5, \"your name\": name}\n\n\ndef test_function():\n\n    header = snapshot(\n        \"\"\"\\\nreally long header\nreally long header\nreally long header\nreally long header\nreally long header\n\"\"\"\n    )\n\n    assert some_data(\"Tom\") == snapshot(\n        {\n            \"header\": header,\n            \"your name\": \"Tom\",\n        }\n    )\n\n    assert some_data(\"Bob\") == snapshot(\n        {\n            \"header\": header,\n            \"your name\": \"Bob\",\n        }\n    )\n</code></pre> <p>This simplifies test data and allows inline-snapshot to update your values if required. It makes also sure that the header is the same in both cases.</p>"},{"location":"eq_snapshot/#f-strings","title":"f-strings","text":"<p>f-strings are not generated by inline-snapshot, but they can be used in snapshots if you want to replace some dynamic part of a string value.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef get_error():\n    # example code which generates an error message\n    return __file__ + \": error at line 5\"\n\n\ndef test_get_error():\n    assert get_error() == snapshot(f\"{__file__}: error at line 5\")\n</code></pre> <p>It is not required to wrap the changed value in <code>Is(f\"...\")</code>, because inline-snapshot knows that f-strings are only generated by the developer.</p> <p>Limitation</p> <p>inline-snapshot is currently not able to fix the string constants within f-strings.</p> <p><code>f\"...{var}...\"</code> works currently like <code>Is(f\"...{var}...\")</code> and issues a warning if the value changes, giving you the opportunity to fix your f-string.</p> <p><code>f\"...{var}...\"</code> will in the future work like <code>f\"...{Is(var)}\"</code>. inline-snapshot will then be able to fix the string parts within the f-string.</p>"},{"location":"eq_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the value parts and store them in the source code if it is different from the current one.</li> <li><code>update</code> update parts of the value if their representation has changed.   Parts which are replaced with dirty-equals expressions are not updated.</li> </ul>"},{"location":"extra/","title":"first-party (extra)","text":""},{"location":"extra/#inline_snapshot.extra","title":"<code>inline_snapshot.extra</code>","text":"<p>The following functions are built on top of inline-snapshot and could also be implemented in an extra library. The source is added to the documentation, which allows you to look at how they are implemented and implement similar functions if you need them.</p> <p>They are part of inline-snapshot because they are generally useful and do not depend on other libraries.</p>"},{"location":"extra/#inline_snapshot.extra.Transformed","title":"<code>Transformed</code>","text":"<p><code>Transformed</code> allows you to move transformations of your values from one side of the <code>==</code> to the other.</p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import Transformed\n\n\ndef test_transform():\n    numbers = [1, 8, 3, 7, 5]\n    assert sorted(numbers) == snapshot()\n    assert numbers == Transformed(sorted, snapshot())\n</code></pre> <p>Both assertions create the same snapshots.</p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import Transformed\n\n\ndef test_transform():\n    numbers = [1, 8, 3, 7, 5]\n    assert sorted(numbers) == snapshot([1, 3, 5, 7, 8])\n    assert numbers == Transformed(sorted, snapshot([1, 3, 5, 7, 8]))\n</code></pre> <p><code>Transformed</code> is more flexible to use because you can also use it deep inside data structures. The following example shows how <code>Transformed</code> is used inside a dictionary.</p> <pre><code>from random import shuffle\nfrom inline_snapshot import snapshot\nfrom inline_snapshot.extra import Transformed\n\n\ndef request():\n    data = [1, 8, 18748, 493]\n    shuffle(data)\n    return {\"name\": \"example\", \"data\": data}\n\n\ndef test_request():\n    assert request() == snapshot(\n        {\n            \"name\": \"example\",\n            \"data\": Transformed(sorted, snapshot([1, 8, 493, 18748])),\n        }\n    )\n</code></pre> <p>Or to normalize strings.</p> <pre><code>from inline_snapshot.extra import Transformed\nfrom inline_snapshot import snapshot\nimport re\n\n\nclass Thing:\n    def __repr__(self):\n        return \"&lt;Thing with some random id 152897513&gt;\"\n\n\ndef without_ids(text):\n    return re.sub(r\"&lt;([^0-9]*)[^&gt;]+&gt;\", lambda m: f\"&lt;{m[1]} ...&gt;\", text)\n\n\ndef test_text_with_objects():\n    text = f\"text can contain {Thing()}\"\n\n    assert {\"logs\": text} == snapshot(\n        {\n            \"logs\": Transformed(\n                without_ids,\n                snapshot(\"text can contain &lt;Thing with some random id  ...&gt;\"),\n            )\n        }\n    )\n</code></pre> <p>Tip</p> <p>You can use @transformation if you want to use the same transformation multiple times.</p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@declare_unmanaged\nclass Transformed:\n    \"\"\"\n    `Transformed` allows you to move transformations of your values from one side of the `==` to the other.\n\n    &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n    ``` python\n    from inline_snapshot import snapshot\n    from inline_snapshot.extra import Transformed\n\n\n    def test_transform():\n        numbers = [1, 8, 3, 7, 5]\n        assert sorted(numbers) == snapshot()\n        assert numbers == Transformed(sorted, snapshot())\n    ```\n\n    Both assertions create the same snapshots.\n\n    &lt;!-- inline-snapshot: create outcome-passed=1 outcome-errors=1 --&gt;\n    ``` python hl_lines=\"7 8\"\n    from inline_snapshot import snapshot\n    from inline_snapshot.extra import Transformed\n\n\n    def test_transform():\n        numbers = [1, 8, 3, 7, 5]\n        assert sorted(numbers) == snapshot([1, 3, 5, 7, 8])\n        assert numbers == Transformed(sorted, snapshot([1, 3, 5, 7, 8]))\n    ```\n\n    `Transformed` is more flexible to use because you can also use it deep inside data structures.\n    The following example shows how `Transformed` is used inside a dictionary.\n\n    &lt;!-- inline-snapshot: create fix first_block outcome-passed=1 --&gt;\n    ``` python\n    from random import shuffle\n    from inline_snapshot import snapshot\n    from inline_snapshot.extra import Transformed\n\n\n    def request():\n        data = [1, 8, 18748, 493]\n        shuffle(data)\n        return {\"name\": \"example\", \"data\": data}\n\n\n    def test_request():\n        assert request() == snapshot(\n            {\n                \"name\": \"example\",\n                \"data\": Transformed(sorted, snapshot([1, 8, 493, 18748])),\n            }\n        )\n    ```\n\n    Or to normalize strings.\n\n    &lt;!-- inline-snapshot: create fix first_block outcome-passed=1 --&gt;\n    ``` python\n    from inline_snapshot.extra import Transformed\n    from inline_snapshot import snapshot\n    import re\n\n\n    class Thing:\n        def __repr__(self):\n            return \"&lt;Thing with some random id 152897513&gt;\"\n\n\n    def without_ids(text):\n        return re.sub(r\"&lt;([^0-9]*)[^&gt;]+&gt;\", lambda m: f\"&lt;{m[1]} ...&gt;\", text)\n\n\n    def test_text_with_objects():\n        text = f\"text can contain {Thing()}\"\n\n        assert {\"logs\": text} == snapshot(\n            {\n                \"logs\": Transformed(\n                    without_ids,\n                    snapshot(\"text can contain &lt;Thing with some random id  ...&gt;\"),\n                )\n            }\n        )\n    ```\n\n\n    !!! Tip\n        You can use [@transformation][inline_snapshot.extra.transformation] if you want to use the same transformation multiple times.\n\n    \"\"\"\n\n    def __init__(\n        self, func: Callable[[Any], Any], value: Snapshot, should_be: Any = None\n    ) -&gt; None:\n        \"\"\"\n        Arguments:\n            func: functions which is used to transform the value which is compared.\n            value: the result of the transformation\n            should_be: this argument is unused and only reported in the `repr()` to show you the last transformed value.\n        \"\"\"\n        self._func = func\n        self._value = value\n        self._last_transformed_value = None\n\n    def __eq__(self, other) -&gt; bool:\n        self._last_transformed_value = self._func(other)\n        return self._last_transformed_value == self._value\n\n    def __repr__(self):\n        if self._last_transformed_value == self._value:\n            return f\"Transformed({code_repr(self._func)}, {self._value})\"\n        else:\n            return f\"Transformed({code_repr(self._func)}, {self._value}, should_be={self._last_transformed_value!r})\"\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.Transformed.__init__","title":"<code>__init__(func, value, should_be=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Any], Any]</code> <p>functions which is used to transform the value which is compared.</p> required <code>value</code> <code>Snapshot</code> <p>the result of the transformation</p> required <code>should_be</code> <code>Any</code> <p>this argument is unused and only reported in the <code>repr()</code> to show you the last transformed value.</p> <code>None</code> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>def __init__(\n    self, func: Callable[[Any], Any], value: Snapshot, should_be: Any = None\n) -&gt; None:\n    \"\"\"\n    Arguments:\n        func: functions which is used to transform the value which is compared.\n        value: the result of the transformation\n        should_be: this argument is unused and only reported in the `repr()` to show you the last transformed value.\n    \"\"\"\n    self._func = func\n    self._value = value\n    self._last_transformed_value = None\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.prints","title":"<code>prints(*, stdout='', stderr='')</code>","text":"<p>Uses <code>contextlib.redirect_stderr/stdout</code> to capture the output and compare it with the snapshots. <code>dirty_equals.IsStr</code> can be used to ignore the output if needed.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>Snapshot[str]</code> <p>Snapshot that is compared to the recorded output.</p> <code>''</code> <code>stderr</code> <code>Snapshot[str]</code> <p>Snapshot that is compared to the recorded error output.</p> <code>''</code> original--inline-snapshot=createignore stdout <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nimport sys\n\n\ndef test_prints():\n    with prints(stdout=snapshot(), stderr=snapshot()):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nimport sys\n\n\ndef test_prints():\n    with prints(\n        stdout=snapshot(\"hello world\\n\"), stderr=snapshot(\"some error\\n\")\n    ):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nfrom dirty_equals import IsStr\nimport sys\n\n\ndef test_prints():\n    with prints(\n        stdout=IsStr(),\n        stderr=snapshot(\"some error\\n\"),\n    ):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef prints(*, stdout: Snapshot[str] = \"\", stderr: Snapshot[str] = \"\"):\n    \"\"\"Uses `contextlib.redirect_stderr/stdout` to capture the output and\n    compare it with the snapshots. `dirty_equals.IsStr` can be used to ignore\n    the output if needed.\n\n    Parameters:\n        stdout: Snapshot that is compared to the recorded output.\n        stderr: Snapshot that is compared to the recorded error output.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        import sys\n\n\n        def test_prints():\n            with prints(stdout=snapshot(), stderr=snapshot()):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python hl_lines=\"7 8 9\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        import sys\n\n\n        def test_prints():\n            with prints(\n                stdout=snapshot(\"hello world\\\\n\"), stderr=snapshot(\"some error\\\\n\")\n            ):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n\n    === \"ignore stdout\"\n\n        &lt;!-- inline-snapshot: outcome-passed=1 --&gt;\n        ``` python hl_lines=\"3 9 10\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        from dirty_equals import IsStr\n        import sys\n\n\n        def test_prints():\n            with prints(\n                stdout=IsStr(),\n                stderr=snapshot(\"some error\\\\n\"),\n            ):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n    \"\"\"\n\n    with redirect_stdout(io.StringIO()) as stdout_io:\n        with redirect_stderr(io.StringIO()) as stderr_io:\n            yield\n\n    assert stderr_io.getvalue() == stderr\n    assert stdout_io.getvalue() == stdout\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.raises","title":"<code>raises(exception)</code>","text":"<p>Check that an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Snapshot[str]</code> <p>Snapshot that is compared with <code>f\"{type}: {message}\"</code> if an exception occurs, or <code>\"&lt;no exception&gt;\"</code> if no exception is raised.</p> required original--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import raises\n\n\ndef test_raises():\n    with raises(snapshot()):\n        1 / 0\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import raises\n\n\ndef test_raises():\n    with raises(snapshot(\"ZeroDivisionError: division by zero\")):\n        1 / 0\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef raises(exception: Snapshot[str]):\n    \"\"\"Check that an exception is raised.\n\n    Parameters:\n        exception: Snapshot that is compared with `#!python f\"{type}: {message}\"` if an exception occurs, or `#!python \"&lt;no exception&gt;\"` if no exception is raised.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import raises\n\n\n        def test_raises():\n            with raises(snapshot()):\n                1 / 0\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python hl_lines=\"6\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import raises\n\n\n        def test_raises():\n            with raises(snapshot(\"ZeroDivisionError: division by zero\")):\n                1 / 0\n        ```\n    \"\"\"\n\n    try:\n        yield\n    except Exception as ex:\n        msg = str(ex)\n        if \"\\n\" in msg:\n            assert f\"{type(ex).__name__}:\\n{ex}\" == exception\n        else:\n            assert f\"{type(ex).__name__}: {ex}\" == exception\n    else:\n        assert \"&lt;no exception&gt;\" == exception\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.transformation","title":"<code>transformation(func)</code>","text":"<p><code>@transformation</code> can be used to bind a function to Transformed, which simplifies your code if you want to use the same transformation multiple times.</p> <pre><code>from inline_snapshot.extra import transformation\nfrom inline_snapshot import snapshot\nimport re\n\n\nclass Thing:\n    def __repr__(self):\n        return \"&lt;Thing with some random id 152897513&gt;\"\n\n\n@transformation\ndef WithoutIds(text):\n    return re.sub(r\"&lt;([^0-9]*)[^&gt;]+&gt;\", lambda m: f\"&lt;{m[1]} ...&gt;\", text)\n\n\ndef test_text_with_objects():\n    text = f\"text can contain {Thing()}\"\n\n    assert {\"logs\": [text]} == snapshot(\n        {\n            \"logs\": [\n                WithoutIds(\n                    snapshot(\n                        \"text can contain &lt;Thing with some random id  ...&gt;\"\n                    )\n                )\n            ]\n        }\n    )\n</code></pre> <p>Tip</p> <p>The argument of <code>WithoutIds</code> can also be an external <code>WithoutIds(external())</code> if you want to store a large log in an external file.</p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>def transformation(func):\n    \"\"\"\n\n    `@transformation` can be used to bind a function to [Transformed][inline_snapshot.extra.Transformed],\n    which simplifies your code if you want to use the same transformation multiple times.\n\n    &lt;!-- inline-snapshot: create first_block outcome-passed=1 --&gt;\n    ``` python\n    from inline_snapshot.extra import transformation\n    from inline_snapshot import snapshot\n    import re\n\n\n    class Thing:\n        def __repr__(self):\n            return \"&lt;Thing with some random id 152897513&gt;\"\n\n\n    @transformation\n    def WithoutIds(text):\n        return re.sub(r\"&lt;([^0-9]*)[^&gt;]+&gt;\", lambda m: f\"&lt;{m[1]} ...&gt;\", text)\n\n\n    def test_text_with_objects():\n        text = f\"text can contain {Thing()}\"\n\n        assert {\"logs\": [text]} == snapshot(\n            {\n                \"logs\": [\n                    WithoutIds(\n                        snapshot(\n                            \"text can contain &lt;Thing with some random id  ...&gt;\"\n                        )\n                    )\n                ]\n            }\n        )\n    ```\n\n    !!! Tip\n        The argument of `WithoutIds` can also be an external `WithoutIds(external())` if you want to store a large log in an external file.\n    \"\"\"\n\n    def f(value):\n        return Transformed(func, value)\n\n    return f\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.warns","title":"<code>warns(expected_warnings, /, include_line=False, include_file=False)</code>","text":"<p>Captures warnings with <code>warnings.catch_warnings</code> and compares them against expected warnings.</p> <p>Parameters:</p> Name Type Description Default <code>expected_warnings</code> <code>Snapshot[List[Warning]]</code> <p>Snapshot containing a list of expected warnings.</p> required <code>include_line</code> <code>bool</code> <p>If <code>True</code>, each expected warning is a tuple <code>(line_number, message)</code>.</p> <code>False</code> <code>include_file</code> <code>bool</code> <p>If <code>True</code>, each expected warning is a tuple <code>(filename, message)</code>.</p> <code>False</code> <p>The format of the expected warning:</p> <ul> <li><code>(filename, line_number, message)</code> if both <code>include_line</code> and <code>include_file</code> are <code>True</code>.</li> <li><code>(line_number, message)</code> if only <code>include_line</code> is <code>True</code>.</li> <li><code>(filename, message)</code> if only <code>include_file</code> is <code>True</code>.</li> <li>A string <code>message</code> if both are <code>False</code>.</li> </ul> original--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import warns\nfrom warnings import warn\n\n\ndef test_warns():\n    with warns(snapshot(), include_line=True):\n        warn(\"some problem\")\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import warns\nfrom warnings import warn\n\n\ndef test_warns():\n    with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n        warn(\"some problem\")\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef warns(\n    expected_warnings: Snapshot[List[Warning]],\n    /,\n    include_line: bool = False,\n    include_file: bool = False,\n):\n    \"\"\"\n    Captures warnings with `warnings.catch_warnings` and compares them against expected warnings.\n\n    Parameters:\n        expected_warnings: Snapshot containing a list of expected warnings.\n        include_line: If `True`, each expected warning is a tuple `(line_number, message)`.\n        include_file: If `True`, each expected warning is a tuple `(filename, message)`.\n\n    The format of the expected warning:\n\n    - `(filename, line_number, message)` if both `include_line` and `include_file` are `True`.\n    - `(line_number, message)` if only `include_line` is `True`.\n    - `(filename, message)` if only `include_file` is `True`.\n    - A string `message` if both are `False`.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import warns\n        from warnings import warn\n\n\n        def test_warns():\n            with warns(snapshot(), include_line=True):\n                warn(\"some problem\")\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create fix outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python hl_lines=\"7\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import warns\n        from warnings import warn\n\n\n        def test_warns():\n            with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n                warn(\"some problem\")\n        ```\n    \"\"\"\n    with warnings.catch_warnings(record=True) as result:\n        warnings.simplefilter(\"always\")\n        yield\n\n    def make_warning(w):\n        message = f\"{w.category.__name__}: {w.message}\"\n        if not include_line and not include_file:\n            return message\n        message = (message,)\n\n        if include_line:\n            message = (w.lineno, *message)\n        if include_file:\n            message = (w.filename, *message)\n\n        return message\n\n    assert [make_warning(w) for w in result] == expected_warnings\n</code></pre>"},{"location":"fix_assert/","title":"assert x == ...","text":""},{"location":"fix_assert/#general","title":"General","text":"<p>Info</p> <p>The following feature is available for insider  only and requires cpython&gt;=3.11 to generate code. The generated code can be used with every python version.</p> <p>The <code>snapshot()</code> function provides a lot of flexibility, but there is a easier way for simple assertion. You can write a normal assertion and use <code>...</code> where inline-snapshot should create the new value, like in the following example.</p> <pre><code>def test_assert():\n    assert 1 + 1 == ...\n</code></pre> <p>You can then run <code>pytest</code> to create the value or use the \"run test\" button in PyCharm, which replaces <code>...</code> by default with the correct value.</p> <pre><code>def test_assert():\n    assert 1 + 1 == 2\n</code></pre> <p>It is also possible to fix existing values.</p> <pre><code>def test_assert():\n    assert 1 + 1 == 5\n</code></pre> <p>Fixing existing assertions can only be done by running <code>pytest</code> and not the \"run test\" button.</p> <pre><code>def test_assert():\n    assert 1 + 1 == 2\n</code></pre> <p>This is especially useful to fix values in existing codebases where <code>snapshot()</code> is currently not used.</p> <p>The logic to create/fix the assertions is the same like for snapshots, but there are rules which specify which side of the <code>==</code> should be fixed. This allows assertions like <code>assert 5 == 1 + 2</code> to be fixed and prevents inline-snapshot to try to fix code like <code>assert f1() == f2()</code>.</p> <p>The rule is that exactly one side of the equation must be a value expression, which is defined as follows:</p> <ul> <li>a constant</li> <li>a list/tuple/dict/set of value expressions</li> <li>a constructor call such as <code>T(...arguments)</code><ul> <li>where the arguments are value expressions</li> <li>and <code>T</code> is a type (which excludes function calls)</li> </ul> </li> </ul>"},{"location":"fix_assert/#limitations","title":"Limitations","text":"<ul> <li><code>cpython&gt;=3.11</code> is required to create/fix assertions.</li> <li>It can only fix the first failing assertion in a test.   You need to run your tests a multiple times to fix the remaining ones.</li> <li>It is not possible to fix values where inline-snapshot did not know which side of the equal sign should be fixed.   You can use <code>snapshot()</code> in this case to make this clear.</li> </ul>"},{"location":"fix_assert/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value where <code>...</code> is used.</li> <li> <p><code>fix-assert</code> fix the value if the assertion fails.</p> <p>Note</p> <p>fix-assert is used to distinguisch between snapshot fixes and assertion fixes without snapshot(). This should help in deciding whether some fixes should be approved. Fixing normal assertions is inherently more complicated because these assertions are written by a human without the intention of being automatically fixed. Separating the two helps in approving the changes.</p> </li> </ul>"},{"location":"get_snapshot_value/","title":"get_snapshot_value()","text":""},{"location":"get_snapshot_value/#inline_snapshot.get_snapshot_value","title":"<code>get_snapshot_value(snapshot_value)</code>","text":"<p>Extracts and returns the raw value stored inside a snapshot, removing all inline-snapshot-specific wrappers such as those generated by <code>external()</code>, <code>Is()</code>, or <code>snapshot()</code>.</p> <p>This function is primarily intended for extension authors who need direct access to the value of a previously stored snapshot. For standard test assertions, prefer using the snapshot directly.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot_value</code> <code>Snapshot[T]</code> <p>The snapshot object from which to extract the value.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The unwrapped value contained in the snapshot.</p> Example <pre><code>from inline_snapshot import external, snapshot, get_snapshot_value\n\ns = snapshot([0, external(\"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.json\")])\n\nif record:\n    # Store value\n    assert s == [0, 5]\nelse:\n    # Use value from snapshot\n    value = get_snapshot_value(s)\n    # ... do something with value\n</code></pre>"},{"location":"getitem_snapshot/","title":"snapshot()[key]","text":""},{"location":"getitem_snapshot/#general","title":"General","text":"<p>It is possible to generate sub-snapshots during runtime. This sub-snapshots can be used like a normal snapshot.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot()\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot({\"a\": 4, \"b\": 5})\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p><code>s[key]</code> can be used with every normal snapshot operation including <code>s[key1][key2]</code>.</p>"},{"location":"getitem_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined or create a new sub-snapshot if one is missing.</li> <li><code>trim</code> remove sub-snapshots if they are not needed any more.</li> </ul> <p>The flags <code>fix</code> and <code>update</code> are applied recursive to all sub-snapshots.</p>"},{"location":"in_snapshot/","title":"x in snapshot()","text":""},{"location":"in_snapshot/#general","title":"General","text":"<p>It is possible to check if an value is in a snapshot. The value of the generated snapshot will be a list of all values which are tested.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot()\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot([5, 8, \"a\", \"b\"])\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p>"},{"location":"in_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> adds a value to the list if it is missing.</li> <li><code>trim</code> removes a value from the list if it is not necessary.</li> </ul>"},{"location":"insiders/","title":"Insiders","text":"<p>Hi, I'm Frank Hoffmann. I created and maintain inline-snapshot and several other tools. Working on open-source projects is incredibly rewarding, but it also requires a significant investment of time and energy. Balancing work, family, and open-source is challenging, and your support can make a real difference.</p>"},{"location":"insiders/#why-sponsor","title":"Why sponsor?","text":"<p>By sponsoring me, you become an essential part of the future of inline-snapshot and related tools. Your support empowers me to spend more time building new features, improving usability, fixing bugs, and providing better documentation and support for everyone.</p> <p>Open-source software powers the world, but most projects rely on volunteer work. Sponsoring helps create a more sustainable ecosystem, where maintainers can focus on quality and innovation instead of struggling to find time.</p>"},{"location":"insiders/#what-do-you-get-when-you-sponsor-me","title":"What do you get when you sponsor me?","text":"<p>I want to create insider features that improve the usability of inline-snapshot. These are first released for insiders only, which means you can access them when you sponsor me on GitHub. They will later be released for everyone once a specific sponsoring goal is reached.</p> <p>You will be able to run tests created with the insider version of inline-snapshot using the normal version. This is very important to me because it allows you to collaborate with others (in open-source or in your company) who do not use the insider version. You can also use the normal inline-snapshot version to run your tests in CI.</p> <p>The following features are currently available for sponsors:</p>"},{"location":"insiders/#the-ability-to-create-and-fix-assertions-without-snapshot","title":"The ability to create and fix assertions without snapshot()","text":"<p>You can create and fix normal assertions, which can be very useful when you work in a large codebase and want to use the inline-snapshot magic with your existing assertions, or when you want to create assertions but don't want to add inline-snapshot as a test dependency to your project.</p>"},{"location":"insiders/#ide-integration-into-pycharm","title":"IDE integration into PyCharm","text":"<p>You are able to create snapshots by clicking the green \"run test\" button. This is the first step toward extended IDE integration, and the ability to approve snapshot changes will follow in the future.</p>"},{"location":"insiders/#for-companies","title":"For Companies","text":"<p>You can sponsor me as a company and email me a list of GitHub accounts that you want to be able to access the insider features. It is still $10 per account, but you have only one sponsorship to manage. I will also add your logo to my project readme when you sponsor me for more than $100 (see funding tiers).</p>"},{"location":"insiders/#funding-goals","title":"Funding goals","text":"<p>One of my goals is to motivate people to start sponsoring open-source projects, not just mine. Therefore, my plan is to reduce the minimum sponsoring amount, starting from $10 a month.</p> <ul> <li>10 Sponsors: inline-snapshot-pandas and canonical-imports will be released.</li> <li>20 Sponsors: reduce the sponsorship amount to $9</li> <li>40 Sponsors: reduce the sponsorship amount to $8</li> <li>... more goals will follow</li> </ul> <p>I follow several goals with this plan:</p> <ol> <li>I would like to convince many people and companies to sponsor open-source projects.</li> <li>Lowering the minimum amount allows you to support other projects as well.</li> <li>The ultimate goal is to have the time to work on my projects without having to offer sponsor-only features. I don't know if that will work out, but I think it's worth a try.</li> </ol>"},{"location":"insiders/#getting-started","title":"Getting started","text":"<p>The inline-snapshot insider version is API-compatible with the normal inline-snapshot version, but offers several usability improvements. Note that in order to access the Insiders repository, you need to become an eligible sponsor of @15r10nk on GitHub with $10 per month or more. You will then be invited to join the insider team and gain access to the repositories that are only accessible to insiders.</p> <p>You can then install the insiders version with pip from the git repository:</p> <pre><code>pip install git+ssh://git@github.com/15r10nk-insiders/inline-snapshot.git\n</code></pre> <p>This version offers you the features described at the top. You can continue to use the inline-snapshot version you have downloaded after you stop sponsoring me, but you will no longer have access to the insider repository or updates.</p>"},{"location":"insiders/#every-contribution-counts","title":"Every contribution counts!","text":"<p>Whether you\u2019re an individual developer or a company, your sponsorship helps keep inline-snapshot moving forward. Together, we can make open-source better for everyone.</p>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#only-cpython-is-supported","title":"Only CPython is supported","text":"<p>Currently, inline-snapshot only works with CPython. On other Python implementations, such as PyPy, inline-snapshot acts as if <code>--inline-snapshot=disable</code> is set, allowing tests to pass but not providing any way to update snapshots.</p>"},{"location":"limitations/#pytest-xdist-is-not-supported","title":"pytest-xdist is not supported","text":"<p>pytest-xdist splits test runs across multiple processes. This prevents inline-snapshot from being able to update snapshots across multiple processes, so if you have pytest-xdist installed and active, inline-snapshot will act as if <code>--inline-snapshot=disable</code> is set.</p> <p>If you have pytest-xdist installed and active by default in your pytest settings, you can disable it for a single test run with its <code>-n0</code> option. Then inline-snapshot will act as usual, or you can pass alternative flags with <code>--inline-snapshot</code>:</p> <pre><code>pytest -n0 --inline-snapshot=create,report\n</code></pre>"},{"location":"limitations/#on-cpython-311-pytest-assert-rewriting-can-be-disabled","title":"On CPython &lt; 3.11, pytest assert rewriting can be disabled","text":"<p>On CPython versions before 3.11, inline-snapshot must disable pytest assert rewriting if you use any of these flags: <code>report</code>, <code>review</code>, <code>create</code>, <code>fix</code>, <code>trim</code>, or <code>update</code>.</p>"},{"location":"pycharm/","title":"PyCharm","text":"<p>Info</p> <p>The following feature is available for insiders  only and requires CPython &gt;= 3.11 to generate code. The generated code can be used with any version of Python.</p> <p>The PyCharm integration allows you to create snapshots directly within your IDE.</p> <p>Approving changes to existing values currently works only via the CLI.</p> <p>Note</p> <p>VSCode support is also planned, but it is currently blocked by this issue.</p>"},{"location":"pytest/","title":"Pytest","text":"<p>inline-snapshot provides one pytest option with different flags (create, fix, trim, update, short-report, report, disable).</p> <p>Snapshot comparisons return always <code>True</code> if you use one of the flags create, fix or review. This is necessary because the whole test needs to be run to fix all snapshots like in this case:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot(5)\n    assert 2 &lt;= snapshot(5)\n</code></pre> <p>Note</p> <p>Every flag with the exception of disable and short-report disables the pytest assert-rewriting.</p>"},{"location":"pytest/#-inline-snapshotcreatefixtrimupdate","title":"--inline-snapshot=create,fix,trim,update","text":"<p>Approve the changes of the given category. These flags can be combined with report and review.</p> test_something.py<pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot()\n    assert 2 &lt;= snapshot(5)\n</code></pre> <pre><code>&gt; pytest test_something.py --inline-snapshot=create,report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.1, pluggy-1.6.0\nrootdir: /tmp/tmp.GlQg3On7KT\nplugins: inline-snapshot-0.31.1\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes will be applied, because you used ]8;id=510912;https://15r10nk.github.io/inline-snapshot/latest/categories/#create\\create]8;;\\\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot(1)                                                 \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=]8;id=333335;https://15r10nk.github.io/inline-snapshot/latest/categories/#trim\\trim]8;;\\ to apply them, or use the interactive mode with \n--inline-snapshot=]8;id=328255;https://15r10nk.github.io/inline-snapshot/latest/pytest/#-inline-snapshotreview\\review]8;;\\\n\n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --inline-snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.11s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotshort-report","title":"--inline-snapshot=short-report","text":"<p>give a short report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=short-report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.1, pluggy-1.6.0\nrootdir: /tmp/tmp.Rp5r1XdrVT\nplugins: inline-snapshot-0.31.1\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nInfo: one snapshot can be trimmed (--inline-snapshot=trim)\nError: one snapshot is missing a value (--inline-snapshot=create)\n\nYou can also use --inline-snapshot=review to approve the changes interactively\n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --inline-snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.12s ==========================\n</code></pre> <p>Info</p> <p>short-report exists mainly to show that snapshots have changed with enabled pytest assert-rewriting. This option will be replaced with report when this restriction is lifted.</p>"},{"location":"pytest/#-inline-snapshotreport","title":"--inline-snapshot=report","text":"<p>Shows a diff report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.1, pluggy-1.6.0\nrootdir: /tmp/tmp.ChGTgBQnD3\nplugins: inline-snapshot-0.31.1\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=]8;id=984219;https://15r10nk.github.io/inline-snapshot/latest/categories/#create\\create]8;;\\ to apply them, or use the interactive mode with \n--inline-snapshot=]8;id=376324;https://15r10nk.github.io/inline-snapshot/latest/pytest/#-inline-snapshotreview\\review]8;;\\\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot()                                                  \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=]8;id=433836;https://15r10nk.github.io/inline-snapshot/latest/categories/#trim\\trim]8;;\\ to apply them, or use the interactive mode with \n--inline-snapshot=]8;id=550272;https://15r10nk.github.io/inline-snapshot/latest/pytest/#-inline-snapshotreview\\review]8;;\\\n\n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --inline-snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.10s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotreview","title":"--inline-snapshot=review","text":"<p>Shows a diff report for each category and ask if you want to apply the changes</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=review\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-9.0.1, pluggy-1.6.0\nrootdir: /tmp/tmp.suuJK3eUYL\nplugins: inline-snapshot-0.31.1\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nDo you want to ]8;id=103888;https://15r10nk.github.io/inline-snapshot/latest/categories/#create\\create]8;;\\ these snapshots? [y/n] (n): \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot(1)                                                 \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nDo you want to ]8;id=798262;https://15r10nk.github.io/inline-snapshot/latest/categories/#trim\\trim]8;;\\ these snapshots? [y/n] (n): \n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --inline-snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.11s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotdisable","title":"--inline-snapshot=disable","text":"<p>Disables all the snapshot logic. <code>snapshot(x)</code> will just return <code>x</code> and inline-snapshot will not be able to fix snapshots or to generate reports. This can be used if you think that snapshot logic causes a problem in your tests. It is also the default for CI runs.</p> <p>deprecation</p> <p>This option was previously called <code>--inline-snapshot-disable</code></p>"},{"location":"testing/","title":"Testing","text":"<p><code>inline_snapshot.testing</code> provides tools that can be used to test inline-snapshot workflows. This might be useful if you want to build your own libraries based on inline-snapshot.</p> <p>The following example shows how you can use the <code>Example</code> class to test what inline-snapshot would do with the given source code. The snapshots in the argument are asserted inside the <code>run_*</code> methods. Some arguments are optional, and some are required. Please see the reference below for details.</p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n\"\"\"\n        }\n    ).run_pytest(  # run with the create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(),\n        returncode=snapshot(),\n    )\n</code></pre> <p>Inline-snapshot will then populate the empty snapshots.</p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n\"\"\"\n        }\n    ).run_pytest(  # run with the create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(\n            {\n                \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot(2)\n\"\"\"\n            }\n        ),\n        returncode=snapshot(1),\n    )\n</code></pre> <p>The <code>Example</code> object is immutable and not connected to any directory. A temporary directory is only created when you call a <code>run_*</code> method. The result of the <code>run_*</code> method is always a new <code>Example</code> object with the updated files. This means that you can create an <code>Example</code> and call the <code>run_*</code> methods on it in any order you want, with the arguments that are useful for your test case.</p> <p>This allows for more complex tests where you create one example and perform multiple test runs on it. Every test run will work on the changed files from the previous one.</p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n    assert 1+5 == snapshot(2)\n\"\"\"\n        }\n    ).run_pytest(  # run with the create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(\n            {\n                \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot(2)\n    assert 1+5 == snapshot(2)\n\"\"\"\n            }\n        ),\n        returncode=snapshot(1),\n    ).run_pytest(  # run with the create flag and check the changed files\n        [\"--inline-snapshot=fix\"],\n        changed_files=snapshot(\n            {\n                \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot(2)\n    assert 1+5 == snapshot(6)\n\"\"\"\n            }\n        ),\n        returncode=snapshot(1),\n    )\n</code></pre> <p>You can also use the same example multiple times and call different methods on it.</p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    e = Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n    assert 1+5 == snapshot(2)\n\"\"\"\n        }\n    )\n    e.run_inline(  # run without flags\n        reported_categories=snapshot([\"create\", \"fix\"]),\n    )\n\n    e.run_pytest(\n        [\"--inline-snapshot=short-report\"],  # check the pytest report\n        changed_files=snapshot({}),\n        report=snapshot(\n            \"\"\"\\\nError: one snapshot is missing a value (--inline-snapshot=create)\nYou can also use --inline-snapshot=review to approve the changes interactively\\\n\"\"\"\n        ),\n        returncode=snapshot(1),\n    )\n    e.run_pytest(  # run with the create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(\n            {\n                \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot(2)\n\"\"\"\n            }\n        ),\n        returncode=snapshot(1),\n    )\n</code></pre>"},{"location":"testing/#api","title":"API","text":""},{"location":"testing/#inline_snapshot.testing.Example","title":"<code>Example</code>","text":""},{"location":"testing/#inline_snapshot.testing.Example.__init__","title":"<code>__init__(files)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>files</code> <code>str | bytes | dict[str, str | bytes]</code> <p>a collection of files which are used as your example project,    or just a string which will be saved as tests/test_something.py.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.change_code","title":"<code>change_code(mapping)</code>","text":"<p>Changes example tests by mapping every file with the given function.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Callable[[str], str]</code> <p>function to apply to each file's content.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.read_file","title":"<code>read_file(filename)</code>","text":"<p>Reads a file from the example.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.remove_file","title":"<code>remove_file(filename)</code>","text":"<p>Removes a file from the example.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the file to be removed.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.replace","title":"<code>replace(old_text, new_text)</code>","text":"<p>Changes example tests by replacing old_text with new_text.</p> <p>Parameters:</p> Name Type Description Default <code>old_text</code> <code>str</code> <p>the text to be replaced.</p> required <code>new_text</code> <code>str</code> <p>the new text to use instead.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.run_inline","title":"<code>run_inline(args=[], *, reported_categories=None, changed_files=None, report=None, raises=None, stderr=None)</code>","text":"<p>Execute the example files in process and run every <code>test_*</code> function.</p> <p>This is useful for fast test execution.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>inline-snapshot arguments (supports only \"--inline-snapshot=fix|create|...\").</p> <code>[]</code> <code>reported_categories</code> <code>Snapshot[list[Category]] | None</code> <p>snapshot of categories which inline-snapshot thinks could be applied.</p> <code>None</code> <code>changed_files</code> <code>Snapshot[dict[str, str]] | None</code> <p>snapshot of files which are changed by this run.</p> <code>None</code> <code>raises</code> <code>Snapshot[str] | None</code> <p>snapshot of the exception raised during test execution.     Required if your code raises an exception.</p> <code>None</code> <p>Returns:</p> Type Description <code>Example</code> <p>A new Example instance containing the changed files.</p>"},{"location":"testing/#inline_snapshot.testing.Example.run_pytest","title":"<code>run_pytest(args=[], *, term_columns=80, env={}, changed_files=None, report=None, error=None, stderr=None, returncode=0, stdin=b'', outcomes=None)</code>","text":"<p>Run pytest with the given args and environment variables in a separate process.</p> <p>It can be used to test the interaction between your code and pytest, but it is a bit slower than <code>run_inline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>pytest arguments like \"--inline-snapshot=fix\"</p> <code>[]</code> <code>env</code> <code>dict[str, str]</code> <p>dict of environment variables</p> <code>{}</code> <code>changed_files</code> <code>Snapshot[dict[str, str]] | None</code> <p>snapshot of files changed by this run.</p> <code>None</code> <code>report</code> <code>Snapshot[str] | None</code> <p>snapshot of the report at the end of the pytest run.</p> <code>None</code> <code>stderr</code> <code>Snapshot[str] | None</code> <p>pytest stderr output</p> <code>None</code> <code>returncode</code> <code>Snapshot[int]</code> <p>snapshot of the pytest return code.</p> <code>0</code> <p>Returns:</p> Type Description <code>Example</code> <p>A new Example instance containing the changed files.</p>"},{"location":"testing/#inline_snapshot.testing.Example.with_files","title":"<code>with_files(extra_files)</code>","text":"<p>Adds extra files to the example.</p> <p>Parameters:</p> Name Type Description Default <code>extra_files</code> <code>dict[str, str | bytes]</code> <p>dictionary of filenames and file contents.</p> required"},{"location":"third_party/","title":"third-party","text":"<p>Third-party extensions can be used to enhance the testing experience with other frameworks. The goal of inline-snapshot is to provide the core functionality for many different use cases.</p> <p>List of current third-party extensions:</p> <ul> <li>inline-snapshot-django Extensions for using inline-snapshot to test Django projects.</li> <li>inline-snapshot-pandas pandas integration for inline-snapshot (insider only)</li> </ul> <p>How to add your extension to this list?</p> <p>Your package name has to start with <code>inline-snapshot-</code> or end with <code>-inline-snapshot</code> and has to be available on PyPI. The summary of your package will be used as description.</p> <p>I will update this list from time to time but you can accelerate this process by creating a new issue.</p>"},{"location":"types/","title":"types","text":""},{"location":"types/#inline_snapshot","title":"<code>inline_snapshot</code>","text":""},{"location":"types/#inline_snapshot.Category","title":"<code>Category = Literal['update', 'fix', 'create', 'trim', 'fix-assert']</code>  <code>module-attribute</code>","text":"<p>See categories</p>"},{"location":"types/#inline_snapshot.Snapshot","title":"<code>Snapshot</code>","text":"<p>Can be used to annotate function arguments which accept snapshot values.</p> <p>You can annotate function arguments with <code>Snapshot[T]</code> to declare that a snapshot-value can be passed as function argument. <code>Snapshot[T]</code> is a type alias for <code>T</code>, which allows you to pass <code>int</code> values instead of <code>int</code> snapshots.</p> <p>Example:</p> <pre><code>from typing import Optional\nfrom inline_snapshot import snapshot, Snapshot\n\n# required snapshots\n\n\ndef check_in_bounds(value, lower: Snapshot[int], upper: Snapshot[int]):\n    assert lower &lt;= value &lt;= upper\n\n\ndef test_numbers():\n    for c in \"hello world\":\n        check_in_bounds(ord(c), snapshot(32), snapshot(119))\n\n    # use with normal values\n    check_in_bounds(5, 0, 10)\n\n\n# optional snapshots\n\n\ndef check_container(\n    value,\n    *,\n    value_repr: Optional[Snapshot[str]] = None,\n    length: Optional[Snapshot[int]] = None\n):\n    if value_repr is not None:\n        assert repr(value) == value_repr\n\n    if length is not None:\n        assert len(value) == length\n\n\ndef test_container():\n    check_container([1, 2], value_repr=snapshot(\"[1, 2]\"), length=snapshot(2))\n\n    check_container({1, 1}, length=snapshot(1))\n</code></pre> Source code in <code>src/inline_snapshot/_types.py</code> <pre><code>class Snapshot(Protocol[T]):\n    \"\"\"Can be used to annotate function arguments which accept snapshot\n    values.\n\n    You can annotate function arguments with `Snapshot[T]` to declare that a snapshot-value can be passed as function argument.\n    `Snapshot[T]` is a type alias for `T`, which allows you to pass `int` values instead of `int` snapshots.\n\n\n    Example:\n    &lt;!-- inline-snapshot: create fix trim first_block outcome-passed=2 --&gt;\n    ``` python\n    from typing import Optional\n    from inline_snapshot import snapshot, Snapshot\n\n    # required snapshots\n\n\n    def check_in_bounds(value, lower: Snapshot[int], upper: Snapshot[int]):\n        assert lower &lt;= value &lt;= upper\n\n\n    def test_numbers():\n        for c in \"hello world\":\n            check_in_bounds(ord(c), snapshot(32), snapshot(119))\n\n        # use with normal values\n        check_in_bounds(5, 0, 10)\n\n\n    # optional snapshots\n\n\n    def check_container(\n        value,\n        *,\n        value_repr: Optional[Snapshot[str]] = None,\n        length: Optional[Snapshot[int]] = None\n    ):\n        if value_repr is not None:\n            assert repr(value) == value_repr\n\n        if length is not None:\n            assert len(value) == length\n\n\n    def test_container():\n        check_container([1, 2], value_repr=snapshot(\"[1, 2]\"), length=snapshot(2))\n\n        check_container({1, 1}, length=snapshot(1))\n    ```\n    \"\"\"\n\n    def __eq__(self, other: object, /) -&gt; bool: ...  # pragma: no cover\n</code></pre>"},{"location":"external/external/","title":"external()","text":"<p>Storing snapshots in the source code is the main feature of inline snapshots. This has the advantage that you can easily see changes in code reviews. However, it also has some drawbacks:</p> <ul> <li>It is problematic to snapshot a large amount of data, as it consumes significant space in your tests.</li> <li>Binary data or images are not human-readable in your tests.</li> </ul> <p><code>external()</code> solves this problem and integrates nicely with inline snapshots. It stores a reference to the external data in a special <code>external()</code> object, which can be used like <code>snapshot()</code>.</p> <p>There are different storage protocols, such as hash or uuid, and different file formats, such as .txt, .bin, and .json. It is also possible to implement custom file formats.</p> <p>Example:</p> <pre><code>from inline_snapshot import external\n\n\ndef test_something():\n    # inline-snapshot can determine the correct file types\n    assert \"string\" == external()\n    assert b\"bytes\" == external()\n\n    # Data structures with lists and dictionaries are stored as JSON\n    assert [\"json\", \"like\", \"data\"] == external()\n\n    # You can also explicitly specify the storage protocol\n    assert \"other text\" == external(\"uuid:\")\n\n    # And the format (.json instead of the default .txt in this case)\n    assert \"other text\" == external(\"uuid:.json\")\n</code></pre> <p>inline-snapshot will then fill in the missing parts when you create your snapshots. It will keep your specified protocols and file types and generate names for your snapshots.</p> <pre><code>from inline_snapshot import external\n\n\ndef test_something():\n    # inline-snapshot can determine the correct file types\n    assert \"string\" == external(\"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.txt\")\n    assert b\"bytes\" == external(\"uuid:f728b4fa-4248-4e3a-8a5d-2f346baa9455.bin\")\n\n    # Data structures with lists and dictionaries are stored as JSON\n    assert [\"json\", \"like\", \"data\"] == external(\n        \"uuid:eb1167b3-67a9-4378-bc65-c1e582e2e662.json\"\n    )\n\n    # You can also explicitly specify the storage protocol\n    assert \"other text\" == external(\n        \"uuid:f7c1bd87-4da5-4709-9471-3d60c8a70639.txt\"\n    )\n\n    # And the format (.json instead of the default .txt in this case)\n    assert \"other text\" == external(\n        \"uuid:e443df78-9558-467f-9ba9-1faf7a024204.json\"\n    )\n</code></pre> <p>The <code>external()</code> function can also be used inside other data structures.</p> <pre><code>from inline_snapshot import snapshot, external\n\n\ndef test_something():\n    assert [\"long text\\n\" * times for times in [1, 2, 1000]] == snapshot(\n        [..., ..., external()]\n    )\n</code></pre> <pre><code>from inline_snapshot import snapshot, external\n\n\ndef test_something():\n    assert [\"long text\\n\" * times for times in [1, 2, 1000]] == snapshot(\n        [\n            \"long text\\n\",\n            \"\"\"\\\nlong text\nlong text\n\"\"\",\n            external(\"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.txt\"),\n        ]\n    )\n</code></pre>"},{"location":"external/external/#storage-protocols","title":"Storage Protocols","text":""},{"location":"external/external/#uuid","title":"UUID","text":"<p>The <code>uuid:</code> storage protocol is the default protocol and stores the external files relative to the test files in <code>__inline_snapshot__/&lt;test_file&gt;/&lt;qualname&gt;/&lt;uuid&gt;.suffix</code>.</p> <ul> <li> Files are co-located with the file/function where your value is used.</li> <li> The use of a UUID allows inline-snapshot to find the external file even if file or function names of a test function have changed.</li> <li> Distinguishing multiple external snapshots in the same function remains challenging.</li> </ul> <p>Note</p> <p>Using the same external uuid multiple times like this is not supported:</p> <p> <pre><code>from inline_snapshot import external\n\n\ndef test_a():\n    assert \"test\" == external(\"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.txt\")\n\n\ndef test_b():\n    assert \"test\" == external(\"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.txt\")\n</code></pre></p> <p>This can happen when you copy tests and change them for another use case. inline-snapshot notifies you in this case, and you should change one external back to <code>external(\"uuid:\")</code> and create new external snapshots.</p> <p>The correct way to do use the same external in different tests is to assign the external to a variable and reuse this variable.</p> <p> <pre><code>from inline_snapshot import external\n\nexpected = external(\"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.txt\")\n\n\ndef test_a():\n    assert \"test\" == expected\n\n\ndef test_b():\n    assert \"test\" == expected\n</code></pre> </p>"},{"location":"external/external/#hash","title":"Hash","text":"<p>The <code>hash:</code> storage can be used to store snapshot files based on the hash of their content. This was the first storage protocol supported by inline-snapshot and can still be useful in some cases. It also preserves backward compatibility with older inline-snapshot versions.</p> <p>The external data is by default stored inside <code>&lt;pytest_config_dir&gt;/.inline-snapshot/external</code>, where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any. To store data in a different location, set the <code>storage-dir</code> option in pyproject.toml.</p> <ul> <li> Value changes cause source code changes because the hash changes.</li> <li> GitHub/GitLab web UIs cannot be used to view the diffs, because the filename changes.</li> </ul>"},{"location":"external/external/#formats","title":"Formats","text":"<p>inline-snapshot supports several built-in formats for external snapshots. The format used is determined by the given data type: bytes are stored in a <code>.bin</code> file, and strings are stored in a <code>.txt</code> file by default. More complex data types are stored in a <code>.json</code> file.</p> Suffix Priority Description <code>.bin</code> 0 Stores bytes in <code>.bin</code> files and shows them as a hexdump. <code>.txt</code> 0 Stores strings in <code>.txt</code> files. <code>.json</code> -10 Stores the data with <code>json.dump()</code>. <p>Custom formats are also supported.</p> <p>You can also use format aliases if you want to use specific file suffixes that have the same handling as existing formats. You must specify the suffix in this case.</p> <pre><code>from inline_snapshot import register_format_alias, external\n\nregister_format_alias(\".html\", \".txt\")\n\n\ndef test():\n    assert \"&lt;html&gt;&lt;/html&gt;\" == external(\".html\")\n</code></pre> <p>inline-snapshot uses the given suffix to create an external snapshot.</p> <pre><code>from inline_snapshot import register_format_alias, external\n\nregister_format_alias(\".html\", \".txt\")\n\n\ndef test():\n    assert \"&lt;html&gt;&lt;/html&gt;\" == external(\n        \"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.html\"\n    )\n</code></pre> <p>Breaking Change</p> <p><code>register_format_alias()</code> is required if you used <code>outsource(value, suffix=\"html\")</code> and are migrating from inline-snapshot prior to version 0.24.</p>"},{"location":"external/external/#pytest-options","title":"pytest Options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code>: Creates new external files.</li> <li><code>fix</code>: Changes external files.</li> <li><code>trim</code>: Removes all snapshots from the storage that are not referenced with <code>external(...)</code> in the code.</li> </ul>"},{"location":"external/external_file/","title":"external_file()","text":"<p><code>external_file()</code> is a lower-level solution than <code>external()</code>. It accepts one argument, which is the path to the file where your external object should be stored. It will only create or fix the given files and will never trim unused files.</p> <p>You can use it to generate files in your project.</p> <pre><code>def test_generate_doc():\n    assert generate_features_doc() == external_file(\"all_features.md\")\n</code></pre> <p>inline-snapshot checks whether your documentation is up to date and displays a diff that you can approve if necessary.</p> <p>Another use case is to check if some files in your project are correct by reading the file, transforming it, and comparing it with the current version. The transformation (<code>eval_code_blocks()</code> in the example) of the text should produce the same result if everything is correct. The test will fail if the transformation results in different output, and inline-snapshot will show you the diff, as it does for other external comparisons.</p> <pre><code>def test_files():\n    for file in root.rglob(\"*.md\", format=\".txt\"):\n        current_text = file.read_text()\n\n        # eval_code_blocks is a custom function that could run your examples in a project-specific way and store the output in the documentation.\n        # It is up to you to implement such functions for your specific use case.\n        correct_text = eval_code_blocks(current_text)\n\n        assert correct_text == external_file(file)\n</code></pre>"},{"location":"external/external_file/#inline_snapshot.external_file","title":"<code>external_file(path, *, format=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>the path to the external file, relative to the directory of the current file.</p> required <code>format</code> <code>Optional[str]</code> <p>overwrite the format handler which should be used to load and save the content.     It can be used to treat markdown files as text files with <code>format=\".txt\"</code> for example.</p> <code>None</code>"},{"location":"external/outsource/","title":"outsource()","text":"<p><code>outsource()</code> can be used to declare that a value should be stored in an external object when you create it. This is useful in cases where you already know that a value can only be stored externally, and you want to return it from a function, for example.</p> <pre><code>from inline_snapshot import outsource, register_format_alias, snapshot\n\nregister_format_alias(\".png\", \".bin\")\n\n\ndef check_captcha(input_data):\n    # Perform operations on input_data ...\n    the_data = b\"image data ...\"\n\n    return {\n        \"size\": \"200x100\",\n        \"difficulty\": 8,\n        \"picture\": outsource(the_data, suffix=\".png\"),\n    }\n\n\ndef test_captcha():\n    assert check_captcha(\"abc\") == snapshot()\n</code></pre> <p>inline-snapshot always generates an external object in this case.</p> <pre><code>from inline_snapshot import outsource, register_format_alias, snapshot\n\nfrom inline_snapshot import external\n\nregister_format_alias(\".png\", \".bin\")\n\n\ndef check_captcha(input_data):\n    # Perform operations on input_data ...\n    the_data = b\"image data ...\"\n\n    return {\n        \"size\": \"200x100\",\n        \"difficulty\": 8,\n        \"picture\": outsource(the_data, suffix=\".png\"),\n    }\n\n\ndef test_captcha():\n    assert check_captcha(\"abc\") == snapshot(\n        {\n            \"size\": \"200x100\",\n            \"difficulty\": 8,\n            \"picture\": external(\"hash:0da2cc316111*.png\"),\n        }\n    )\n</code></pre> <p><code>outsource()</code> was the only way to create external objects until inline-snapshot 0.24. External objects can now also be created with <code>external()</code> and used like <code>snapshot()</code>.</p> <p>Info</p> <p>It is not possible to specify the storage protocol when you call <code>outsource()</code> because this is something that should be under the control of the user who uses this external object.</p> <p>Limitation</p> <p><code>outsource()</code> currently always uses the hash protocol when it creates a new external object. This is a limitation that will be addressed in the future. It is possible to change it later to <code>external(\"uuid:\")</code> manually if you want to store it in a different location.</p>"},{"location":"external/register_format/","title":"@register_format()","text":""},{"location":"external/register_format/#general","title":"General","text":"<p><code>register_format()</code> allows you to add support for your custom file formats, such as the following <code>Array</code> type.</p> <p>my_array.py<pre><code>from dataclasses import dataclass\nfrom typing import List\n\n\n@dataclass\nclass Array:\n    numbers: List[int]\n</code></pre> </p> conftest.py<pre><code>from pathlib import Path\nfrom inline_snapshot import register_format, TextDiff, Format\n\nfrom my_array import Array\n\n\n@register_format\nclass ArrayFormat(TextDiff, Format[Array]):\n    suffix = \".arr\"\n\n    @staticmethod\n    def is_format_for(data: object):\n        return isinstance(data, Array)\n\n    @staticmethod\n    def encode(value: Array, path: Path):\n        with path.open(\"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            f.write(\"\\n\".join(map(str, value.numbers)))\n\n    @staticmethod\n    def decode(path: Path) -&gt; Array:\n        with path.open(\"r\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            return Array(list(map(int, f.read().splitlines())))\n</code></pre> <p>You can then use <code>external()</code> to save this type into an external file.</p> <pre><code>from my_array import Array\nfrom inline_snapshot import external\n\n\ndef test_array():\n    assert Array([1, 2, 3]) == external()\n</code></pre> <p>inline-snapshot will check if the type matches by using <code>is_format_for()</code> and create a file with the given suffix.</p> <pre><code>from my_array import Array\nfrom inline_snapshot import external\n\n\ndef test_array():\n    assert Array([1, 2, 3]) == external(\n        \"uuid:e3e70682-c209-4cac-a29f-6fbed82c07cd.arr\"\n    )\n</code></pre>"},{"location":"external/register_format/#report","title":"Report","text":"<p>inline-snapshot needs to know how changes in your external files should be displayed. <code>TextDiff</code> and <code>BinaryDiff</code> can be used as mixin classes (see the <code>Array</code> example (above)[#array-example]) to provide generic representations for text or binary formats, but you can also define custom functions for your files.</p> <ul> <li><code>rich_diff()</code> is used every time the external snapshot value is changed and should show the difference between the original and new versions in a human-readable form.</li> <li><code>rich_show()</code> is used every time an external snapshot is created and should show a human-readable form of the initial value.</li> </ul> conftest.py<pre><code>from pathlib import Path\nfrom inline_snapshot import register_format, Format, external\nfrom number_set import NumberSet\n\n\n@register_format\nclass NumberSetFormat(Format[NumberSet]):\n    suffix = \".numberset\"\n\n    def rich_diff(self, original: Path, new: Path):\n        original_numbers = set(self.decode(original).numbers)\n        new_numbers = set(self.decode(new).numbers)\n\n        return (\n            f\"new numbers: [green]{new_numbers-original_numbers}[/]\\n\"\n            f\"removed numbers: [red]{original_numbers-new_numbers}[/]\"\n        )\n\n    def rich_show(self, path: Path):\n        return \" \".join(f\"[blue]{n}[/]\" for n in self.decode(path).numbers)\n\n    def is_format_for(self, data: object):\n        return isinstance(data, NumberSet)\n\n    def encode(self, value: NumberSet, path: Path):\n        with path.open(\"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            f.write(\"\\n\".join(sorted(map(str, value.numbers))))\n\n    def decode(self, path: Path) -&gt; NumberSet:\n        with path.open(\"r\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            return NumberSet(set(map(int, f.read().splitlines())))\n</code></pre> number_set.py<pre><code>from dataclasses import dataclass\nfrom typing import Set\n\n\n@dataclass\nclass NumberSet:\n    numbers: Set[int]\n</code></pre> <p>The custom format is then used every time a <code>NumberSet</code> is compared with an empty external.</p> example pytest outputexample <p></p> <p> <pre><code>from inline_snapshot import external\nfrom number_set import NumberSet\n\n\ndef test():\n    assert NumberSet([1, 2, 5]) == external(\"hash:b85198032326*.numberset\")\n    assert NumberSet([1, 2, 8]) == external(\"hash:f8a68eb0c510*.numberset\")\n</code></pre></p>"},{"location":"external/register_format/#reference","title":"Reference","text":""},{"location":"external/register_format/#inline_snapshot.Format","title":"<code>Format</code>","text":"<p>Base class for the Format Protocol.</p>"},{"location":"external/register_format/#inline_snapshot.Format.priority","title":"<code>priority = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determines the correct format when multiple format handlers can handle a given value (<code>is_format_for</code>).</p> <p>priority is <code>0</code> by default and can be set to a smaller number for generic formats that work with many data types (e.g., .json), where <code>is_format_for()</code> also returns <code>True</code> for <code>str</code> and <code>bytes</code>. This allows you to use <code>assert \"text\" == external()</code> without explicitly providing a <code>\".txt\"</code> suffix to distinguish it from <code>\".json\"</code>.</p> <p>A higher priority can be used for more specific formats, such as bytes with a <code>b\"\\x89PNG\"</code> prefix that should be stored as .png files.</p>"},{"location":"external/register_format/#inline_snapshot.Format.suffix","title":"<code>suffix</code>  <code>instance-attribute</code>","text":"<p>The suffix associated with this format handler.</p> <p>Every format implementation must define a suffix. This suffix is used when the external file is written and is required to find the correct format handler when the file is read again.</p>"},{"location":"external/register_format/#inline_snapshot.Format.decode","title":"<code>decode(path)</code>","text":"<p>Reads the value from the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to a temporary file where the value is stored.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value of the external object.</p>"},{"location":"external/register_format/#inline_snapshot.Format.encode","title":"<code>encode(value, path)</code>","text":"<p>Converts the value and stores it in the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to be stored.</p> required <code>path</code> <code>Path</code> <p>The path to a temporary file where the value should be stored.</p> required"},{"location":"external/register_format/#inline_snapshot.Format.is_format_for","title":"<code>is_format_for(value)</code>","text":"<p>Determines if this format handler can handle the given value.</p> <p>This function is used to find the correct format handler when no suffix is provided.</p> <pre><code>assert value == external()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>The value to be formatted.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value is handled by this format implementation.</p>"},{"location":"external/register_format/#inline_snapshot.Format.rich_diff","title":"<code>rich_diff(original, new)</code>","text":"<p>Displays a diff between the original and new files.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Path</code> <p>The path to the original external file.</p> required <code>new</code> <code>Path</code> <p>The path to the new external file.</p> required <p>Returns:</p> Type Description <code>RenderableType</code> <p>A rich renderable object representing the diff. This can be a</p> <code>RenderableType</code> <p>textual diff or another type of representation.</p>"},{"location":"external/register_format/#inline_snapshot.Format.rich_show","title":"<code>rich_show(path)</code>","text":"<p>Displays a representation of a newly created external object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the external file.</p> required <p>Returns:</p> Type Description <code>RenderableType</code> <p>A rich renderable object representing the new object. The</p> <code>RenderableType</code> <p>representation should be concise.</p>"},{"location":"external/register_format/#inline_snapshot.register_format","title":"<code>register_format(format=None, *, replace_handler=False)</code>","text":"<p>Registers a new format handler for the suffix <code>format.suffix</code>.</p> <p>This function can also be used as a decorator:</p> <pre><code>@register_format\nclass MyFormat: ...\n</code></pre> <p>which is equivalent to:</p> <pre><code>register_format(MyFormat())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>type[Format[FormatT]] | Format[FormatT] | None</code> <p>The format handler class or instance.</p> <code>None</code> <code>replace_handler</code> <code>bool</code> <p>If <code>True</code>, replaces an existing handler for the same suffix.</p> <code>False</code> <p>Raises:</p> Type Description <code>UsageError</code> <p>If a handler for the same suffix already exists and <code>replace_handler</code> is not set to <code>True</code>.</p>"},{"location":"external/register_format/#inline_snapshot.register_format_alias","title":"<code>register_format_alias(suffix, format)</code>","text":"<p>Registers an alias for a given format suffix.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>The suffix to register the alias for.</p> required <code>format</code> <code>str</code> <p>The suffix of the format that should be used instead.</p> required Notes <p>The alias suffix is used to find the correct format handler.</p>"},{"location":"howto/parametrize/","title":"pytest parametrize","text":"<p>inline-snapshot can also be used with <code>pytest.mark.parametrize</code>. All you have to do is to use <code>snapshot()</code> as an parameter for your test</p> <pre><code>import pytest\nfrom inline_snapshot import snapshot\n\n\n@pytest.mark.parametrize(\n    \"a,b,result\",\n    [\n        (1, 2, snapshot()),\n        (3, 4, snapshot()),\n    ],\n)\ndef test_param(a, b, result):\n    assert a + b == result\n</code></pre> <p>and the missing value will be created for each run.</p> <pre><code>import pytest\nfrom inline_snapshot import snapshot\n\n\n@pytest.mark.parametrize(\n    \"a,b,result\",\n    [\n        (1, 2, snapshot(3)),\n        (3, 4, snapshot(7)),\n    ],\n)\ndef test_param(a, b, result):\n    assert a + b == result\n</code></pre>"}]}