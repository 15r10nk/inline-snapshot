{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-inline-snapshot","title":"Welcome to inline-snapshot","text":"<p>inline-snapshot can be used for different things:</p> <ul> <li>golden master/approval/snapshot testing.   The idea is that you have a function with a currently unknown result and you want to write a test, which ensures that the result does not change during refactoring.</li> <li>Compare things which are complex like lists with lot of numbers or complex data structures.</li> <li>Things which might change during the development like error messages.</li> </ul> <p><code>inline-snapshot</code> automates the process of recording, storing and updating the value you want to compare with. The value is converted with <code>repr()</code> and stored in the source file as argument of the <code>snapshot()</code> function.</p> <p>News</p> <p>Hello, I would like to inform you about some changes.</p> <p>I have started to offer insider features for inline-snapshot. I will only release features as insider features if they will not cause problems for you when used in an open source project.</p> <p>I hope this will allow me to spend more time working on open source projects. Thank you for using inline-snapshot, the future will be \ud83d\ude80.</p> <p>The first feature is that inline-snapshot can now also fix normal assertions which do not use <code>snapshot()</code> like:</p> <pre><code>assert 1 + 1 == 3\n</code></pre> <p>You can learn here more about this feature.</p>"},{"location":"#usage","title":"Usage","text":"<p>You can use <code>snapshot()</code> instead of the value which you want to compare with and run the tests to record the correct values.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p>Your tests will break, if you change your code by adding <code>// 18</code>. Maybe that is correct and you should fix your code, or your code is correct and you want to update your test results.</p> changed code--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(1590054)\n</code></pre></p> <p>Please verify the new results. <code>git diff</code> will give you a good overview over all changed results. Use <code>pytest -k test_something --inline-snapshot=fix</code> if you only want to change one test.</p>"},{"location":"#supported-operations","title":"Supported operations","text":"<p>You can use <code>snapshot(x)</code> like you can use <code>x</code> in your assertion with a limited set of operations:</p> <ul> <li><code>value == snapshot()</code> to compare with something,</li> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</li> </ul> <p>Warning</p> <p>One snapshot can only be used with one operation. The following code will not work:  <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot(5)\n    assert 5 &lt;= s\n    assert 5 == s\n\n\n# Error:\n# &gt;       assert 5 == s\n# E       TypeError: This snapshot cannot be use with `==`, because it was previously used with `x &lt;= snapshot`\n</code></pre></p>"},{"location":"#supported-usage","title":"Supported usage","text":"<p>It is possible to place <code>snapshot()</code> anywhere in the tests and reuse it multiple times.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 21 * 2\n\n\nresult = snapshot()\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 21 * 2\n\n\nresult = snapshot(42)\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p><code>snapshot()</code> can also be used in loops:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot(3)\n</code></pre></p> <p>or passed as an argument to a function:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot())\n    check_string_len(\"1234\", snapshot())\n    check_string_len(\".......\", snapshot())\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot(3))\n    check_string_len(\"1234\", snapshot(4))\n    check_string_len(\".......\", snapshot(7))\n</code></pre></p>"},{"location":"#feedback","title":"Feedback","text":"<p>inline-snapshot provides some advanced ways to work with snapshots.</p> <p>I would like to know how these features are used to further improve this small library. Let me know if you've found interesting use cases for this library via twitter, fosstodon or in the github discussions.</p>"},{"location":"#sponsors","title":"Sponsors","text":"<p>I would like to thank my sponsors. Without them, I would not be able to invest so much time in my projects.</p>"},{"location":"#bronze-sponsor","title":"Bronze sponsor \ud83e\udd49","text":""},{"location":"#issues","title":"Issues","text":"<p>If you encounter any problems, please report an issue along with a detailed description.</p>"},{"location":"alternatives/","title":"Alternatives","text":"<p>inline-snapshot is not the only snapshot library for python. There are several others to:</p> <ul> <li>syrupy</li> <li>snapshottest</li> <li>pytest-snapshot</li> <li>pytest-insta</li> </ul> <p>All of them have things that make them unique. What sets inline-snapshot apart is the ability to store snapshots directly in the source code. This leads to less indirections in the code which improves readability and code-reviews.</p> <p>If you miss a feature that is available in other libraries, please let me know.</p> <p> </p>"},{"location":"categories/","title":"Categories","text":"<p>Each snapshot change is assigned to a different category. This is done because inline-snapshot supports more than just <code>==</code> checks.</p> <p>There are changes which:</p> <ul> <li>create new snapshot values</li> <li>fix your tests</li> <li>update only the syntax to a new representation</li> <li>trim unused pieces from your snapshots</li> </ul> <p>Create and fix are mainly used, but it is good to know what type of change you are approving, because it helps with the decision if this changes should be applied.</p>"},{"location":"categories/#categories","title":"Categories","text":""},{"location":"categories/#create","title":"Create","text":"<p>These changes are made when new snapshots are created.</p> <p>The result of each comparison is <code>True</code>, which allows to run the whole test to fill all new snapshots with values.</p> <p>Example:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 5 == snapshot()\n\n    assert 5 &lt;= snapshot()\n\n    assert 5 in snapshot()\n\n    s = snapshot()\n    assert 5 == s[\"key\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 5 == snapshot(5)\n\n    assert 5 &lt;= snapshot(5)\n\n    assert 5 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 5 == s[\"key\"]\n</code></pre>"},{"location":"categories/#fix","title":"Fix","text":"<p>These changes are made when the snapshots comparison does not return <code>True</code> any more (depending on the operation <code>==</code>, <code>&lt;=</code>, <code>in</code>). The result of each comparison is <code>True</code> if you change something from this category, which allows to run the whole test and to fix other snapshots.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 8 == snapshot(5)\n\n    assert 8 &lt;= snapshot(5)\n\n    assert 8 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 8 == s[\"key\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 8 == snapshot(8)\n\n    assert 8 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key\": 8})\n    assert 8 == s[\"key\"]\n</code></pre> <p>Info</p> <p>The main reason for the different categories is to make the number of changes in the fix category as small as possible. The changes in the fix category are the only changes which change the value of the snapshots and should be reviewed carefully.</p>"},{"location":"categories/#trim","title":"Trim","text":"<p>These changes are made when parts of the snapshots are removed which are no longer needed, or if limits can be reduced.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key1\": 1, \"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 &lt;= snapshot(2)\n\n    assert 8 in snapshot([8])\n\n    s = snapshot({\"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <p>There might be problems in cases where you use the same snapshot in different tests, run only one test and trim the snapshot with <code>pytest -k test_a --inline-snapshot=trim</code> in this case:</p> <pre><code>from inline_snapshot import snapshot\n\ns = snapshot(5)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\ns = snapshot(2)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <p>The value of the snapshot is reduced to <code>2</code>, because <code>test_a()</code> was the only test running and inline-snapshot does not know about <code>5 &lt;= s</code>. It is recommended to use trim only if you run your complete test suite.</p>"},{"location":"categories/#update","title":"Update","text":"<p>Changes in the update category do not change the value of the snapshot, just its representation. These updates are not shown by default in your reports and can be enabled with show-updates. The reason might be that <code>repr()</code> of the object has changed or that inline-snapshot provides some new logic which changes the representation. Like with the strings in the following example:</p> original--inline-snapshot=update <p> <pre><code>from inline_snapshot import snapshot\n\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\"a\\nb\\nc\\n\")\n\n    assert 5 == snapshot(4 + 1)\n\n    assert Vector(1, 2) == snapshot(Vector(x=1, y=2))\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\n        \"\"\"\\\na\nb\nc\n\"\"\"\n    )\n\n    assert 5 == snapshot(5)\n\n    assert Vector(1, 2) == snapshot(Vector(1, 2))\n</code></pre></p> <p>The approval of this type of changes is easier, because inline-snapshot assures that the value has not changed.</p> <p>The goal of inline-snapshot is to generate the values for you in the correct format so that no manual editing is required. This improves your productivity and saves time. Keep in mind that any changes you make to your snapshots will likely need to be redone if your program's behaviour (and expected values) change. Inline-snapshot uses the update category to let you know when it has a different opinion than you about how the code should look. You can agree with inline-snapshot and accept the changes or you can use one of the following options to tell inline-snapshot what the code should look like:</p> <ol> <li> <p>change the <code>__repr__</code> implementation of your object or use customize repr if the class is not part of your codebase.</p> </li> <li> <p>define a format-command if another tool has a different opinion about how your code should look. Inline-snapshot will apply this formatting before reporting an update.</p> </li> <li> <p>inline-snapshot manages everything within <code>snapshot(...)</code>, but you can take control by using Is() in cases where you want to use custom code (like local variables) in your snapshots.</p> </li> <li> <p>you can also open an issue if you have a specific problem with the way inline-snapshot generates the code.</p> </li> </ol> <p>!!! note:     #177 will give the developer more control about how snapshots are created. update will them become much more useful.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#exec-1--upcoming-version-no-tag-matching-configuration-could-be-found","title":"upcoming version (No tag matching configuration could be found.","text":"<p>Possible causes: - version in configuration is not the current version - tag_format or legacy_tag_formats is missing, check them using 'git tag --list'</p> <p>? Is this the first tag created? (Y/n)</p> <pre><code>                                    ? Is this the first tag created? (Y/n))\n</code></pre>"},{"location":"changelog/#exec-1--changed","title":"Changed","text":"<ul> <li>Improved the explanation of what it means when snapshots are disabled in CI runs (#226).</li> </ul>"},{"location":"changelog/#exec-1--changed_1","title":"Changed","text":"<ul> <li>Added extra information to the reported failure when snapshots are fixed or created (#240).</li> </ul>"},{"location":"changelog/#exec-1--added","title":"Added","text":"<ul> <li>Add/fix reproducible standard repr for functions</li> </ul>"},{"location":"changelog/#exec-1--fixed","title":"Fixed","text":"<ul> <li>fix: changed format-command default to <code>\"\"</code> (#256).</li> </ul>"},{"location":"changelog/#exec-1--fixed_1","title":"Fixed","text":"<ul> <li>fixed the representation of empty strings in sub-snapshots from triple-quotes to single-quotes <code>assert \"\"==snapshot({5: \"\"})[5]</code> (#258).</li> </ul>"},{"location":"changelog/#exec-1--0232-2025-05-28","title":"0.23.2 \u2014 2025-05-28","text":""},{"location":"changelog/#exec-1--fixed_2","title":"Fixed","text":"<ul> <li>The <code>readline</code> module doesn't have to be installed on non-windows systems.</li> </ul>"},{"location":"changelog/#exec-1--0231-2025-05-26","title":"0.23.1 \u2014 2025-05-26","text":""},{"location":"changelog/#exec-1--changed_2","title":"Changed","text":"<ul> <li>changed how the <code>Snapshot[T]</code> type is implemented.</li> </ul>"},{"location":"changelog/#exec-1--fixed_3","title":"Fixed","text":"<ul> <li>command line flags work again in CI (#242)</li> </ul>"},{"location":"changelog/#exec-1--0230-2025-04-25","title":"0.23.0 \u2014 2025-04-25","text":""},{"location":"changelog/#exec-1--changed_3","title":"Changed","text":"<ul> <li>snapshot updates are now disabled by default. They be enabled with <code>show-updates=true</code> in your config. This is done because they can confuse new inline-snapshot users and does not fit the way how most users work with inline-snapshot. updates will become much more useful when (#177) is implemented.</li> </ul>"},{"location":"changelog/#exec-1--0223-2025-04-14","title":"0.22.3 \u2014 2025-04-14","text":""},{"location":"changelog/#exec-1--fixed_4","title":"Fixed","text":"<ul> <li>A pycharm environment is no longer incorrectly recognized as a CI environment.</li> </ul>"},{"location":"changelog/#exec-1--0222-2025-04-14","title":"0.22.2 \u2014 2025-04-14","text":""},{"location":"changelog/#exec-1--fixed_5","title":"Fixed","text":"<ul> <li>show correct diff when <code>pytest --inline-snapshot=report -vv</code> is used (#231)</li> </ul>"},{"location":"changelog/#exec-1--0221-2025-04-11","title":"0.22.1 \u2014 2025-04-11","text":""},{"location":"changelog/#exec-1--fixed_6","title":"Fixed","text":"<ul> <li> <p>The environment variable <code>INLINE_SNAPSHOT_DEFAULT_FLAGS</code> now takes precedence over all default flags defined in pyproject.toml.</p> </li> <li> <p>inline-snapshot can now be used in combination with <code>pytester.runpytest()</code></p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0220-2025-04-03","title":"0.22.0 \u2014 2025-04-03","text":""},{"location":"changelog/#exec-1--added_1","title":"Added","text":"<ul> <li>You can now use the config option <code>skip-snapshot-updates-for-now</code> to skip the reporting of updates.   But be aware that this option might not be there forever. Please create an issue if you think that the creation of snapshots can be improved.</li> </ul>"},{"location":"changelog/#exec-1--0213-2025-04-02","title":"0.21.3 \u2014 2025-04-02","text":""},{"location":"changelog/#exec-1--fixed_7","title":"Fixed","text":"<ul> <li>Allowed inline-snapshot to work when pytest-xdist is disabled with <code>-n 0</code>.</li> </ul>"},{"location":"changelog/#exec-1--0212-2025-03-31","title":"0.21.2 \u2014 2025-03-31","text":""},{"location":"changelog/#exec-1--fixed_8","title":"Fixed","text":"<ul> <li><code>repr(Is(x))</code> returns the same value as <code>repr(x)</code> to provide nice pytest outputs (#217)</li> </ul>"},{"location":"changelog/#exec-1--0211-2025-03-29","title":"0.21.1 \u2014 2025-03-29","text":""},{"location":"changelog/#exec-1--changed_4","title":"Changed","text":"<ul> <li>trailing white spaces in multi-line strings are now terminated with an <code>\\n\\</code>.     <pre><code>def test_something():\n    assert \"a   \\nb\\n\" == snapshot(\n        \"\"\"\\\na   \\n\\\nb\n\"\"\"\n    )\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0210-2025-03-28","title":"0.21.0 \u2014 2025-03-28","text":""},{"location":"changelog/#exec-1--changed_5","title":"Changed","text":"<ul> <li> <p>inline-snapshot uses now <code>--inline-snapshot=disable</code> during CI runs by default.     This improves performance because <code>snapshot()</code> is then equal to:     <pre><code>def snapshot(x):\n    return x\n</code></pre>     It also has benefits for the accuracy of your tests as it is less likely that inline snapshot will affect your tests in CI.</p> </li> <li> <p>The default flags have changed for cpython &gt;= 3.11:</p> <ul> <li><code>--inline-snapshot=create,review</code> is used in an interactive terminal and</li> <li><code>--inline-snapshot=report</code> otherwise.</li> </ul> </li> <li> <p>The categories in the terminal output are now links to the documentation if it is supported by the terminal.</p> </li> </ul>"},{"location":"changelog/#exec-1--fixed_9","title":"Fixed","text":"<ul> <li>Hide update section if the diff is empty because the change is reverted by the format-command.</li> </ul>"},{"location":"changelog/#exec-1--02010-2025-03-26","title":"0.20.10 \u2014 2025-03-26","text":""},{"location":"changelog/#exec-1--fixed_10","title":"Fixed","text":"<ul> <li>Use of the correct snapshot category (update/fix) when deleting dataclass arguments.</li> </ul>"},{"location":"changelog/#exec-1--0209-2025-03-23","title":"0.20.9 \u2014 2025-03-23","text":""},{"location":"changelog/#exec-1--fixed_11","title":"Fixed","text":"<ul> <li><code>--inline-snapshot=create</code> preserves test failures now.</li> </ul>"},{"location":"changelog/#exec-1--0208-2025-03-20","title":"0.20.8 \u2014 2025-03-20","text":""},{"location":"changelog/#exec-1--fixed_12","title":"Fixed","text":"<ul> <li>inline-snapshot now also works if you use <code>--no-summary</code> (which pycharm does if you run your tests from the IDE).</li> </ul>"},{"location":"changelog/#exec-1--0207-2025-03-14","title":"0.20.7 \u2014 2025-03-14","text":""},{"location":"changelog/#exec-1--changed_6","title":"Changed","text":"<ul> <li>Tests with failed snapshot comparisons now always result in a pytest <code>Error</code>, even if snapshots have been fixed or created.</li> </ul>"},{"location":"changelog/#exec-1--0206-2025-03-13","title":"0.20.6 \u2014 2025-03-13","text":""},{"location":"changelog/#exec-1--fixed_13","title":"Fixed","text":"<ul> <li>Do not skip snapshots in conditional marked xfail tests.   <pre><code>@pytest.mark.xfail(False, reason=\"...\")\ndef test_a():\n    assert 5 == snapshot(3)  # &lt;- this will be fixed\n\n\n@pytest.mark.xfail(True, reason=\"...\")\ndef test_b():\n    assert 5 == snapshot(3)  # &lt;- this not\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0205-2025-03-04","title":"0.20.5 \u2014 2025-03-04","text":""},{"location":"changelog/#exec-1--fixed_14","title":"Fixed","text":"<ul> <li>correct normalization of \"python3.9\" to \"python\" in tests</li> </ul>"},{"location":"changelog/#exec-1--0204-2025-03-03","title":"0.20.4 \u2014 2025-03-03","text":""},{"location":"changelog/#exec-1--fixed_15","title":"Fixed","text":"<ul> <li>Prevent a crash if a value cannot be copied and a UsageError is raised.</li> </ul>"},{"location":"changelog/#exec-1--0203-2025-02-28","title":"0.20.3 \u2014 2025-02-28","text":""},{"location":"changelog/#exec-1--fixed_16","title":"Fixed","text":"<ul> <li>Use the black API directly to format python code.   This solves issues with the upcoming click 8.2.0 (#202) and problems in multithreading (https://github.com/15r10nk/inline-snapshot/pull/193#issuecomment-2660393512).</li> </ul>"},{"location":"changelog/#exec-1--0202-2025-02-13","title":"0.20.2 \u2014 2025-02-13","text":""},{"location":"changelog/#exec-1--fixed_17","title":"Fixed","text":"<ul> <li> <p>snapshots inside tests which are marked as xfail are now ignored (#184)</p> </li> <li> <p>Fixed a crash caused by the following code:</p> </li> </ul> <pre><code>snapshot(tuple())\n# or\nsnapshot(dict())\n</code></pre> <p></p>"},{"location":"changelog/#exec-1--0201-2025-02-04","title":"0.20.1 \u2014 2025-02-04","text":""},{"location":"changelog/#exec-1--fixed_18","title":"Fixed","text":"<ul> <li>Fixed a windows bug with the readline module (#189)</li> </ul>"},{"location":"changelog/#exec-1--0200-2025-02-01","title":"0.20.0 \u2014 2025-02-01","text":""},{"location":"changelog/#exec-1--changed_7","title":"Changed","text":"<ul> <li> <p>pytest assert rewriting works now together with inline-snapshot if you use <code>cpython&gt;=3.11</code></p> </li> <li> <p><code>...</code> is now a special value to create snapshot values.    The value change in <code>assert [5,4] == snapshot([5,...])</code> is now a create (previously it was a fix)</p> </li> </ul>"},{"location":"changelog/#exec-1--fixed_19","title":"Fixed","text":"<ul> <li> <p>fixed some issues with dataclass arguments</p> </li> <li> <p>fixed an issue where --inline-snapshot=review discarded the user input and never formatted   the code if you used cpython 3.13.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0193-2025-01-15","title":"0.19.3 \u2014 2025-01-15","text":""},{"location":"changelog/#exec-1--fixed_20","title":"Fixed","text":"<ul> <li>raise no assertion for positional arguments inside constructor methods.</li> </ul>"},{"location":"changelog/#exec-1--0192-2025-01-15","title":"0.19.2 \u2014 2025-01-15","text":""},{"location":"changelog/#exec-1--fixed_21","title":"Fixed","text":"<ul> <li> <p>fixed a crash when you changed the snapshot to use a custom constructor method for dataclass/pydantic models.</p> <p>example: <pre><code>from inline_snapshot import snapshot\nfrom pydantic import BaseModel\n\n\nclass A(BaseModel):\n    a: int\n\n    @classmethod\n    def from_str(cls, s):\n        return cls(a=int(s))\n\n\ndef test_something():\n    assert A(a=2) == snapshot(A.from_str(\"1\"))\n</code></pre></p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0191-2025-01-12","title":"0.19.1 \u2014 2025-01-12","text":""},{"location":"changelog/#exec-1--added_2","title":"Added","text":"<ul> <li>added the optional <code>inline-snapshot[dirty-equals]</code> dependency to depend on the dirty-equals version which works in combination with inline-snapshot.</li> </ul>"},{"location":"changelog/#exec-1--fixed_22","title":"Fixed","text":"<ul> <li> <p>snapshots with pydantic models can now be compared multiple times</p> <pre><code>class A(BaseModel):\n    a: int\n\n\ndef test_something():\n    for _ in [1, 2]:\n        assert A(a=1) == snapshot(A(a=1))\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0190-2025-01-10","title":"0.19.0 \u2014 2025-01-10","text":""},{"location":"changelog/#exec-1--added_3","title":"Added","text":"<ul> <li>You can now specify which tool you want to use to format your code by setting a <code>format-command</code> in your configuration.</li> </ul>"},{"location":"changelog/#exec-1--changed_8","title":"Changed","text":"<ul> <li>BREAKING-CHANGE you have to install <code>inline-snapshot[black]</code> now if you want to format your code like in the previous versions. This option is not required if you use a <code>format-command</code>.</li> </ul>"},{"location":"changelog/#exec-1--fixed_23","title":"Fixed","text":"<ul> <li>Load default config values even if <code>[tool.inline-snapshot]</code> is missing.   This makes the documented default shortcuts <code>--review</code> and <code>--fix</code> work.</li> </ul>"},{"location":"changelog/#exec-1--0182-2025-01-02","title":"0.18.2 \u2014 2025-01-02","text":""},{"location":"changelog/#exec-1--changed_9","title":"Changed","text":"<ul> <li>added <code>[dependency-groups]</code> to pyproject.toml and use uv and pytest to run tests in CI.</li> </ul>"},{"location":"changelog/#exec-1--fixed_24","title":"Fixed","text":"<ul> <li>use '.model_fields' on pydantic model class and not instance. This fixes a deprecation warning in the upcoming pydantic v2.11 (#169)</li> </ul>"},{"location":"changelog/#exec-1--0181-2024-12-22","title":"0.18.1 \u2014 2024-12-22","text":""},{"location":"changelog/#exec-1--fixed_25","title":"Fixed","text":"<ul> <li>uv is now only used during test time if you run the inline-snapshot tests with <code>pytest --use-uv</code>   This solves a problem if you want to package inline-snapshot in distributions (#165)</li> </ul>"},{"location":"changelog/#exec-1--0180-2024-12-21","title":"0.18.0 \u2014 2024-12-21","text":""},{"location":"changelog/#exec-1--added_4","title":"Added","text":"<ul> <li>Support for a new <code>storage-dir</code> configuration option, to tell inline-snapshot where to store data files such as external snapshots.</li> </ul>"},{"location":"changelog/#exec-1--fixed_26","title":"Fixed","text":"<ul> <li> <p>pydantic v1 is supported again. pydantic v1 &amp; v2 create now the same snapshots. You can use <code>.dict()</code> to get the same snapshots like in inline-snapshot-0.15.0 for pydantic v1.</p> <pre><code>class M(BaseModel):\n    name: str\n\n\ndef test_pydantic():\n    m = M(name=\"Tom\")\n    assert m == snapshot(M(name=\"Tom\"))\n    assert m.dict() == snapshot({\"name\": \"Tom\"})\n</code></pre> </li> <li> <p>Find <code>pyproject.toml</code> file in parent directories, not just next to the Pytest configuration file.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0171-2024-12-17","title":"0.17.1 \u2014 2024-12-17","text":""},{"location":"changelog/#exec-1--fixed_27","title":"Fixed","text":"<ul> <li>Code generation for sets is now deterministic.   <pre><code>def test():\n    assert {1j, 2j, 1, 2, 3} == snapshot({1, 1j, 2, 2j, 3})\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0170-2024-12-14","title":"0.17.0 \u2014 2024-12-14","text":""},{"location":"changelog/#exec-1--added_5","title":"Added","text":"<ul> <li> <p>attrs can now contain unmanaged values</p> <pre><code>import datetime as dt\nimport uuid\nimport attrs\nfrom dirty_equals import IsDatetime\nfrom inline_snapshot import Is, snapshot\n\n\n@attrs.define\nclass Attrs:\n    ts: dt.datetime\n    id: uuid.UUID\n\n\ndef test():\n    id = uuid.uuid4()\n\n    assert Attrs(dt.datetime.now(), id) == snapshot(\n        Attrs(ts=IsDatetime(), id=Is(id))\n    )\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0160-2024-12-12","title":"0.16.0 \u2014 2024-12-12","text":""},{"location":"changelog/#exec-1--added_6","title":"Added","text":"<ul> <li><code>inline_snapshot.extra.warns</code> to captures warnings and compares them against expected warnings.     <pre><code>def test_warns():\n    with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n        warn(\"some problem\")\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--0151-2024-12-10","title":"0.15.1 \u2014 2024-12-10","text":""},{"location":"changelog/#exec-1--fixed_28","title":"Fixed","text":"<ul> <li>solved a bug caused by a variable inside a snapshot (#148)</li> </ul>"},{"location":"changelog/#exec-1--0150-2024-12-10","title":"0.15.0 \u2014 2024-12-10","text":""},{"location":"changelog/#exec-1--added_7","title":"Added","text":"<ul> <li> <p>snapshots inside snapshots are now supported.</p> <pre><code>assert get_schema() == snapshot(\n    [\n        {\n            \"name\": \"var_1\",\n            \"type\": snapshot(\"int\") if version &lt; 2 else snapshot(\"string\"),\n        }\n    ]\n)\n</code></pre> </li> <li> <p>runtime values can now be part of snapshots.</p> <pre><code>from inline_snapshot import snapshot, Is\n\ncurrent_version = \"1.5\"\nassert request() == snapshot(\n    {\"data\": \"page data\", \"version\": Is(current_version)}\n)\n</code></pre> </li> <li> <p>f-strings can now also be used within snapshots, but are currently not fixed by inline-snapshot.</p> </li> </ul>"},{"location":"changelog/#exec-1--changed_10","title":"Changed","text":"<ul> <li>dirty-equals expressions are now treated like runtime values or snapshots within snapshots and are not modified by inline-snapshot.</li> </ul>"},{"location":"changelog/#exec-1--fixed_29","title":"Fixed","text":"<ul> <li> <p>inline-snapshot checks now if the given command line flags (<code>--inline-snapshot=...</code>) are valid</p> </li> <li> <p><code>Example(...).run_pytest(raise=snapshot(...))</code> uses now the flags from the current run and not the flags from the Example.</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0142-2024-12-07","title":"0.14.2 \u2014 2024-12-07","text":""},{"location":"changelog/#exec-1--fixed_30","title":"Fixed","text":"<ul> <li>do not crash when handling raw f-strings (<code>rf\"\"</code>,<code>RF\"\"</code>,...) (#143)</li> </ul>"},{"location":"changelog/#exec-1--0141-2024-12-04","title":"0.14.1 \u2014 2024-12-04","text":""},{"location":"changelog/#exec-1--fixed_31","title":"Fixed","text":"<ul> <li> <p>Don't crash for snapshots like <code>snapshot(f\"\")</code> (#139)   It first appeared with pytest-8.3.4, but already existed before for cpython-3.11.   f-strings in snapshots are currently not official supported, but they should not lead to crashes.</p> </li> <li> <p>skip formatting if black returns an error (#138)</p> </li> </ul> <p></p>"},{"location":"changelog/#exec-1--0140-2024-11-10","title":"0.14.0 \u2014 2024-11-10","text":""},{"location":"changelog/#exec-1--removed","title":"Removed","text":"<ul> <li>removed the <code>\"Programming Language :: Python :: Implementation :: PyPy\"</code> classifier which was incorrect, because inline-snapshot can not fix snapshots on pypy.   inline-snapshot now enforces <code>--inline-snapshot=disable</code> when used with an implementation other than cpython, which allows it to be used in packages that want to support pypy.</li> </ul>"},{"location":"changelog/#exec-1--added_8","title":"Added","text":"<ul> <li>command line shortcuts can be defined to simplify your workflows. <code>--review</code> and <code>--fix</code> are defined by default. See the documentation for details.</li> </ul>"},{"location":"changelog/#exec-1--changed_11","title":"Changed","text":"<ul> <li><code>--inline-snapshot=create/fix/trim/update</code> will no longer show reports for other categories.   You can use <code>--inline-snapshot=create,report</code> if you want to use the old behaviour.</li> </ul>"},{"location":"changelog/#exec-1--0134-2024-11-07","title":"0.13.4 \u2014 2024-11-07","text":""},{"location":"changelog/#exec-1--changed_12","title":"Changed","text":"<ul> <li>use tomli instead of toml (#130)</li> </ul>"},{"location":"changelog/#exec-1--0133-2024-09-24","title":"0.13.3 \u2014 2024-09-24","text":""},{"location":"changelog/#exec-1--fixed_32","title":"Fixed","text":"<ul> <li>removed non-optional dirty-equals dependency (#118)</li> </ul>"},{"location":"changelog/#exec-1--0132-2024-09-24","title":"0.13.2 \u2014 2024-09-24","text":""},{"location":"changelog/#exec-1--changed_13","title":"Changed","text":"<ul> <li>star-expressions in list or dicts where never valid and cause a warning now.     <pre><code>    other=[2]\n    assert [5,2]==snapshot([5,*other])\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--fixed_33","title":"Fixed","text":"<ul> <li> <p>A snapshot which contains an dirty-equals expression can now be compared multiple times.</p> <pre><code>def test_something():\n    greeting = \"hello\"\n    for name in [\"alex\", \"bob\"]:\n        assert (name, greeting) == snapshot((IsString(), \"hello\"))\n</code></pre> </li> </ul>"},{"location":"changelog/#exec-1--v0131-2024-09-18","title":"v0.13.1 (2024-09-18)","text":""},{"location":"changelog/#exec-1--fix","title":"Fix","text":"<ul> <li>Use tomllib instead of PyPI toml on Python 3.11 and later</li> </ul>"},{"location":"changelog/#exec-1--v0130-2024-09-10","title":"v0.13.0 (2024-09-10)","text":""},{"location":"changelog/#exec-1--feat","title":"Feat","text":"<ul> <li>added extra.prints</li> <li>3.13 support</li> <li>strings with one line-break at the end become no multiline strings</li> </ul>"},{"location":"changelog/#exec-1--v0121-2024-08-05","title":"v0.12.1 (2024-08-05)","text":""},{"location":"changelog/#exec-1--fix_1","title":"Fix","text":"<ul> <li>add license to project metadata and some other fixes in pyproject.toml (#104)</li> </ul>"},{"location":"changelog/#exec-1--v0120-2024-07-22","title":"v0.12.0 (2024-07-22)","text":""},{"location":"changelog/#exec-1--feat_1","title":"Feat","text":"<ul> <li>implement extra.raises</li> <li>added inline_snapshot.testing.Example which can be used to test 3rd-party extensions</li> </ul>"},{"location":"changelog/#exec-1--v0110-2024-07-07","title":"v0.11.0 (2024-07-07)","text":""},{"location":"changelog/#exec-1--feat_2","title":"Feat","text":"<ul> <li>check if the result of copy.deepcopy() is equal to the copied value</li> <li>support for <code>enum.Enum</code>, <code>enum.Flag</code>, <code>type</code> and omitting of default values (#73)</li> </ul>"},{"location":"changelog/#exec-1--v0102-2024-05-28","title":"v0.10.2 (2024-05-28)","text":""},{"location":"changelog/#exec-1--fix_2","title":"Fix","text":"<ul> <li>changed how --inline-snapshot=disable works in combination with xdist (#90)</li> <li>fix typo, rename 'theme' with 'them'</li> </ul>"},{"location":"changelog/#exec-1--v0101-2024-05-26","title":"v0.10.1 (2024-05-26)","text":""},{"location":"changelog/#exec-1--fix_3","title":"Fix","text":"<ul> <li>trigger no update for trailing comma changes</li> </ul>"},{"location":"changelog/#exec-1--v0100-2024-05-21","title":"v0.10.0 (2024-05-21)","text":""},{"location":"changelog/#exec-1--breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>removed support for python 3.7</li> <li>removed <code>--inline-snapshot-disable</code> option and replaced it with <code>--inline-snapshot=disable</code></li> </ul>"},{"location":"changelog/#exec-1--feat_3","title":"Feat","text":"<ul> <li>new flags: disable, short-report, report and review</li> <li>added config option and environment variable to specify default flags</li> <li>show diff of changed snapshots in pytest report</li> <li>interactive review mode</li> </ul>"},{"location":"changelog/#exec-1--v090-2024-05-07","title":"v0.9.0 (2024-05-07)","text":""},{"location":"changelog/#exec-1--feat_4","title":"Feat","text":"<ul> <li>check if inline-snapshot is used in combination with xdist and notify the user that this is not possible</li> </ul>"},{"location":"changelog/#exec-1--fix_4","title":"Fix","text":"<ul> <li>change the quoting of strings does not trigger an update</li> </ul>"},{"location":"changelog/#exec-1--v082-2024-04-24","title":"v0.8.2 (2024-04-24)","text":""},{"location":"changelog/#exec-1--fix_5","title":"Fix","text":"<ul> <li>removed restriction that the snapshot functions has to be called snapshot (#72)</li> <li>report error in tear down for sub-snapshots with missing values (#70)</li> <li>element access in sub-snapshots does not create new values</li> </ul>"},{"location":"changelog/#exec-1--v081-2024-04-22","title":"v0.8.1 (2024-04-22)","text":""},{"location":"changelog/#exec-1--fix_6","title":"Fix","text":"<ul> <li>make typing less strict</li> </ul>"},{"location":"changelog/#exec-1--v080-2024-04-09","title":"v0.8.0 (2024-04-09)","text":""},{"location":"changelog/#exec-1--feat_5","title":"Feat","text":"<ul> <li>prevent dirty-equal values from triggering of updates</li> <li>fix lists by calculating the alignment of the changed values</li> <li>insert dict items</li> <li>delete dict items</li> <li>preserve not changed dict-values and list-elements</li> </ul>"},{"location":"changelog/#exec-1--fix_7","title":"Fix","text":"<ul> <li>update with UndecidedValue</li> <li>handle dicts with multiple insertions and deletions</li> <li>handle lists with multiple insertions and deletions</li> <li>fixed typing and coverage</li> </ul>"},{"location":"changelog/#exec-1--refactor","title":"Refactor","text":"<ul> <li>removed old needs* logic</li> <li>removed get_result</li> <li>use _get_changes api for DictValue</li> <li>use _get_changes api for CollectionValue</li> <li>use _get_changes api for MinMaxValue</li> <li>use _get_changes</li> <li>moved some functions</li> </ul>"},{"location":"changelog/#exec-1--v070-2024-02-27","title":"v0.7.0 (2024-02-27)","text":""},{"location":"changelog/#exec-1--feat_6","title":"Feat","text":"<ul> <li>removed old --update-snapshots option</li> </ul>"},{"location":"changelog/#exec-1--v061-2024-01-28","title":"v0.6.1 (2024-01-28)","text":""},{"location":"changelog/#exec-1--fix_8","title":"Fix","text":"<ul> <li>use utf-8 encoding to read and write source files</li> </ul>"},{"location":"changelog/#exec-1--v060-2023-12-10","title":"v0.6.0 (2023-12-10)","text":""},{"location":"changelog/#exec-1--feat_7","title":"Feat","text":"<ul> <li>store snapshot values in external files</li> </ul>"},{"location":"changelog/#exec-1--v052-2023-11-13","title":"v0.5.2 (2023-11-13)","text":""},{"location":"changelog/#exec-1--fix_9","title":"Fix","text":"<ul> <li>remove upper bound from dependency in pyproject.toml</li> </ul>"},{"location":"changelog/#exec-1--v051-2023-10-20","title":"v0.5.1 (2023-10-20)","text":""},{"location":"changelog/#exec-1--fix_10","title":"Fix","text":"<ul> <li>show better error messages</li> </ul>"},{"location":"changelog/#exec-1--v050-2023-10-15","title":"v0.5.0 (2023-10-15)","text":""},{"location":"changelog/#exec-1--feat_8","title":"Feat","text":"<ul> <li>support 3.12</li> </ul>"},{"location":"changelog/#exec-1--fix_11","title":"Fix","text":"<ul> <li>do not change empty snapshot if it is not used</li> </ul>"},{"location":"changelog/#exec-1--v040-2023-09-29","title":"v0.4.0 (2023-09-29)","text":""},{"location":"changelog/#exec-1--feat_9","title":"Feat","text":"<ul> <li>escaped linebreak at the start/end of multiline strings</li> </ul>"},{"location":"changelog/#exec-1--fix_12","title":"Fix","text":"<ul> <li>added py.typed</li> </ul>"},{"location":"changelog/#exec-1--v032-2023-07-31","title":"v0.3.2 (2023-07-31)","text":""},{"location":"changelog/#exec-1--fix_13","title":"Fix","text":"<ul> <li>handle update flag in sub-snapshots correctly</li> <li>fixed some edge cases where sub-snapshots had problems with some flags</li> <li>string literal concatenation should trigger no update</li> </ul>"},{"location":"changelog/#exec-1--v031-2023-07-14","title":"v0.3.1 (2023-07-14)","text":""},{"location":"changelog/#exec-1--fix_14","title":"Fix","text":"<ul> <li>added <code>__all__</code> to inline_snapshot</li> <li>flags fix/trim/create/update are changing the matching snapshots</li> </ul>"},{"location":"changelog/#exec-1--v030-2023-07-12","title":"v0.3.0 (2023-07-12)","text":""},{"location":"changelog/#exec-1--breaking-change_1","title":"BREAKING CHANGE","text":"<ul> <li>values have to be copyable with <code>copy.deepcopy</code></li> </ul>"},{"location":"changelog/#exec-1--fix_15","title":"Fix","text":"<ul> <li>snapshot the current value of mutable objects   <pre><code>l = [1]\nassert l == snapshot([1])  # old behaviour: snapshot([1, 2])\nl.append(2)\nassert l == snapshot([1, 2])\n</code></pre></li> </ul>"},{"location":"changelog/#exec-1--v021-2023-07-09","title":"v0.2.1 (2023-07-09)","text":""},{"location":"changelog/#exec-1--fix_16","title":"Fix","text":"<ul> <li>black configuration files are respected</li> </ul>"},{"location":"changelog/#exec-1--v020-2023-06-20","title":"v0.2.0 (2023-06-20)","text":""},{"location":"changelog/#exec-1--feat_10","title":"Feat","text":"<ul> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li> <p><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</p> </li> <li> <p>convert strings with newlines to triple quoted strings   <pre><code>assert \"a\\nb\\n\" == snapshot(\n    \"\"\"a\nb\n\"\"\"\n)\n</code></pre></p> </li> <li>preserve black formatting</li> </ul>"},{"location":"changelog/#exec-1--v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":""},{"location":"changelog/#exec-1--fix_17","title":"Fix","text":"<ul> <li>updated executing</li> </ul>"},{"location":"changelog/#exec-1--v011-2022-12-08","title":"v0.1.1 (2022-12-08)","text":""},{"location":"changelog/#exec-1--fix_18","title":"Fix","text":"<ul> <li>fixed typo in pytest plugin name</li> </ul>"},{"location":"changelog/#exec-1--v010-2022-07-25","title":"v0.1.0 (2022-07-25)","text":""},{"location":"changelog/#exec-1--feat_11","title":"Feat","text":"<ul> <li>first inline-snapshot version</li> </ul>"},{"location":"cmp_snapshot/","title":"x <= snapshot()","text":""},{"location":"cmp_snapshot/#general","title":"General","text":"<p>A snapshot can be compared against any value with <code>&lt;=</code> or <code>&gt;=</code>. This can be used to create a upper/lower bound for some result. The snapshot value can be trimmed to the lowest/largest valid value.</p> <p>Example:</p> original code--inline-snapshot=createoptimized code --inline-snapshot=trim <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot()\n    assert iterations &lt;= snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(3)\n</code></pre></p> <p>Warning</p> <p>This should not be used to check for any flaky values like the runtime of some code, because it will randomly break your tests.</p> <p>The same snapshot value can also be used in multiple assertions.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    value = snapshot()\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    value = snapshot(6)\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p>"},{"location":"cmp_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the new value and store it in the source code if it is contradicts the comparison.</li> <li><code>trim</code> record the new value and store it in the source code if it is more strict than the old one.</li> </ul>"},{"location":"code_generation/","title":"Code generation","text":"<p>You can use almost any python data type and also complex values like <code>datetime.date</code>, because <code>repr()</code> is used to convert the values to source code. The default <code>__repr__()</code> behaviour can be customized. It might be necessary to import the right modules to match the <code>repr()</code> output.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot(\n        {\n            \"name\": \"hello\",\n            \"one number\": 5,\n            \"numbers\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            \"sets\": {1, 2, 15},\n            \"datetime\": datetime.date(1, 2, 22),\n            \"complex stuff\": (3 + 5j),\n            \"bytes\": b\"byte abc\\n\\x16\",\n        }\n    )\n</code></pre></p> <p>The code is generated in the following way:</p> <ol> <li>The value is copied with <code>value = copy.deepcopy(value)</code> and it is checked if the copied value is equal to the original value.</li> <li>The code is generated with:<ul> <li><code>repr(value)</code> (which can be customized)</li> <li>or a special internal implementation for container types to support unmanaged snapshot values.   This can currently not be customized.</li> </ul> </li> <li> <p>Strings which contain newlines are converted to triple quoted strings.</p> <p>Note</p> <p>Missing newlines at start or end are escaped (since 0.4.0).</p> original code--inline-snapshot=update <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"first line\nsecond line\"\"\"\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"\\\nfirst line\nsecond line\\\n\"\"\"\n    )\n</code></pre></p> </li> <li> <p>The new code fragments are formatted with black if it is installed.</p> <p>Note</p> <p>Black is an optional dependency since inline-snapshot v0.19.0. You can install it with: <pre><code>pip install inline-snapshot[black]\n</code></pre></p> </li> <li> <p>The whole file is formatted</p> <ul> <li> <p>with black if it was formatted with black before.</p> <p>Note</p> <p>The black formatting of the whole file could not work for the following reasons:</p> <ol> <li>black is configured with cli arguments and not in a configuration file. Solution: configure black in a configuration file</li> <li>inline-snapshot uses a different black version. Solution: specify which black version inline-snapshot should use by adding black with a specific version to your dependencies.</li> <li>black is not installed. Black is an optional dependency since inline-snapshot v0.19.0</li> </ol> </li> <li> <p>or with the format-command if you defined one.</p> </li> </ul> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Default configuration:</p> <pre><code>[tool.inline-snapshot]\nhash-length=15\ndefault-flags=[\"report\"]\ndefault-flags-tui=[\"create\", \"review\"]\nformat-command=\"\"\nshow-updates=false\n\n[tool.inline-snapshot.shortcuts]\nreview=[\"review\"]\nfix=[\"create\",\"fix\"]\n</code></pre> <ul> <li>hash-length: specifies the length of the hash used by <code>external()</code> in the code representation.     This does not affect the hash length used to store the data.     The hash should be long enough to avoid hash collisions.</li> <li> <p>default-flags: defines which flags should be used if there are no flags specified with <code>--inline-snapshot=...</code>.     You can also use the environment variable <code>INLINE_SNAPSHOT_DEFAULT_FLAGS=...</code> to specify the flags and to override those in the configuration file.</p> </li> <li> <p>default-flags-tui: defines which flags should be used if you run pytest in an interactive terminal.     inline-snapshot creates all snapshots by default in this case and asks when there are values to change.     This feature requires cpython&gt;=3.11</p> </li> </ul> <p>Note</p> <p>The default flags are different if you use cpython&lt;3.11 due to some technical limitations: <pre><code>[tool.inline-snapshot]\ndefault-flags=[\"short-report\"]\ndefault-flags-tui=[\"short-report\"]\n</code></pre></p> <ul> <li> <p>shortcuts: allows you to define custom commands to simplify your workflows.     <code>--fix</code> and <code>--review</code> are defined by default, but this configuration can be changed to fit your needs.</p> </li> <li> <p>storage-dir: allows you to define the directory where inline-snapshot stores data files such as external snapshots.     By default, it will be <code>&lt;pytest_config_dir&gt;/.inline-snapshot</code>,     where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any.     External snapshots will be stored in the <code>external</code> subfolder of the storage directory.</p> </li> <li> <p>format-command: allows you to specify a custom command which is used to format the python code after code is changed.    <pre><code>[tool.inline-snapshot]\nformat-command=\"ruff format --stdin-filename {filename}\"\n</code></pre>    The placeholder <code>{filename}</code> can be used to specify the filename if it is needed to find the correct formatting options for this file.</p> <p>Important</p> <p>The command should not format the file on disk. The current file content (with the new code changes) is passed to stdin and the formatted content should be written to stdout.</p> <p>You can also use a <code>|</code> if you want to use multiple commands. <pre><code>[tool.inline-snapshot]\nformat-command=\"ruff check --fix-only --stdin-filename {filename} | ruff format --stdin-filename {filename}\"\n</code></pre></p> </li> <li> <p>show-updates: shows updates in reviews and reports.</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Please create an issue before writing a pull request so we can discuss what needs to be changed.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>The code can be tested with hatch</p> <ul> <li><code>hatch test</code> can be used to test all supported python versions and to check for coverage.</li> <li><code>hatch test -py 3.10 -- --sw</code> runs pytest for python 3.10 with the <code>--sw</code> argument.</li> </ul> <p>The preferred way to test inline-snapshot is by using <code>inline-snapshot.texting.Example</code>. You will see some other fixtures which are used inside the tests, but these are old ways to write the tests and I try to use the new <code>Example</code> class to write new tests.</p>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>This project has a hard coverage requirement of 100% (which is checked in CI). You can also check the coverage locally with <code>hatch test -acp</code>. The goal here is to find different edge cases which might have bugs.</p> <p>However, it is possible to exclude some code from the coverage.</p> <p>Code can be marked with <code>pragma: no cover</code>, if it can not be tested for some reason. This makes it easy to spot uncovered code in the source.</p> <p>Impossible conditions can be handled with <code>assert False</code>. <pre><code>if some_condition:\n    ...\nif some_other_condition:\n    ...\nelse:\n    assert False, \"unreachable because ...\"\n</code></pre> This serves also as an additional check during runtime.</p>"},{"location":"contributing/#commits","title":"Commits","text":"<p>Please use pre-commit for your commits.</p>"},{"location":"customize_repr/","title":"@customize_repr","text":"<p><code>repr()</code> can be used to convert a python object into a source code representation of the object, but this does not work for every type. Here are some examples:</p> <pre><code>&gt;&gt;&gt; repr(int)\n\"&lt;class 'int'&gt;\"\n\n&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; E = Enum(\"E\", [\"a\", \"b\"])\n&gt;&gt;&gt; repr(E.a)\n'&lt;E.a: 1&gt;'\n</code></pre> <p><code>customize_repr</code> can be used to overwrite the default <code>repr()</code> behaviour.</p> <p>The implementation for <code>Enum</code> looks like this:</p> <pre><code>@customize_repr\ndef _(value: Enum):\n    return f\"{type(value).__qualname__}.{value.name}\"\n</code></pre> <p>This implementation is then used by inline-snapshot if <code>repr()</code> is called during the code generation, but not in normal code.</p> <pre><code>from inline_snapshot import snapshot\nfrom enum import Enum\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # normal repr\n    assert repr(E.a) == \"&lt;E.a: 1&gt;\"\n\n    # the special implementation to convert the Enum into a code\n    assert E.a == snapshot(E.a)\n</code></pre>"},{"location":"customize_repr/#built-in-data-types","title":"built-in data types","text":"<p>inline-snapshot comes with a special implementation for the following types:</p> <ul> <li><code>builtins.frozenset</code></li> <li><code>builtins.function</code></li> <li><code>builtins.set</code></li> <li><code>builtins.type</code></li> <li><code>enum.Enum</code></li> <li><code>enum.Flag</code></li> </ul> <p>Please open an issue if you found a built-in type which is not supported by inline-snapshot.</p> <p>Note</p> <p>Container types like <code>dict</code>, <code>list</code>, <code>tuple</code> or <code>dataclass</code> are handled in a different way, because inline-snapshot also needs to inspect these types to implement unmanaged snapshot values.</p>"},{"location":"customize_repr/#customize-recursive-repr","title":"customize recursive repr","text":"<p>You can also use <code>repr()</code> inside <code>__repr__()</code>, if you want to make your own type compatible with inline-snapshot.</p> <pre><code>from inline_snapshot import snapshot\nfrom enum import Enum\n\n\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def __repr__(self):\n        # this would not work\n        # return f\"Pair({self.a!r}, {self.b!r})\"\n\n        # you have to use repr()\n        return f\"Pair({repr(self.a)}, {repr(self.b)})\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Pair):\n            return NotImplemented\n        return self.a == other.a and self.b == other.b\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # the special repr implementation is used recursive here\n    # to convert every Enum to the correct representation\n    assert Pair(E.a, [E.b]) == snapshot(Pair(E.a, [E.b]))\n</code></pre> <p>Note</p> <p>using <code>f\"{obj!r}\"</code> or <code>PyObject_Repr()</code> will not work, because inline-snapshot replaces <code>builtins.repr</code> during the code generation. The only way to use the custom repr implementation is to use the <code>repr()</code> function.</p> <p>Note</p> <p>This implementation allows inline-snapshot to use the custom <code>repr()</code> recursively, but it does not allow you to use unmanaged snapshot values like <code>Pair(Is(some_var),5)</code></p> <p>you can also customize the representation of data types in other libraries:</p> <pre><code>from inline_snapshot import customize_repr\nfrom other_lib import SomeType\n\n\n@customize_repr\ndef _(value: SomeType):\n    return f\"SomeType(x={repr(value.x)})\"\n</code></pre>"},{"location":"eq_snapshot/","title":"x == snapshot()","text":""},{"location":"eq_snapshot/#general","title":"General","text":"<p>A snapshot can be compared with any value using <code>==</code>. The value can be recorded with <code>--inline-snapshot=create</code> if the snapshot is empty. The value can later be changed with <code>--inline-snapshot=fix</code> if the value the snapshot is compared with has changed.</p> <p>Example:</p> original code--inline-snapshot=createvalue changed--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 4 == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 4 == snapshot(6)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 40 == snapshot(4)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 40 == snapshot(42)\n</code></pre></p>"},{"location":"eq_snapshot/#unmanaged-snapshot-values","title":"unmanaged snapshot values","text":"<p>inline-snapshots manages everything inside <code>snapshot(...)</code>, which means that the developer should not change these parts, but there are cases where it is useful to give the developer the control over the snapshot content back.</p> <p>Therefor some types will be ignored by inline-snapshot and will not be updated or fixed, even if they cause tests to fail.</p> <p>These types are:</p> <ul> <li>dirty-equals expressions,</li> <li>dynamic code inside <code>Is(...)</code>,</li> <li>snapshots inside snapshots and</li> <li>f-strings.</li> </ul> <p>inline-snapshot is able to handle these types within the following containers:</p> <ul> <li>list</li> <li>tuple</li> <li>dict</li> <li>namedtuple</li> <li>dataclass</li> <li>attrs</li> </ul> <p>Other types are converted with a customizable <code>repr()</code> into code. It is not possible to use unmanaged snapshot values within these objects.</p>"},{"location":"eq_snapshot/#dirty-equals","title":"dirty-equals","text":"<p>dirty-equals is a library of special objects for comparing types declaratively in unit tests. inline-snapshot supports dirty-equals expressions inside snapshots, making it easier to write snapshots that contain data that varies between test runs, such as timestamps, database IDs, or other runtime values.</p> <p>To use dirty-equals with inline-snapshot, pull in a compatible version with the <code>dirty-equals</code> extra dependency. For example, with Pip:</p> <pre><code>pip install inline-snapshot[dirty-equals]\n</code></pre> <p>Then you can start using dirty-equals expressions inside snapshots.</p> <p>For example, say you have a function that returns a dictionary that contains a variable <code>datetime</code>. You could initialize a test like this:</p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot()\n</code></pre> <p>If you use <code>--inline-snapshot=create</code>, inline-snapshot will record the current <code>datetime</code> in the snapshot:</p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\"date\": datetime.datetime(2024, 3, 14, 0, 0), \"payload\": \"some data\"}\n    )\n</code></pre> <p>To avoid the test failing in future runs, replace the <code>datetime</code> with dirty-equals' <code>IsDatetime()</code>:</p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre> <p>Say a different part of the return data changes, such as the <code>payload</code> value:</p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre> <p>Re-running the test with <code>--inline-snapshot=fix</code> will update the snapshot to match the new value of <code>payload</code>, while keeping the <code>date</code> as a dirty-equals expression:</p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"data changed for some good reason\",\n        }\n    )\n</code></pre>"},{"location":"eq_snapshot/#snapshot-inside-dirty-equals-expressions","title":"<code>snapshot()</code> inside dirty-equals expressions","text":"<p><code>snapshot()</code> can also be used inside dirty-equals containers, such as with <code>IsJson()</code>:</p> <pre><code>from dirty_equals import IsJson\nfrom inline_snapshot import snapshot\n\n\ndef test_foo():\n    assert {\"json_data\": '{\"value\": 1}'} == snapshot(\n        {\"json_data\": IsJson(snapshot())}\n    )\n</code></pre> <p>Running this test with <code>--inline-snapshot=create</code> will record the snapshot value inside the <code>IsJson()</code> call:</p> <pre><code>from dirty_equals import IsJson\nfrom inline_snapshot import snapshot\n\n\ndef test_foo():\n    assert {\"json_data\": '{\"value\": 1}'} == snapshot(\n        {\"json_data\": IsJson(snapshot({\"value\": 1}))}\n    )\n</code></pre> <p>The general rule is that functions to which you pass a snapshot can only use <code>==</code> (or other snapshot operations) on the value.</p> <p>Important</p> <p>You cannot use a snapshot for every dirty-equals argument, but only for those that also support dirty equals values.</p>"},{"location":"eq_snapshot/#is","title":"Is(...)","text":"<p><code>Is()</code> can be used to put runtime values inside snapshots. It tells inline-snapshot that the developer wants control over some part of the snapshot.</p> <pre><code>from inline_snapshot import snapshot, Is\n\ncurrent_version = \"1.5\"\n\n\ndef request():\n    return {\"data\": \"page data\", \"version\": current_version}\n\n\ndef test_function():\n    assert request() == snapshot(\n        {\"data\": \"page data\", \"version\": Is(current_version)}\n    )\n</code></pre> <p>The snapshot does not need to be fixed when <code>current_version</code> changes in the future, but <code>\"page data\"</code> will still be fixed if it changes.</p> <p><code>Is()</code> can also be used when the snapshot is evaluated multiple times, which is useful in loops or parametrized tests.</p> original code--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot, Is\n\n\ndef test_function():\n    for c in \"abc\":\n        assert [c, \"correct\"] == snapshot([Is(c), \"wrong\"])\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, Is\n\n\ndef test_function():\n    for c in \"abc\":\n        assert [c, \"correct\"] == snapshot([Is(c), \"correct\"])\n</code></pre></p>"},{"location":"eq_snapshot/#inner-snapshots","title":"inner snapshots","text":"<p>Snapshots can be used inside other snapshots in different use cases.</p>"},{"location":"eq_snapshot/#conditional-snapshots","title":"conditional snapshots","text":"<p>It is also possible to use snapshots inside snapshots.</p> <p>This is useful to describe version specific parts of snapshots by replacing the specific part with <code>snapshot() if some_condition else snapshot()</code>. The test has to be executed in each specific condition to fill the snapshots.</p> <p>The following example shows how this can be used to run a tests with two different library versions:</p> my_lib.py v1my_lib.py v2 <p> <pre><code>version = 1\n\n\ndef get_schema():\n    return [{\"name\": \"var_1\", \"type\": \"int\"}]\n</code></pre></p> <p> <pre><code>version = 2\n\n\ndef get_schema():\n    return [{\"name\": \"var_1\", \"type\": \"string\"}]\n</code></pre></p> <pre><code>from inline_snapshot import snapshot\nfrom my_lib import version, get_schema\n\n\ndef test_function():\n    assert get_schema() == snapshot(\n        [\n            {\n                \"name\": \"var_1\",\n                \"type\": snapshot(\"int\") if version &lt; 2 else snapshot(\"string\"),\n            }\n        ]\n    )\n</code></pre> <p>The advantage of this approach is that the test uses always the correct values for each library version.</p> <p>You can also extract the version logic into its own function.</p> <pre><code>from inline_snapshot import snapshot, Snapshot\nfrom my_lib import version, get_schema\n\n\ndef version_snapshot(v1: Snapshot, v2: Snapshot):\n    return v1 if version &lt; 2 else v2\n\n\ndef test_function():\n    assert get_schema() == snapshot(\n        [\n            {\n                \"name\": \"var_1\",\n                \"type\": version_snapshot(\n                    v1=snapshot(\"int\"), v2=snapshot(\"string\")\n                ),\n            }\n        ]\n    )\n</code></pre>"},{"location":"eq_snapshot/#common-snapshot-parts","title":"common snapshot parts","text":"<p>Another use case is the extraction of common snapshot parts into an extra snapshot:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef some_data(name):\n    return {\"header\": \"really long header\\n\" * 5, \"your name\": name}\n\n\ndef test_function():\n\n    header = snapshot(\n        \"\"\"\\\nreally long header\nreally long header\nreally long header\nreally long header\nreally long header\n\"\"\"\n    )\n\n    assert some_data(\"Tom\") == snapshot(\n        {\n            \"header\": header,\n            \"your name\": \"Tom\",\n        }\n    )\n\n    assert some_data(\"Bob\") == snapshot(\n        {\n            \"header\": header,\n            \"your name\": \"Bob\",\n        }\n    )\n</code></pre> <p>This simplifies test data and allows inline-snapshot to update your values if required. It makes also sure that the header is the same in both cases.</p>"},{"location":"eq_snapshot/#f-strings","title":"f-strings","text":"<p>f-strings are not generated by inline-snapshot, but they can be used in snapshots if you want to replace some dynamic part of a string value.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef get_error():\n    # example code which generates an error message\n    return __file__ + \": error at line 5\"\n\n\ndef test_get_error():\n    assert get_error() == snapshot(f\"{__file__}: error at line 5\")\n</code></pre> <p>It is not required to wrap the changed value in <code>Is(f\"...\")</code>, because inline-snapshot knows that f-strings are only generated by the developer.</p> <p>Limitation</p> <p>inline-snapshot is currently not able to fix the string constants within f-strings.</p> <p><code>f\"...{var}...\"</code> works currently like <code>Is(f\"...{var}...\")</code> and issues a warning if the value changes, giving you the opportunity to fix your f-string.</p> <p><code>f\"...{var}...\"</code> will in the future work like <code>f\"...{Is(var)}\"</code>. inline-snapshot will then be able to fix the string parts within the f-string.</p>"},{"location":"eq_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the value parts and store them in the source code if it is different from the current one.</li> <li><code>update</code> update parts of the value if their representation has changed.   Parts which are replaced with dirty-equals expressions are not updated.</li> </ul>"},{"location":"extra/","title":"first-party (extra)","text":""},{"location":"extra/#inline_snapshot.extra","title":"<code>inline_snapshot.extra</code>","text":"<p>The following functions are build on top of inline-snapshot and could also be implemented in an extra library.</p> <p>They are part of inline-snapshot because they are general useful and do not depend on other libraries.</p>"},{"location":"extra/#inline_snapshot.extra.prints","title":"<code>prints(*, stdout='', stderr='')</code>","text":"<p>Uses <code>contextlib.redirect_stderr/stdout</code> to capture the output and compare it with the snapshots. <code>dirty_equals.IsStr</code> can be used to ignore the output if needed.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>Snapshot[str]</code> <p>snapshot which is compared to the recorded output</p> <code>''</code> <code>stderr</code> <code>Snapshot[str]</code> <p>snapshot which is compared to the recorded error output</p> <code>''</code> original--inline-snapshot=createignore stdout <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nimport sys\n\n\ndef test_prints():\n    with prints(stdout=snapshot(), stderr=snapshot()):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nimport sys\n\n\ndef test_prints():\n    with prints(\n        stdout=snapshot(\"hello world\\n\"), stderr=snapshot(\"some error\\n\")\n    ):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nfrom dirty_equals import IsStr\nimport sys\n\n\ndef test_prints():\n    with prints(\n        stdout=IsStr(),\n        stderr=snapshot(\"some error\\n\"),\n    ):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef prints(*, stdout: Snapshot[str] = \"\", stderr: Snapshot[str] = \"\"):\n    \"\"\"Uses `contextlib.redirect_stderr/stdout` to capture the output and\n    compare it with the snapshots. `dirty_equals.IsStr` can be used to ignore\n    the output if needed.\n\n    Parameters:\n        stdout: snapshot which is compared to the recorded output\n        stderr: snapshot which is compared to the recorded error output\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        import sys\n\n\n        def test_prints():\n            with prints(stdout=snapshot(), stderr=snapshot()):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python hl_lines=\"7 8 9\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        import sys\n\n\n        def test_prints():\n            with prints(\n                stdout=snapshot(\"hello world\\\\n\"), stderr=snapshot(\"some error\\\\n\")\n            ):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n\n    === \"ignore stdout\"\n\n        &lt;!-- inline-snapshot: outcome-passed=1 --&gt;\n        ``` python hl_lines=\"3 9 10\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        from dirty_equals import IsStr\n        import sys\n\n\n        def test_prints():\n            with prints(\n                stdout=IsStr(),\n                stderr=snapshot(\"some error\\\\n\"),\n            ):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n    \"\"\"\n\n    with redirect_stdout(io.StringIO()) as stdout_io:\n        with redirect_stderr(io.StringIO()) as stderr_io:\n            yield\n\n    assert stderr_io.getvalue() == stderr\n    assert stdout_io.getvalue() == stdout\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.raises","title":"<code>raises(exception)</code>","text":"<p>Check that an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Snapshot[str]</code> <p>snapshot which is compared with <code>f\"{type}: {message}\"</code> if an exception occurred or <code>\"&lt;no exception&gt;\"</code> if no exception was raised.</p> required original--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import raises\n\n\ndef test_raises():\n    with raises(snapshot()):\n        1 / 0\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import raises\n\n\ndef test_raises():\n    with raises(snapshot(\"ZeroDivisionError: division by zero\")):\n        1 / 0\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef raises(exception: Snapshot[str]):\n    \"\"\"Check that an exception is raised.\n\n    Parameters:\n        exception: snapshot which is compared with `#!python f\"{type}: {message}\"` if an exception occurred or `#!python \"&lt;no exception&gt;\"` if no exception was raised.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import raises\n\n\n        def test_raises():\n            with raises(snapshot()):\n                1 / 0\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python hl_lines=\"6\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import raises\n\n\n        def test_raises():\n            with raises(snapshot(\"ZeroDivisionError: division by zero\")):\n                1 / 0\n        ```\n    \"\"\"\n\n    try:\n        yield\n    except Exception as ex:\n        msg = str(ex)\n        if \"\\n\" in msg:\n            assert f\"{type(ex).__name__}:\\n{ex}\" == exception\n        else:\n            assert f\"{type(ex).__name__}: {ex}\" == exception\n    else:\n        assert \"&lt;no exception&gt;\" == exception\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.warns","title":"<code>warns(expected_warnings, /, include_line=False, include_file=False)</code>","text":"<p>Captures warnings with <code>warnings.catch_warnings</code> and compares them against expected warnings.</p> <p>Parameters:</p> Name Type Description Default <code>expected_warnings</code> <code>Snapshot[List[Warning]]</code> <p>Snapshot containing a list of expected warnings.</p> required <code>include_line</code> <code>bool</code> <p>If <code>True</code>, each expected warning is a tuple <code>(linenumber, message)</code>.</p> <code>False</code> <code>include_file</code> <code>bool</code> <p>If <code>True</code>, each expected warning is a tuple <code>(filename, message)</code>.</p> <code>False</code> <p>The format of the expected warning:</p> <ul> <li><code>(filename, linenumber, message)</code> if both <code>include_line</code> and <code>include_file</code> are <code>True</code>.</li> <li><code>(linenumber, message)</code> if only <code>include_line</code> is <code>True</code>.</li> <li><code>(filename, message)</code> if only <code>include_file</code> is <code>True</code>.</li> <li>A string <code>message</code> if both are <code>False</code>.</li> </ul> original--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import warns\nfrom warnings import warn\n\n\ndef test_warns():\n    with warns(snapshot(), include_line=True):\n        warn(\"some problem\")\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import warns\nfrom warnings import warn\n\n\ndef test_warns():\n    with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n        warn(\"some problem\")\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef warns(\n    expected_warnings: Snapshot[List[Warning]],\n    /,\n    include_line: bool = False,\n    include_file: bool = False,\n):\n    \"\"\"\n    Captures warnings with `warnings.catch_warnings` and compares them against expected warnings.\n\n    Parameters:\n        expected_warnings: Snapshot containing a list of expected warnings.\n        include_line: If `True`, each expected warning is a tuple `(linenumber, message)`.\n        include_file: If `True`, each expected warning is a tuple `(filename, message)`.\n\n    The format of the expected warning:\n\n    - `(filename, linenumber, message)` if both `include_line` and `include_file` are `True`.\n    - `(linenumber, message)` if only `include_line` is `True`.\n    - `(filename, message)` if only `include_file` is `True`.\n    - A string `message` if both are `False`.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import warns\n        from warnings import warn\n\n\n        def test_warns():\n            with warns(snapshot(), include_line=True):\n                warn(\"some problem\")\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create fix outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python hl_lines=\"7\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import warns\n        from warnings import warn\n\n\n        def test_warns():\n            with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n                warn(\"some problem\")\n        ```\n    \"\"\"\n    with warnings.catch_warnings(record=True) as result:\n        warnings.simplefilter(\"always\")\n        yield\n\n    def make_warning(w):\n        message = f\"{w.category.__name__}: {w.message}\"\n        if not include_line and not include_file:\n            return message\n        message = (message,)\n\n        if include_line:\n            message = (w.lineno, *message)\n        if include_file:\n            message = (w.filename, *message)\n\n        return message\n\n    assert [make_warning(w) for w in result] == expected_warnings\n</code></pre>"},{"location":"fix_assert/","title":"assert x == ...","text":""},{"location":"fix_assert/#general","title":"General","text":"<p>Info</p> <p>The following feature is available for insider  only and requires cpython&gt;=3.11.</p> <p>The <code>snapshot()</code> function provides a lot of flexibility, but there is a easier way for simple assertion. You can write a normal assertion and use <code>...</code> where inline-snapshot should create the new value, like in the following example.</p> original code--inline-snapshot=create <p> <pre><code>def test_assert():\n    assert 1 + 1 == ...\n</code></pre></p> <p> <pre><code>def test_assert():\n    assert 1 + 1 == 2\n</code></pre></p> <p>inline-snapshot will detect these failures and will replace <code>...</code> with the correct value.</p> <p>It is also possible to fix existing values.</p> original code--inline-snapshot=fix-assert <p> <pre><code>def test_assert():\n    assert 1 + 1 == 5\n</code></pre></p> <p> <pre><code>def test_assert():\n    assert 1 + 1 == 2\n</code></pre></p> <p>This is especially useful to fix values in existing codebases where <code>snapshot()</code> is currently not used.</p> <p>The logic to create/fix the assertions is the same like for snapshots, but there are rules which specify which side of the <code>==</code> should be fixed. This allows assertions like <code>assert 5 == 1 + 2</code> to be fixed and prevents inline-snapshot to try to fix code like <code>assert f1() == f2()</code>.</p> <p>The rule is that exactly one side of the equation must be a value expression, which is defined as follows:</p> <ul> <li>a constant</li> <li>a list/tuple/dict/set of value expressions</li> <li>a constructor call such as <code>T(...arguments)</code><ul> <li>where the arguments are value expressions</li> <li>and <code>T</code> is a type (which excludes function calls)</li> </ul> </li> </ul>"},{"location":"fix_assert/#limitations","title":"Limitations","text":"<ul> <li><code>cpython&gt;=3.11</code> is required to create/fix assertions.</li> <li>It can only fix the first failing assertion in a test.   You need to run your tests a multiple times to fix the remaining ones.</li> <li>It is not possible to fix values where inline-snapshot did not know which side of the equal sign should be fixed.   You can use <code>snapshot()</code> in this case to make this clear.</li> </ul>"},{"location":"fix_assert/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value where <code>...</code> is used.</li> <li> <p><code>fix-assert</code> fix the value if the assertion fails.</p> <p>Note</p> <p>fix-assert is used to distinguisch between snapshot fixes and assertion fixes without snapshot(). This should help in deciding whether some fixes should be approved. Fixing normal assertions is inherently more complicated because these assertions are written by a human without the intention of being automatically fixed. Separating the two helps in approving the changes.</p> </li> </ul>"},{"location":"getitem_snapshot/","title":"snapshot()[key]","text":""},{"location":"getitem_snapshot/#general","title":"General","text":"<p>It is possible to generate sub-snapshots during runtime. This sub-snapshots can be used like a normal snapshot.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot()\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot({\"a\": 4, \"b\": 5})\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p><code>s[key]</code> can be used with every normal snapshot operation including <code>s[key1][key2]</code>.</p>"},{"location":"getitem_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined or create a new sub-snapshot if one is missing.</li> <li><code>trim</code> remove sub-snapshots if they are not needed any more.</li> </ul> <p>The flags <code>fix</code> and <code>update</code> are applied recursive to all sub-snapshots.</p>"},{"location":"in_snapshot/","title":"x in snapshot()","text":""},{"location":"in_snapshot/#general","title":"General","text":"<p>It is possible to check if an value is in a snapshot. The value of the generated snapshot will be a list of all values which are tested.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot()\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot([5, 8, \"a\", \"b\"])\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p>"},{"location":"in_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> adds a value to the list if it is missing.</li> <li><code>trim</code> removes a value from the list if it is not necessary.</li> </ul>"},{"location":"insiders/","title":"Insiders","text":"<p>Hi, I'm Frank Hoffmann I created and maintain inline-snapshot and several other tools. Working on open-source projects is really exciting but requires also a lot of time. Being able to finance my work allows me to put more time into my projects.</p> <p>Many open-source projects follow a sponsorware strategy where they build new features for insiders first and release them when they have reached a specific funding goal. This is not an option for most of the inline-snapshot features, because this would force everyone who wants to run the tests of a project to become a sponsor when the maintainer want to use insider-only features of inline-snapshot which require some new API.</p> <p>But there are some features which require no new API and provide you a lot of value. Fixing raw assertions like the following is one of them:</p> original code--inline-snapshot=fix-assert <p> <pre><code>def test_assert():\n    assert 1 + 1 == 5\n</code></pre></p> <p> <pre><code>def test_assert():\n    assert 1 + 1 == 2\n</code></pre></p> <p>And this is what I want to offer for my sponsors, the ability to create and fix normal assertions.</p> <p>But I also want to make use of funding-goals, where I want to reduce the minimum amount, starting from 10$ a month. The last sponsoring goal will make fixing of raw assertions available for everyone.</p> <p>I follow some goals with this plan:</p> <ol> <li>I would like to convince many people/companies to sponsor open source projects.</li> <li>Lowering the minimum amount allows you to support other projects as well.</li> <li>The ultimate goal is to have the time and money to work on my projects without having to offer sponsor-only features. I don't know if that will work out, but I think it's worth a try.</li> </ol> <p>I don't currently have a detailed plan for when I will reduce the funding amount for the first time or which functions I will make available to everyone, because I don't know how things will develop. The future will be exciting.</p>"},{"location":"insiders/#getting-started","title":"Getting started","text":"<p>The inline-snapshot insider version is API-compatible with the normal inline-snapshot version, but allows to fix assertions. Note that in order to access the Insiders repository, you need to become an eligible sponsor of @15r10nk on GitHub with 10$ per month or more. You will then be invited to join the insider team and gain access to the repositories that are only accessible to insiders.</p>"},{"location":"insiders/#installation","title":"Installation","text":"<p>You can install the insiders version with pip from the git repository:</p> <pre><code>pip install git+ssh://git@github.com/15r10nk-insiders/inline-snapshot.git\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#only-cpython-is-supported","title":"Only CPython is supported","text":"<p>Currently, inline-snapshot only works with CPython. On other Python implementations, such as PyPy, inline-snapshot acts as if <code>--inline-snapshot=disable</code> is set, allowing tests to pass but not providing any way to update snapshots.</p>"},{"location":"limitations/#pytest-xdist-is-not-supported","title":"pytest-xdist is not supported","text":"<p>pytest-xdist splits test runs across multiple processes. This prevents inline-snapshot from being able to update snapshots across multiple processes, so if you have pytest-xdist installed and active, inline-snapshot will act as if <code>--inline-snapshot=disable</code> is set.</p> <p>If you have pytest-xdist installed and active by default in your pytest settings, you can disable it for a single test run with its <code>-n0</code> option. Then inline-snapshot will act as usual, or you can pass alternative flags with <code>--inline-snapshot</code>:</p> <pre><code>pytest -n0 --inline-snapshot=create,report\n</code></pre>"},{"location":"limitations/#on-cpython-311-pytest-assert-rewriting-can-be-disabled","title":"On CPython &lt; 3.11, pytest assert rewriting can be disabled","text":"<p>On CPython versions before 3.11, inline-snapshot must disable pytest assert rewriting if you use any of these flags: <code>report</code>, <code>review</code>, <code>create</code>, <code>fix</code>, <code>trim</code>, or <code>update</code>.</p>"},{"location":"outsource/","title":"outsource(data)","text":""},{"location":"outsource/#general","title":"General","text":"<p>Info</p> <p>This feature is currently under development. See this issue for more information.</p> <p>Storing snapshots in the source code is the main feature of inline snapshots. This has the advantage that you can easily see changes in code reviews. But it also has some problems:</p> <ul> <li>It is problematic to snapshot a lot of data, because it takes up a lot of space in your tests.</li> <li>Binary data or images are not readable in your tests.</li> </ul> <p>The <code>outsource()</code> function solves this problem and integrates itself nicely with the inline snapshot. It stores the data in a special <code>external()</code> object that can be compared in snapshots. The object is represented by the hash of the data. The actual data is stored in a separate file in your project.</p> <p>This allows the test to be renamed and moved around in your code without losing the connection to the stored data.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot, outsource\n\n\ndef test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, outsource\n\nfrom inline_snapshot import external\n\n\ndef test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot(\n        external(\"f5a956460453*.txt\")\n    )\n</code></pre></p> <p>The <code>external</code> object can be used inside other data structures.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot, outsource\n\n\ndef test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, outsource\n\nfrom inline_snapshot import external\n\n\ndef test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot(\n        [\n            external(\"362ad8374ed6*.txt\"),\n            external(\"5755afea3f8d*.txt\"),\n            external(\"f5a956460453*.txt\"),\n        ]\n    )\n</code></pre></p>"},{"location":"outsource/#api","title":"API","text":""},{"location":"outsource/#inline_snapshot.outsource","title":"<code>inline_snapshot.outsource(data, *, suffix=None)</code>","text":"<p>Outsource some data into an external file.</p> <pre><code>&gt;&gt;&gt; png_data = b\"some_bytes\"  # should be the replaced with your actual data\n&gt;&gt;&gt; outsource(png_data, suffix=\".png\")\nexternal(\"212974ed1835*.png\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes]</code> <p>data which should be outsourced. strings are encoded with <code>\"utf-8\"</code>.</p> required <code>suffix</code> <code>Optional[str]</code> <p>overwrite file suffix. The default is <code>\".bin\"</code> if data is an instance of <code>bytes</code> and <code>\".txt\"</code> for <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>external</code> <p>The external data.</p> Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def outsource(data: Union[str, bytes], *, suffix: Optional[str] = None) -&gt; external:\n    \"\"\"Outsource some data into an external file.\n\n    ``` pycon\n    &gt;&gt;&gt; png_data = b\"some_bytes\"  # should be the replaced with your actual data\n    &gt;&gt;&gt; outsource(png_data, suffix=\".png\")\n    external(\"212974ed1835*.png\")\n\n    ```\n\n    Parameters:\n        data: data which should be outsourced. strings are encoded with `\"utf-8\"`.\n\n        suffix: overwrite file suffix. The default is `\".bin\"` if data is an instance of `#!python bytes` and `\".txt\"` for `#!python str`.\n\n    Returns:\n        The external data.\n    \"\"\"\n    if isinstance(data, str):\n        data = data.encode(\"utf-8\")\n        if suffix is None:\n            suffix = \".txt\"\n\n    elif isinstance(data, bytes):\n        if suffix is None:\n            suffix = \".bin\"\n    else:\n        raise TypeError(\"data has to be of type bytes | str\")\n\n    if not suffix or suffix[0] != \".\":\n        raise ValueError(\"suffix has to start with a '.' like '.png'\")\n\n    m = hashlib.sha256()\n    m.update(data)\n    hash = m.hexdigest()\n\n    storage = state().storage\n\n    assert storage is not None\n\n    name = hash + suffix\n\n    if not storage.lookup_all(name):\n        path = hash + \"-new\" + suffix\n        storage.save(path, data)\n\n    return external(name)\n</code></pre>"},{"location":"outsource/#inline_snapshot.external","title":"<code>inline_snapshot.external</code>","text":"Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>class external:\n    def __init__(self, name: str):\n        \"\"\"External objects are used as a representation for outsourced data.\n        You should not create them directly.\n\n        The external data is by default stored inside `&lt;pytest_config_dir&gt;/.inline-snapshot/external`,\n        where `&lt;pytest_config_dir&gt;` is replaced by the directory containing the Pytest configuration file, if any.\n        To store data in a different location, set the `storage-dir` option in pyproject.toml.\n        Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.\n\n        Parameters:\n            name: the name of the external stored object.\n        \"\"\"\n\n        m = re.fullmatch(r\"([0-9a-fA-F]*)\\*?(\\.[a-zA-Z0-9]*)\", name)\n\n        if m:\n            self._hash, self._suffix = m.groups()\n        else:\n            raise ValueError(\n                \"path has to be of the form &lt;hash&gt;.&lt;suffix&gt; or &lt;partial_hash&gt;*.&lt;suffix&gt;\"\n            )\n\n    @property\n    def _path(self):\n        return f\"{self._hash}*{self._suffix}\"\n\n    def __repr__(self):\n        \"\"\"Returns the representation of the external object.\n\n        The length of the hash can be specified in the\n        [config](configuration.md).\n        \"\"\"\n        hash = self._hash[: _config.config.hash_length]\n\n        if len(hash) == 64:\n            return f'external(\"{hash}{self._suffix}\")'\n        else:\n            return f'external(\"{hash}*{self._suffix}\")'\n\n    def __eq__(self, other):\n        \"\"\"Two external objects are equal if they have the same hash and\n        suffix.\"\"\"\n        if not isinstance(other, external):\n            return NotImplemented\n\n        min_hash_len = min(len(self._hash), len(other._hash))\n\n        if self._hash[:min_hash_len] != other._hash[:min_hash_len]:\n            return False\n\n        if self._suffix != other._suffix:\n            return False\n\n        return True\n\n    def _load_value(self):\n        assert state().storage is not None\n        return state().storage.read(self._path)\n</code></pre>"},{"location":"outsource/#inline_snapshot.external.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Two external objects are equal if they have the same hash and suffix.</p> Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Two external objects are equal if they have the same hash and\n    suffix.\"\"\"\n    if not isinstance(other, external):\n        return NotImplemented\n\n    min_hash_len = min(len(self._hash), len(other._hash))\n\n    if self._hash[:min_hash_len] != other._hash[:min_hash_len]:\n        return False\n\n    if self._suffix != other._suffix:\n        return False\n\n    return True\n</code></pre>"},{"location":"outsource/#inline_snapshot.external.__init__","title":"<code>__init__(name)</code>","text":"<p>External objects are used as a representation for outsourced data. You should not create them directly.</p> <p>The external data is by default stored inside <code>&lt;pytest_config_dir&gt;/.inline-snapshot/external</code>, where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any. To store data in a different location, set the <code>storage-dir</code> option in pyproject.toml. Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the external stored object.</p> required Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"External objects are used as a representation for outsourced data.\n    You should not create them directly.\n\n    The external data is by default stored inside `&lt;pytest_config_dir&gt;/.inline-snapshot/external`,\n    where `&lt;pytest_config_dir&gt;` is replaced by the directory containing the Pytest configuration file, if any.\n    To store data in a different location, set the `storage-dir` option in pyproject.toml.\n    Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.\n\n    Parameters:\n        name: the name of the external stored object.\n    \"\"\"\n\n    m = re.fullmatch(r\"([0-9a-fA-F]*)\\*?(\\.[a-zA-Z0-9]*)\", name)\n\n    if m:\n        self._hash, self._suffix = m.groups()\n    else:\n        raise ValueError(\n            \"path has to be of the form &lt;hash&gt;.&lt;suffix&gt; or &lt;partial_hash&gt;*.&lt;suffix&gt;\"\n        )\n</code></pre>"},{"location":"outsource/#inline_snapshot.external.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the representation of the external object.</p> <p>The length of the hash can be specified in the config.</p> Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the representation of the external object.\n\n    The length of the hash can be specified in the\n    [config](configuration.md).\n    \"\"\"\n    hash = self._hash[: _config.config.hash_length]\n\n    if len(hash) == 64:\n        return f'external(\"{hash}{self._suffix}\")'\n    else:\n        return f'external(\"{hash}*{self._suffix}\")'\n</code></pre>"},{"location":"outsource/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>trim</code> removes every snapshots form the storage which is not referenced with <code>external(...)</code> in the code.</li> </ul>"},{"location":"pytest/","title":"pytest integration","text":"<p>inline-snapshot provides one pytest option with different flags (create, fix, trim, update, short-report, report, disable).</p> <p>Snapshot comparisons return always <code>True</code> if you use one of the flags create, fix or review. This is necessary because the whole test needs to be run to fix all snapshots like in this case:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot(5)\n    assert 2 &lt;= snapshot(5)\n</code></pre> <p>Note</p> <p>Every flag with the exception of disable and short-report disables the pytest assert-rewriting.</p>"},{"location":"pytest/#-inline-snapshotcreatefixtrimupdate","title":"--inline-snapshot=create,fix,trim,update","text":"<p>Approve the changes of the given category. These flags can be combined with report and review.</p> test_something.py<pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot()\n    assert 2 &lt;= snapshot(5)\n</code></pre> <pre><code>&gt; pytest test_something.py --inline-snapshot=create,report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0\nrootdir: /tmp/tmp.cgmHdlOykq\nplugins: inline-snapshot-0.23.2\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes will be applied, because you used ]8;id=165275;https://15r10nk.github.io/inline-snapshot/latest/categories/#create\\create]8;;\\\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot(1)                                                 \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=]8;id=43305;https://15r10nk.github.io/inline-snapshot/latest/categories/#trim\\trim]8;;\\ to apply them, or use the interactive mode with \n--inline-snapshot=]8;id=564568;https://15r10nk.github.io/inline-snapshot/latest/pytest/#-inline-snapshotreview\\review]8;;\\\n\n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.12s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotshort-report","title":"--inline-snapshot=short-report","text":"<p>give a short report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=short-report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0\nrootdir: /tmp/tmp.k4334rcVpt\nplugins: inline-snapshot-0.23.2\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nInfo: one snapshot can be trimmed (--inline-snapshot=trim)\nError: one snapshot is missing a value (--inline-snapshot=create)\n\nYou can also use --inline-snapshot=review to approve the changes interactively\n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.09s ==========================\n</code></pre> <p>Info</p> <p>short-report exists mainly to show that snapshots have changed with enabled pytest assert-rewriting. This option will be replaced with report when this restriction is lifted.</p>"},{"location":"pytest/#-inline-snapshotreport","title":"--inline-snapshot=report","text":"<p>Shows a diff report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0\nrootdir: /tmp/tmp.pEDl4O7ndn\nplugins: inline-snapshot-0.23.2\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=]8;id=776415;https://15r10nk.github.io/inline-snapshot/latest/categories/#create\\create]8;;\\ to apply them, or use the interactive mode with \n--inline-snapshot=]8;id=603799;https://15r10nk.github.io/inline-snapshot/latest/pytest/#-inline-snapshotreview\\review]8;;\\\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot()                                                  \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=]8;id=855549;https://15r10nk.github.io/inline-snapshot/latest/categories/#trim\\trim]8;;\\ to apply them, or use the interactive mode with \n--inline-snapshot=]8;id=156590;https://15r10nk.github.io/inline-snapshot/latest/pytest/#-inline-snapshotreview\\review]8;;\\\n\n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.10s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotreview","title":"--inline-snapshot=review","text":"<p>Shows a diff report for each category and ask if you want to apply the changes</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=review\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0\nrootdir: /tmp/tmp.MwbXqap7wl\nplugins: inline-snapshot-0.23.2\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 inline-snapshot \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nDo you want to ]8;id=344;https://15r10nk.github.io/inline-snapshot/latest/categories/#create\\create]8;;\\ these snapshots? [y/n] (n): \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot(1)                                                 \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nDo you want to ]8;id=794445;https://15r10nk.github.io/inline-snapshot/latest/categories/#trim\\trim]8;;\\ these snapshots? [y/n] (n): \n\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\nIf you just created this value with --snapshot=create, the value is now created and you can ignore this message.\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.10s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotdisable","title":"--inline-snapshot=disable","text":"<p>Disables all the snapshot logic. <code>snapshot(x)</code> will just return <code>x</code> and inline-snapshot will not be able to fix snapshots or to generate reports. This can be used if you think that snapshot logic causes a problem in your tests. It is also the default for CI runs.</p> <p>deprecation</p> <p>This option was previously called <code>--inline-snapshot-disable</code></p>"},{"location":"testing/","title":"Testing","text":"<p><code>inline_snapshot.testing</code> provides tools which can be used to test inline-snapshot workflows. This might be useful if you want to build your own libraries based on inline-snapshot.</p> <p>The following example shows how you can use the <code>Example</code> class to test what inline-snapshot would do with given the source code. The snapshots in the argument are asserted inside the <code>run_*</code> methods, but only when they are provided.</p> original--inline-snapshot=create <p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n\"\"\"\n        }\n    ).run_inline(  # run without flags\n        reported_categories=snapshot(),\n    ).run_pytest(\n        [\"--inline-snapshot=short-report\"],  # check the pytest report\n        changed_files=snapshot(),\n        report=snapshot(),\n        returncode=snapshot(),\n    ).run_pytest(  # run with create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(),\n        returncode=snapshot(),\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n\"\"\"\n        }\n    ).run_inline(  # run without flags\n        reported_categories=snapshot([\"create\"]),\n    ).run_pytest(\n        [\"--inline-snapshot=short-report\"],  # check the pytest report\n        changed_files=snapshot({}),\n        report=snapshot(\n            \"\"\"\\\nError: one snapshot is missing a value (--inline-snapshot=create)\nYou can also use --inline-snapshot=review to approve the changes interactively\\\n\"\"\"\n        ),\n        returncode=snapshot(1),\n    ).run_pytest(  # run with create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(\n            {\n                \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot(2)\n\"\"\"\n            }\n        ),\n        returncode=snapshot(1),\n    )\n</code></pre></p>"},{"location":"testing/#api","title":"API","text":""},{"location":"testing/#inline_snapshot.testing.Example","title":"<code>Example</code>","text":""},{"location":"testing/#inline_snapshot.testing.Example.__init__","title":"<code>__init__(files)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>files</code> <code>str | dict[str, str]</code> <p>a collection of files where inline-snapshot operates on,    or just a string which will be saved as test_something.py.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.run_inline","title":"<code>run_inline(args=[], *, reported_categories=None, changed_files=None, report=None, raises=None)</code>","text":"<p>Execute the example files in process and run every <code>test_*</code> function.</p> <p>This is useful for fast test execution.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>inline-snapshot arguments (supports only \"--inline-snapshot=fix|create|...\" ).</p> <code>[]</code> <code>reported_categories</code> <code>Snapshot[list[Category]] | None</code> <p>snapshot of categories which inline-snapshot thinks could be applied.</p> <code>None</code> <code>changed_files</code> <code>Snapshot[dict[str, str]] | None</code> <p>snapshot of files which are changed by this run.</p> <code>None</code> <code>raises</code> <code>Snapshot[str] | None</code> <p>snapshot of the exception which is raised during the test execution.     It is required if your code raises an exception.</p> <code>None</code> <p>Returns:</p> Type Description <code>Example</code> <p>A new Example instance which contains the changed files.</p>"},{"location":"testing/#inline_snapshot.testing.Example.run_pytest","title":"<code>run_pytest(args=[], *, term_columns=80, env={}, changed_files=None, report=None, error=None, stderr=None, returncode=0, stdin=b'', outcomes=None)</code>","text":"<p>Run pytest with the given args and env variables in an separate process.</p> <p>It can be used to test the interaction between your code and pytest, but it is a bit slower than <code>run_inline</code></p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>pytest arguments like \"--inline-snapshot=fix\"</p> <code>[]</code> <code>env</code> <code>dict[str, str]</code> <p>dict of environment variables</p> <code>{}</code> <code>changed_files</code> <code>Snapshot[dict[str, str]] | None</code> <p>snapshot of files which are changed by this run.</p> <code>None</code> <code>report</code> <code>Snapshot[str] | None</code> <p>snapshot of the report at the end of the pytest run.</p> <code>None</code> <code>stderr</code> <code>Snapshot[str] | None</code> <p>pytest stderr output</p> <code>None</code> <code>returncode</code> <code>Snapshot[int]</code> <p>snapshot of the pytest returncode.</p> <code>0</code> <p>Returns:</p> Type Description <code>Example</code> <p>A new Example instance which contains the changed files.</p>"},{"location":"third_party/","title":"third-party","text":"<p>Third-party extensions can be used to enhance the testing experience with other frameworks. The goal of inline-snapshot is to provide the core functionality for many different use cases.</p> <p>List of current third-party extensions:</p> <ul> <li>inline-snapshot-django Extensions for using inline-snapshot to test Django projects.</li> <li>inline-snapshot-pandas pandas integration for inline-snapshot (insider only)</li> </ul> <p>How to add your extension to this list?</p> <p>Your package name has to start with <code>inline-snapshot-</code> or end with <code>-inline-snapshot</code> and has to be available on PyPI. The summary of your package will be used as description.</p> <p>I will update this list from time to time but you can accelerate this process by creating a new issue.</p>"},{"location":"types/","title":"types","text":""},{"location":"types/#inline_snapshot","title":"<code>inline_snapshot</code>","text":""},{"location":"types/#inline_snapshot.Category","title":"<code>Category = Literal['update', 'fix', 'create', 'trim']</code>  <code>module-attribute</code>","text":"<p>See categories</p>"},{"location":"types/#inline_snapshot.Snapshot","title":"<code>Snapshot</code>","text":"<p>Can be used to annotate function arguments which accept snapshot values.</p> <p>You can annotate function arguments with <code>Snapshot[T]</code> to declare that a snapshot-value can be passed as function argument. <code>Snapshot[T]</code> is a type alias for <code>T</code>, which allows you to pass <code>int</code> values instead of <code>int</code> snapshots.</p> <p>Example:</p> <pre><code>from typing import Optional\nfrom inline_snapshot import snapshot, Snapshot\n\n# required snapshots\n\n\ndef check_in_bounds(value, lower: Snapshot[int], upper: Snapshot[int]):\n    assert lower &lt;= value &lt;= upper\n\n\ndef test_numbers():\n    for c in \"hello world\":\n        check_in_bounds(ord(c), snapshot(32), snapshot(119))\n\n    # use with normal values\n    check_in_bounds(5, 0, 10)\n\n\n# optional snapshots\n\n\ndef check_container(\n    value,\n    *,\n    value_repr: Optional[Snapshot[str]] = None,\n    length: Optional[Snapshot[int]] = None\n):\n    if value_repr is not None:\n        assert repr(value) == value_repr\n\n    if length is not None:\n        assert len(value) == length\n\n\ndef test_container():\n    check_container([1, 2], value_repr=snapshot(\"[1, 2]\"), length=snapshot(2))\n\n    check_container({1, 1}, length=snapshot(1))\n</code></pre> Source code in <code>src/inline_snapshot/_types.py</code> <pre><code>class Snapshot(Protocol[T]):\n    \"\"\"Can be used to annotate function arguments which accept snapshot\n    values.\n\n    You can annotate function arguments with `Snapshot[T]` to declare that a snapshot-value can be passed as function argument.\n    `Snapshot[T]` is a type alias for `T`, which allows you to pass `int` values instead of `int` snapshots.\n\n\n    Example:\n    &lt;!-- inline-snapshot: create fix trim first_block outcome-passed=2 --&gt;\n    ``` python\n    from typing import Optional\n    from inline_snapshot import snapshot, Snapshot\n\n    # required snapshots\n\n\n    def check_in_bounds(value, lower: Snapshot[int], upper: Snapshot[int]):\n        assert lower &lt;= value &lt;= upper\n\n\n    def test_numbers():\n        for c in \"hello world\":\n            check_in_bounds(ord(c), snapshot(32), snapshot(119))\n\n        # use with normal values\n        check_in_bounds(5, 0, 10)\n\n\n    # optional snapshots\n\n\n    def check_container(\n        value,\n        *,\n        value_repr: Optional[Snapshot[str]] = None,\n        length: Optional[Snapshot[int]] = None\n    ):\n        if value_repr is not None:\n            assert repr(value) == value_repr\n\n        if length is not None:\n            assert len(value) == length\n\n\n    def test_container():\n        check_container([1, 2], value_repr=snapshot(\"[1, 2]\"), length=snapshot(2))\n\n        check_container({1, 1}, length=snapshot(1))\n    ```\n    \"\"\"\n\n    def __eq__(self, other: object, /) -&gt; bool: ...  # pragma: no cover\n</code></pre>"},{"location":"howto/parametrize/","title":"pytest parametrize","text":"<p>inline-snapshot can also be used with <code>pytest.mark.parametrize</code>. All you have to do is to use <code>snapshot()</code> as an parameter for your test</p> <pre><code>import pytest\nfrom inline_snapshot import snapshot\n\n\n@pytest.mark.parametrize(\n    \"a,b,result\",\n    [\n        (1, 2, snapshot()),\n        (3, 4, snapshot()),\n    ],\n)\ndef test_param(a, b, result):\n    assert a + b == result\n</code></pre> <p>and the missing value will be created for each run.</p> <pre><code>import pytest\nfrom inline_snapshot import snapshot\n\n\n@pytest.mark.parametrize(\n    \"a,b,result\",\n    [\n        (1, 2, snapshot(3)),\n        (3, 4, snapshot(7)),\n    ],\n)\ndef test_param(a, b, result):\n    assert a + b == result\n</code></pre>"}]}