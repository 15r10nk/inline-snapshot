{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-inline-snapshot","title":"Welcome to inline-snapshot","text":"<p>inline-snapshot can be used for different things:</p> <ul> <li>golden master/approval/snapshot testing.   The idea is that you have a function with a currently unknown result and you want to write a tests, which ensures that the result does not change during refactoring.</li> <li>Compare things which are complex like lists with lot of numbers or complex data structures.</li> <li>Things which might change during the development like error messages.</li> </ul> <p><code>inline-snapshot</code> automates the process of recording, storing and updating the value you want to compare with. The value is converted with <code>repr()</code> and stored in the source file as argument of the <code>snapshot()</code> function.</p>"},{"location":"#usage","title":"Usage","text":"<p>You can use <code>snapshot()</code> instead of the value which you want to compare with and run the tests to record the correct values.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p>Your tests will break, if you change your code by adding <code>// 18</code>. Maybe that is correct and you should fix your code, or your code is correct and you want to update your test results.</p> changed code--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(1590054)\n</code></pre></p> <p>Please verify the new results. <code>git diff</code> will give you a good overview over all changed results. Use <code>pytest -k test_something --inline-snapshot=fix</code> if you only want to change one test.</p>"},{"location":"#supported-operations","title":"Supported operations","text":"<p>You can use <code>snapshot(x)</code> like you can use <code>x</code> in your assertion with a limited set of operations:</p> <ul> <li><code>value == snapshot()</code> to compare with something,</li> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</li> </ul> <p>Warning</p> <p>One snapshot can only be used with one operation. The following code will not work:  <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot(5)\n    assert 5 &lt;= s\n    assert 5 == s\n\n\n# Error:\n# &gt;       assert 5 == s\n# E       TypeError: This snapshot cannot be use with `==`, because it was previously used with `x &lt;= snapshot`\n</code></pre></p>"},{"location":"#supported-usage","title":"Supported usage","text":"<p>It is possible to place <code>snapshot()</code> anywhere in the tests and reuse it multiple times.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 21 * 2\n\n\nresult = snapshot()\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 21 * 2\n\n\nresult = snapshot(42)\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p><code>snapshot()</code> can also be used in loops:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot(3)\n</code></pre></p> <p>or passed as an argument to a function:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot())\n    check_string_len(\"1234\", snapshot())\n    check_string_len(\".......\", snapshot())\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot(3))\n    check_string_len(\"1234\", snapshot(4))\n    check_string_len(\".......\", snapshot(7))\n</code></pre></p>"},{"location":"#feedback","title":"Feedback","text":"<p>inline-snapshot provides some advanced ways to work with snapshots.</p> <p>I would like to know how these features are used to further improve this small library. Let me know if you've found interesting use cases for this library via twitter, fosstodon or in the github discussions.</p>"},{"location":"#sponsors","title":"Sponsors","text":"<p>I would like to thank my sponsors. Without them, I would not be able to invest so much time in my projects.</p>"},{"location":"#bronze-sponsor","title":"Bronze sponsor \ud83e\udd49","text":""},{"location":"#issues","title":"Issues","text":"<p>If you encounter any problems, please report an issue along with a detailed description.</p>"},{"location":"categories/","title":"Categories","text":"<p>Each snapshot change is assigned to a different category. This is done because inline-snapshot supports more than just <code>==</code> checks.</p> <p>There are changes which:</p> <ul> <li>create new snapshot values</li> <li>fix your tests</li> <li>update only the syntax to a new representation</li> <li>trim unused pieces from your snapshots</li> </ul> <p>Create and fix are mainly used, but it is good to know what type of change you are approving, because it helps with the decision if this changes should be applied.</p>"},{"location":"categories/#categories","title":"Categories","text":""},{"location":"categories/#create","title":"Create","text":"<p>These changes are made when new snapshots are created.</p> <p>The result of each comparison is <code>True</code>, which allows to run the whole test to fill all new snapshots with values.</p> <p>Example:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 5 == snapshot()\n\n    assert 5 &lt;= snapshot()\n\n    assert 5 in snapshot()\n\n    s = snapshot()\n    assert 5 == s[\"key\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 5 == snapshot(5)\n\n    assert 5 &lt;= snapshot(5)\n\n    assert 5 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 5 == s[\"key\"]\n</code></pre>"},{"location":"categories/#fix","title":"Fix","text":"<p>These changes are made when the snapshots comparison does not return <code>True</code> any more (depending on the operation <code>==</code>, <code>&lt;=</code>, <code>in</code>). The result of each comparison is <code>True</code> if you change something from this category, which allows to run the whole test and to fix other snapshots.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 8 == snapshot(5)\n\n    assert 8 &lt;= snapshot(5)\n\n    assert 8 in snapshot([5])\n\n    s = snapshot({\"key\": 5})\n    assert 8 == s[\"key\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 8 == snapshot(8)\n\n    assert 8 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key\": 8})\n    assert 8 == s[\"key\"]\n</code></pre> <p>Info</p> <p>The main reason for the different categories is to make the number of changes in the fix category as small as possible. The changes in the fix category are the only changes which change the value of the snapshots and should be reviewed carefully.</p>"},{"location":"categories/#trim","title":"Trim","text":"<p>These changes are made when parts of the snapshots are removed which are no longer needed, or if limits can be reduced.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 &lt;= snapshot(8)\n\n    assert 8 in snapshot([5, 8])\n\n    s = snapshot({\"key1\": 1, \"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 &lt;= snapshot(2)\n\n    assert 8 in snapshot([8])\n\n    s = snapshot({\"key2\": 2})\n    assert 2 == s[\"key2\"]\n</code></pre> <p>There might be problems in cases where you use the same snapshot in different tests, run only one test and trim the snapshot with <code>pytest -k test_a --inline-snapshot=trim</code> in this case:</p> <pre><code>from inline_snapshot import snapshot\n\ns = snapshot(5)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <pre><code>from inline_snapshot import snapshot\n\ns = snapshot(2)\n\n\ndef test_a():\n    assert 2 &lt;= s\n\n\ndef test_b():\n    assert 5 &lt;= s\n</code></pre> <p>The value of the snapshot is reduced to <code>2</code>, because <code>test_a()</code> was the only test running and inline-snapshot does not know about <code>5 &lt;= s</code>. It is recommended to use trim only if you run your complete test suite.</p>"},{"location":"categories/#update","title":"Update","text":"<p>Changes in the update category do not change the value in the code, just the representation. The reason might be that <code>repr()</code> of the object has changed or that inline-snapshot provides some new logic which changes the representation. Like with the strings in the following example:</p> original--inline-snapshot=update <p> <pre><code>from inline_snapshot import snapshot\n\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\"a\\nb\\nc\\n\")\n\n    assert 5 == snapshot(4 + 1)\n\n    assert Vector(1, 2) == snapshot(Vector(x=1, y=2))\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return NotImplemented\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        # return f\"Vector(x={self.x}, y={self.y})\"\n        return f\"Vector({self.x}, {self.y})\"\n\n\ndef test_something():\n    assert \"a\\nb\\nc\\n\" == snapshot(\n        \"\"\"\\\na\nb\nc\n\"\"\"\n    )\n\n    assert 5 == snapshot(5)\n\n    assert Vector(1, 2) == snapshot(Vector(1, 2))\n</code></pre></p> <p>The approval of this type of changes is easier, because inline-snapshot assures that the value has not changed.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#exec-1--upcomming-changes","title":"upcomming changes","text":""},{"location":"changelog/#exec-1--fixed","title":"Fixed","text":"<ul> <li>fixed some issues with dataclass arguments</li> </ul>"},{"location":"changelog/#0193-2025-01-15","title":"0.19.3 \u2014 2025-01-15","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>raise no assertion for positional arguments inside constructor methods.</li> </ul>"},{"location":"changelog/#0192-2025-01-15","title":"0.19.2 \u2014 2025-01-15","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li> <p>fixed a crash when you changed the snapshot to use a custom constructor method for dataclass/pydantic models.</p> <p>example: <pre><code>from inline_snapshot import snapshot\nfrom pydantic import BaseModel\n\n\nclass A(BaseModel):\n    a: int\n\n    @classmethod\n    def from_str(cls, s):\n        return cls(a=int(s))\n\n\ndef test_something():\n    assert A(a=2) == snapshot(A.from_str(\"1\"))\n</code></pre></p> </li> </ul> <p></p>"},{"location":"changelog/#0191-2025-01-12","title":"0.19.1 \u2014 2025-01-12","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>added the optional <code>inline-snapshot[dirty-equals]</code> dependency to depend on the dirty-equals version which works in combination with inline-snapshot.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li> <p>snapshots with pydantic models can now be compared multiple times</p> <pre><code>class A(BaseModel):\n    a: int\n\n\ndef test_something():\n    for _ in [1, 2]:\n        assert A(a=1) == snapshot(A(a=1))\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#0190-2025-01-10","title":"0.19.0 \u2014 2025-01-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>You can now specify which tool you want to use to format your code by setting a <code>format-command</code> in your configuration.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>BREAKING-CHANGE you have to install <code>inline-snapshot[black]</code> now if you want to format your code like in the previous versions. This option is not required if you use a <code>format-command</code>.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Load default config values even if <code>[tool.inline-snapshot]</code> is missing.   This makes the documented default shortcuts <code>--review</code> and <code>--fix</code> work.</li> </ul>"},{"location":"changelog/#0182-2025-01-02","title":"0.18.2 \u2014 2025-01-02","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>added <code>[dependency-groups]</code> to pyproject.toml and use uv and pytest to run tests in CI.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>use '.model_fields' on pydantic model class and not instance. This fixes a deprecation warning in the upcoming pydantic v2.11 (#169)</li> </ul>"},{"location":"changelog/#0181-2024-12-22","title":"0.18.1 \u2014 2024-12-22","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>uv is now only used during test time if you run the inline-snapshot tests with <code>pytest --use-uv</code>   This solves a problem if you want to package inline-snapshot in distributions (#165)</li> </ul>"},{"location":"changelog/#0180-2024-12-21","title":"0.18.0 \u2014 2024-12-21","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for a new <code>storage-dir</code> configuration option, to tell inline-snapshot where to store data files such as external snapshots.</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li> <p>pydantic v1 is supported again. pydantic v1 &amp; v2 create now the same snapshots. You can use <code>.dict()</code> to get the same snapshots like in inline-snapshot-0.15.0 for pydantic v1.</p> <pre><code>class M(BaseModel):\n    name: str\n\n\ndef test_pydantic():\n    m = M(name=\"Tom\")\n    assert m == snapshot(M(name=\"Tom\"))\n    assert m.dict() == snapshot({\"name\": \"Tom\"})\n</code></pre> </li> <li> <p>Find <code>pyproject.toml</code> file in parent directories, not just next to the Pytest configuration file.</p> </li> </ul> <p></p>"},{"location":"changelog/#0171-2024-12-17","title":"0.17.1 \u2014 2024-12-17","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Code generation for sets is now deterministic.   <pre><code>def test():\n    assert {1j, 2j, 1, 2, 3} == snapshot({1, 1j, 2, 2j, 3})\n</code></pre></li> </ul>"},{"location":"changelog/#0170-2024-12-14","title":"0.17.0 \u2014 2024-12-14","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li> <p>attrs can now contain unmanaged values</p> <pre><code>import datetime as dt\nimport uuid\nimport attrs\nfrom dirty_equals import IsDatetime\nfrom inline_snapshot import Is, snapshot\n\n\n@attrs.define\nclass Attrs:\n    ts: dt.datetime\n    id: uuid.UUID\n\n\ndef test():\n    id = uuid.uuid4()\n\n    assert Attrs(dt.datetime.now(), id) == snapshot(\n        Attrs(ts=IsDatetime(), id=Is(id))\n    )\n</code></pre> </li> </ul> <p></p>"},{"location":"changelog/#0160-2024-12-12","title":"0.16.0 \u2014 2024-12-12","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li><code>inline_snapshot.extra.warns</code> to captures warnings and compares them against expected warnings.     <pre><code>def test_warns():\n    with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n        warn(\"some problem\")\n</code></pre></li> </ul>"},{"location":"changelog/#0151-2024-12-10","title":"0.15.1 \u2014 2024-12-10","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>solved a bug caused by a variable inside a snapshot (#148)</li> </ul>"},{"location":"changelog/#0150-2024-12-10","title":"0.15.0 \u2014 2024-12-10","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li> <p>snapshots inside snapshots are now supported.</p> <pre><code>assert get_schema() == snapshot(\n    [\n        {\n            \"name\": \"var_1\",\n            \"type\": snapshot(\"int\") if version &lt; 2 else snapshot(\"string\"),\n        }\n    ]\n)\n</code></pre> </li> <li> <p>runtime values can now be part of snapshots.</p> <pre><code>from inline_snapshot import snapshot, Is\n\ncurrent_version = \"1.5\"\nassert request() == snapshot(\n    {\"data\": \"page data\", \"version\": Is(current_version)}\n)\n</code></pre> </li> <li> <p>f-strings can now also be used within snapshots, but are currently not fixed by inline-snapshot.</p> </li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>dirty-equals expressions are now treated like runtime values or snapshots within snapshots and are not modified by inline-snapshot.</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li> <p>inline-snapshot checks now if the given command line flags (<code>--inline-snapshot=...</code>) are valid</p> </li> <li> <p><code>Example(...).run_pytest(raise=snapshot(...))</code> uses now the flags from the current run and not the flags from the Example.</p> </li> </ul> <p></p>"},{"location":"changelog/#0142-2024-12-07","title":"0.14.2 \u2014 2024-12-07","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>do not crash when handling raw f-strings (<code>rf\"\"</code>,<code>RF\"\"</code>,...) (#143)</li> </ul>"},{"location":"changelog/#0141-2024-12-04","title":"0.14.1 \u2014 2024-12-04","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li> <p>Don't crash for snapshots like <code>snapshot(f\"\")</code> (#139)   It first appeared with pytest-8.3.4, but already existed before for cpython-3.11.   f-strings in snapshots are currently not official supported, but they should not lead to crashes.</p> </li> <li> <p>skip formatting if black returns an error (#138)</p> </li> </ul> <p></p>"},{"location":"changelog/#0140-2024-11-10","title":"0.14.0 \u2014 2024-11-10","text":""},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>removed the <code>\"Programming Language :: Python :: Implementation :: PyPy\"</code> classifier which was incorrect, because inline-snapshot can not fix snapshots on pypy.   inline-snapshot now enforces <code>--inline-snapshot=disable</code> when used with an implementation other than cpython, which allows it to be used in packages that want to support pypy.</li> </ul>"},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>command line shortcuts can be defined to simplify your workflows. <code>--review</code> and <code>--fix</code> are defined by default. See the documentation for details.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li><code>--inline-snapshot=create/fix/trim/update</code> will no longer show reports for other categories.   You can use <code>--inline-snapshot=create,report</code> if you want to use the old behaviour.</li> </ul>"},{"location":"changelog/#0134-2024-11-07","title":"0.13.4 \u2014 2024-11-07","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>use tomli instead of toml (#130)</li> </ul>"},{"location":"changelog/#0133-2024-09-24","title":"0.13.3 \u2014 2024-09-24","text":""},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>removed non-optional dirty-equals dependency (#118)</li> </ul>"},{"location":"changelog/#0132-2024-09-24","title":"0.13.2 \u2014 2024-09-24","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>star-expressions in list or dicts where never valid and cause a warning now.     <pre><code>    other=[2]\n    assert [5,2]==snapshot([5,*other])\n</code></pre></li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li> <p>A snapshot which contains an dirty-equals expression can now be compared multiple times.</p> <pre><code>def test_something():\n    greeting = \"hello\"\n    for name in [\"alex\", \"bob\"]:\n        assert (name, greeting) == snapshot((IsString(), \"hello\"))\n</code></pre> </li> </ul>"},{"location":"changelog/#v0131-2024-09-18","title":"v0.13.1 (2024-09-18)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>Use tomllib instead of PyPI toml on Python 3.11 and later</li> </ul>"},{"location":"changelog/#v0130-2024-09-10","title":"v0.13.0 (2024-09-10)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>added extra.prints</li> <li>3.13 support</li> <li>strings with one line-break at the end become no multiline strings</li> </ul>"},{"location":"changelog/#v0121-2024-08-05","title":"v0.12.1 (2024-08-05)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>add license to project metadata and some other fixes in pyproject.toml (#104)</li> </ul>"},{"location":"changelog/#v0120-2024-07-22","title":"v0.12.0 (2024-07-22)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>implement extra.raises</li> <li>added inline_snapshot.testing.Example which can be used to test 3rd-party extensions</li> </ul>"},{"location":"changelog/#v0110-2024-07-07","title":"v0.11.0 (2024-07-07)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>check if the result of copy.deepcopy() is equal to the copied value</li> <li>support for <code>enum.Enum</code>, <code>enum.Flag</code>, <code>type</code> and omitting of default values (#73)</li> </ul>"},{"location":"changelog/#v0102-2024-05-28","title":"v0.10.2 (2024-05-28)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>changed how --inline-snapshot=disable works in combination with xdist (#90)</li> <li>fix typo, rename 'theme' with 'them'</li> </ul>"},{"location":"changelog/#v0101-2024-05-26","title":"v0.10.1 (2024-05-26)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>trigger no update for trailing comma changes</li> </ul>"},{"location":"changelog/#v0100-2024-05-21","title":"v0.10.0 (2024-05-21)","text":""},{"location":"changelog/#breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>removed support for python 3.7</li> <li>removed <code>--inline-snapshot-disable</code> option and replaced it with <code>--inline-snapshot=disable</code></li> </ul>"},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>new flags: disable, short-report, report and review</li> <li>added config option and environment variable to specify default flags</li> <li>show diff of changed snapshots in pytest report</li> <li>interactive review mode</li> </ul>"},{"location":"changelog/#v090-2024-05-07","title":"v0.9.0 (2024-05-07)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>check if inline-snapshot is used in combination with xdist and notify the user that this is not possible</li> </ul>"},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>change the quoting of strings does not trigger an update</li> </ul>"},{"location":"changelog/#v082-2024-04-24","title":"v0.8.2 (2024-04-24)","text":""},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>removed restriction that the snapshot functions has to be called snapshot (#72)</li> <li>report error in tear down for sub-snapshots with missing values (#70)</li> <li>element access in sub-snapshots does not create new values</li> </ul>"},{"location":"changelog/#v081-2024-04-22","title":"v0.8.1 (2024-04-22)","text":""},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>make typing less strict</li> </ul>"},{"location":"changelog/#v080-2024-04-09","title":"v0.8.0 (2024-04-09)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li>prevent dirty-equal values from triggering of updates</li> <li>fix lists by calculating the alignment of the changed values</li> <li>insert dict items</li> <li>delete dict items</li> <li>preserve not changed dict-values and list-elements</li> </ul>"},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>update with UndecidedValue</li> <li>handle dicts with mulitple insertions and deletions</li> <li>handle lists with mulitple insertions and deletions</li> <li>fixed typing and coverage</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>removed old needs* logic</li> <li>removed get_result</li> <li>use _get_changes api for DictValue</li> <li>use _get_changes api for CollectionValue</li> <li>use _get_changes api for MinMaxValue</li> <li>use _get_changes</li> <li>moved some functions</li> </ul>"},{"location":"changelog/#v070-2024-02-27","title":"v0.7.0 (2024-02-27)","text":""},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>removed old --update-snapshots option</li> </ul>"},{"location":"changelog/#v061-2024-01-28","title":"v0.6.1 (2024-01-28)","text":""},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>use utf-8 encoding to read and write source files</li> </ul>"},{"location":"changelog/#v060-2023-12-10","title":"v0.6.0 (2023-12-10)","text":""},{"location":"changelog/#feat_7","title":"Feat","text":"<ul> <li>store snapshot values in external files</li> </ul>"},{"location":"changelog/#v052-2023-11-13","title":"v0.5.2 (2023-11-13)","text":""},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>remove upper bound from dependency in pyproject.toml</li> </ul>"},{"location":"changelog/#v051-2023-10-20","title":"v0.5.1 (2023-10-20)","text":""},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>show better error messages</li> </ul>"},{"location":"changelog/#v050-2023-10-15","title":"v0.5.0 (2023-10-15)","text":""},{"location":"changelog/#feat_8","title":"Feat","text":"<ul> <li>support 3.12</li> </ul>"},{"location":"changelog/#fix_11","title":"Fix","text":"<ul> <li>do not change empty snapshot if it is not used</li> </ul>"},{"location":"changelog/#v040-2023-09-29","title":"v0.4.0 (2023-09-29)","text":""},{"location":"changelog/#feat_9","title":"Feat","text":"<ul> <li>escaped linebreak at the start/end of multiline strings</li> </ul>"},{"location":"changelog/#fix_12","title":"Fix","text":"<ul> <li>added py.typed</li> </ul>"},{"location":"changelog/#v032-2023-07-31","title":"v0.3.2 (2023-07-31)","text":""},{"location":"changelog/#fix_13","title":"Fix","text":"<ul> <li>handle update flag in sub-snapshots correctly</li> <li>fixed some edge cases where sub-snapshots had problems with some flags</li> <li>string literal concatenation should trigger no update</li> </ul>"},{"location":"changelog/#v031-2023-07-14","title":"v0.3.1 (2023-07-14)","text":""},{"location":"changelog/#fix_14","title":"Fix","text":"<ul> <li>added <code>__all__</code> to inline_snapshot</li> <li>flags fix/trim/create/update are changing the matching snapshots</li> </ul>"},{"location":"changelog/#v030-2023-07-12","title":"v0.3.0 (2023-07-12)","text":""},{"location":"changelog/#breaking-change_1","title":"BREAKING CHANGE","text":"<ul> <li>values have to be copyable with <code>copy.deepcopy</code></li> </ul>"},{"location":"changelog/#fix_15","title":"Fix","text":"<ul> <li>snapshot the current value of mutable objects   <pre><code>l = [1]\nassert l == snapshot([1])  # old behaviour: snapshot([1, 2])\nl.append(2)\nassert l == snapshot([1, 2])\n</code></pre></li> </ul>"},{"location":"changelog/#v021-2023-07-09","title":"v0.2.1 (2023-07-09)","text":""},{"location":"changelog/#fix_16","title":"Fix","text":"<ul> <li>black configuration files are respected</li> </ul>"},{"location":"changelog/#v020-2023-06-20","title":"v0.2.0 (2023-06-20)","text":""},{"location":"changelog/#feat_10","title":"Feat","text":"<ul> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li> <p><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</p> </li> <li> <p>convert strings with newlines to triple quoted strings   <pre><code>assert \"a\\nb\\n\" == snapshot(\n    \"\"\"a\nb\n\"\"\"\n)\n</code></pre></p> </li> <li>preserve black formatting</li> </ul>"},{"location":"changelog/#v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":""},{"location":"changelog/#fix_17","title":"Fix","text":"<ul> <li>updated executing</li> </ul>"},{"location":"changelog/#v011-2022-12-08","title":"v0.1.1 (2022-12-08)","text":""},{"location":"changelog/#fix_18","title":"Fix","text":"<ul> <li>fixed typo in pytest plugin name</li> </ul>"},{"location":"changelog/#v010-2022-07-25","title":"v0.1.0 (2022-07-25)","text":""},{"location":"changelog/#feat_11","title":"Feat","text":"<ul> <li>first inline-snapshot version</li> </ul>"},{"location":"cmp_snapshot/","title":"x <= snapshot()","text":""},{"location":"cmp_snapshot/#general","title":"General","text":"<p>A snapshot can be compared against any value with <code>&lt;=</code> or <code>&gt;=</code>. This can be used to create a upper/lower bound for some result. The snapshot value can be trimmed to the lowest/largest valid value.</p> <p>Example:</p> original code--inline-snapshot=createoptimized code --inline-snapshot=trim <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot()\n    assert iterations &lt;= snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(3)\n</code></pre></p> <p>Warning</p> <p>This should not be used to check for any flaky values like the runtime of some code, because it will randomly break your tests.</p> <p>The same snapshot value can also be used in multiple assertions.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    value = snapshot()\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    value = snapshot(6)\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p>"},{"location":"cmp_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the new value and store it in the source code if it is contradicts the comparison.</li> <li><code>trim</code> record the new value and store it in the source code if it is more strict than the old one.</li> </ul>"},{"location":"code_generation/","title":"Code generation","text":"<p>You can use almost any python datatype and also complex values like <code>datatime.date</code>, because <code>repr()</code> is used to convert the values to source code. The default <code>__repr__()</code> behaviour can be customized. It might be necessary to import the right modules to match the <code>repr()</code> output.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"byte abc\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot(\n        {\n            \"name\": \"hello\",\n            \"one number\": 5,\n            \"numbers\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            \"sets\": {1, 2, 15},\n            \"datetime\": datetime.date(1, 2, 22),\n            \"complex stuff\": (3 + 5j),\n            \"bytes\": b\"byte abc\\n\\x16\",\n        }\n    )\n</code></pre></p> <p>The code is generated in the following way:</p> <ol> <li>The value is copied with <code>value = copy.deepcopy(value)</code> and it is checked if the copied value is equal to the original value.</li> <li>The code is generated with <code>repr(value)</code> (which can be customized)</li> <li> <p>Strings which contain newlines are converted to triple quoted strings.</p> <p>Note</p> <p>Missing newlines at start or end are escaped (since 0.4.0).</p> original code--inline-snapshot=update <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"first line\nsecond line\"\"\"\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"\\\nfirst line\nsecond line\\\n\"\"\"\n    )\n</code></pre></p> </li> <li> <p>The new code fragments are formatted with black if it is installed.</p> <p>Note</p> <p>Black is an optional dependency since inline-snapshot v0.19.0. You can install it with: <pre><code>pip install inline-snapshot[black]\n</code></pre></p> </li> <li> <p>The whole file is formatted</p> <ul> <li> <p>with black if it was formatted with black before.</p> <p>Note</p> <p>The black formatting of the whole file could not work for the following reasons:</p> <ol> <li>black is configured with cli arguments and not in a configuration file. Solution: configure black in a configuration file</li> <li>inline-snapshot uses a different black version. Solution: specify which black version inline-snapshot should use by adding black with a specific version to your dependencies.</li> <li>black is not installed. Black is an optional dependency since inline-snapshot v0.19.0</li> </ol> </li> <li> <p>or with the format-command if you defined one.</p> </li> </ul> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Default configuration:</p> <pre><code>[tool.inline-snapshot]\nhash-length=15\ndefault-flags=[\"short-report\"]\nformat-command=\"\"\n\n[tool.inline-snapshot.shortcuts]\nreview=[\"review\"]\nfix=[\"create\",\"fix\"]\n</code></pre> <ul> <li>hash-length: specifies the length of the hash used by <code>external()</code> in the code representation.     This does not affect the hash length used to store the data.     The hash should be long enough to avoid hash collisions.</li> <li> <p>default-flags: defines which flags should be used if there are no flags specified with <code>--inline-snapshot=...</code>.     You can also use the environment variable <code>INLINE_SNAPSHOT_DEFAULT_FLAGS=...</code> to specify the flags and to override those in the configuration file.</p> </li> <li> <p>shortcuts: allows you to define custom commands to simplify your workflows.     <code>--fix</code> and <code>--review</code> are defined by default, but this configuration can be changed to fit your needs.</p> </li> <li> <p>storage-dir: allows you to define the directory where inline-snapshot stores data files such as external snapshots.     By default, it will be <code>&lt;pytest_config_dir&gt;/.inline-snapshot</code>,     where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any.     External snapshots will be stored in the <code>external</code> subfolder of the storage directory.</p> </li> <li> <p>format-command: allows you to specify a custom command which is used to format the python code after code is changed.    <pre><code>[tool.inline-snapshot]\nformat-command=\"ruff format --stdin-filename {filename}\"\n</code></pre>    The placeholder <code>{filename}</code> can be used to specify the filename if it is needed to find the correct formatting options for this file.</p> <p>Important</p> <p>The command should not format the file on disk. The current file content (with the new code changes) is passed to stdin and the formatted content should be written to stdout.</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Please create an issue before writing a pull request so we can discuss what needs to be changed.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>The code can be tested with hatch</p> <ul> <li><code>hatch test</code> can be used to test all supported python versions and to check for coverage.</li> <li><code>hatch test -py 3.10 -- --sw</code> runs pytest for python 3.10 with the <code>--sw</code> argument.</li> </ul> <p>The preferred way to test inline-snapshot is by using <code>inline-snapshot.texting.Example</code>. You will see some other fixtures which are used inside the tests, but these are old ways to write the tests and I try to use the new <code>Example</code> class to write new tests.</p>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>This project has a hard coverage requirement of 100% (which is checked in CI). You can also check the coverage locally with <code>hatch test -acp</code>. The goal here is to find different edge cases which might have bugs.</p> <p>However, it is possible to exclude some code from the coverage.</p> <p>Code can be marked with <code>pragma: no cover</code>, if it can not be tested for some reason. This makes it easy to spot uncovered code in the source.</p> <p>Impossible conditions can be handled with <code>assert False</code>. <pre><code>if some_condition:\n    ...\nif some_other_codition:\n    ...\nelse:\n    assert False, \"unreachable because ...\"\n</code></pre> This serves also as an additional check during runtime.</p>"},{"location":"contributing/#commits","title":"Commits","text":"<p>Please use pre-commit for your commits.</p>"},{"location":"customize_repr/","title":"@customize_repr","text":"<p><code>repr()</code> can be used to convert a python object into a source code representation of the object, but this does not work for every type. Here are some examples:</p> <pre><code>&gt;&gt;&gt; repr(int)\n\"&lt;class 'int'&gt;\"\n\n&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; E = Enum(\"E\", [\"a\", \"b\"])\n&gt;&gt;&gt; repr(E.a)\n'&lt;E.a: 1&gt;'\n</code></pre> <p><code>customize_repr</code> can be used to overwrite the default <code>repr()</code> behaviour.</p> <p>The implementation for <code>Enum</code> looks like this:</p> <pre><code>@customize_repr\ndef _(value: Enum):\n    return f\"{type(value).__qualname__}.{value.name}\"\n</code></pre> <p>This implementation is then used by inline-snapshot if <code>repr()</code> is called during the code generation, but not in normal code.</p> <pre><code>from inline_snapshot import snapshot\nfrom enum import Enum\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # normal repr\n    assert repr(E.a) == \"&lt;E.a: 1&gt;\"\n\n    # the special implementation to convert the Enum into a code\n    assert E.a == snapshot(E.a)\n</code></pre>"},{"location":"customize_repr/#builtin-datatypes","title":"builtin datatypes","text":"<p>inline-snapshot comes with a special implementation for the following types:</p> <ul> <li><code>builtins.frozenset</code></li> <li><code>builtins.set</code></li> <li><code>builtins.type</code></li> <li><code>enum.Enum</code></li> <li><code>enum.Flag</code></li> </ul> <p>Note</p> <p>Container types like <code>dict</code>, <code>list</code>, <code>tuple</code> or <code>dataclass</code> are handled in a different way, because inline-snapshot also needs to inspect these types to implement unmanaged snapshot values.</p>"},{"location":"customize_repr/#customize-recursive-repr","title":"customize recursive repr","text":"<p>You can also use <code>repr()</code> inside <code>__repr__()</code>, if you want to make your own type compatible with inline-snapshot.</p> <pre><code>from inline_snapshot import snapshot\nfrom enum import Enum\n\n\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def __repr__(self):\n        # this would not work\n        # return f\"Pair({self.a!r}, {self.b!r})\"\n\n        # you have to use repr()\n        return f\"Pair({repr(self.a)}, {repr(self.b)})\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Pair):\n            return NotImplemented\n        return self.a == other.a and self.b == other.b\n\n\ndef test_enum():\n    E = Enum(\"E\", [\"a\", \"b\"])\n\n    # the special repr implementation is used recursive here\n    # to convert every Enum to the correct representation\n    assert Pair(E.a, [E.b]) == snapshot(Pair(E.a, [E.b]))\n</code></pre> <p>Note</p> <p>using <code>f\"{obj!r}\"</code> or <code>PyObject_Repr()</code> will not work, because inline-snapshot replaces <code>builtins.repr</code> during the code generation. The only way to use the custom repr implementation is to use the <code>repr()</code> function.</p> <p>Note</p> <p>This implementation allows inline-snapshot to use the custom <code>repr()</code> recursively, but it does not allow you to use unmanaged snapshot values like <code>Pair(Is(some_var),5)</code></p> <p>you can also customize the representation of datatypes in other libraries:</p> <pre><code>from inline_snapshot import customize_repr\nfrom other_lib import SomeType\n\n\n@customize_repr\ndef _(value: SomeType):\n    return f\"SomeType(x={repr(value.x)})\"\n</code></pre>"},{"location":"eq_snapshot/","title":"x == snapshot()","text":""},{"location":"eq_snapshot/#general","title":"General","text":"<p>A snapshot can be compared with any value using <code>==</code>. The value can be recorded with <code>--inline-snapshot=create</code> if the snapshot is empty. The value can later be changed with <code>--inline-snapshot=fix</code> if the value the snapshot is compared with has changed.</p> <p>Example:</p> original code--inline-snapshot=createvalue changed--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 4 == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 4 == snapshot(6)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 40 == snapshot(4)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 2 + 40 == snapshot(42)\n</code></pre></p>"},{"location":"eq_snapshot/#unmanaged-snapshot-values","title":"unmanaged snapshot values","text":"<p>inline-snapshots manages everything inside <code>snapshot(...)</code>, which means that the developer should not change these parts, but there are cases where it is useful to give the developer the control over the snapshot content back.</p> <p>Therefor some types will be ignored by inline-snapshot and will not be updated or fixed, even if they cause tests to fail.</p> <p>These types are:</p> <ul> <li>dirty-equals expressions,</li> <li>dynamic code inside <code>Is(...)</code>,</li> <li>snapshots inside snapshots and</li> <li>f-strings.</li> </ul> <p>inline-snapshot is able to handle these types within the following containers:</p> <ul> <li>list</li> <li>tuple</li> <li>dict</li> <li>namedtuple</li> <li>dataclass</li> <li>attrs</li> </ul> <p>Other types are converted with a customizable <code>repr()</code> into code. It is not possible to use unmanaged snapshot values within these objects.</p>"},{"location":"eq_snapshot/#dirty-equals","title":"dirty-equals","text":"<p>It might be, that larger snapshots with many lists and dictionaries contain some values which change frequently and are not relevant for the test. They might be part of larger data structures and be difficult to normalize.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\"date\": datetime.datetime(2024, 3, 14, 0, 0), \"payload\": \"some data\"}\n    )\n</code></pre></p> <p>The date can be replaced with the dirty-equals expression <code>IsDatetime()</code>.</p> <p>Example:</p> using IsDatetime()changed payload--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"data changed for some good reason\",\n        }\n    )\n</code></pre></p> <p>Note</p> <p>Use the optional dirty-equals dependency to install the version that works best in combination with inline-snapshot. <pre><code>pip install inline-snapshot[dirty-equals]\n</code></pre></p>"},{"location":"eq_snapshot/#is","title":"Is(...)","text":"<p><code>Is()</code> can be used to put runtime values inside snapshots. It tells inline-snapshot that the developer wants control over some part of the snapshot.</p> <pre><code>from inline_snapshot import snapshot, Is\n\ncurrent_version = \"1.5\"\n\n\ndef request():\n    return {\"data\": \"page data\", \"version\": current_version}\n\n\ndef test_function():\n    assert request() == snapshot(\n        {\"data\": \"page data\", \"version\": Is(current_version)}\n    )\n</code></pre> <p>The snapshot does not need to be fixed when <code>current_version</code> changes in the future, but <code>\"page data\"</code> will still be fixed if it changes.</p> <p><code>Is()</code> can also be used when the snapshot is evaluated multiple times, which is useful in loops or parametrized tests.</p> original code--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot, Is\n\n\ndef test_function():\n    for c in \"abc\":\n        assert [c, \"correct\"] == snapshot([Is(c), \"wrong\"])\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, Is\n\n\ndef test_function():\n    for c in \"abc\":\n        assert [c, \"correct\"] == snapshot([Is(c), \"correct\"])\n</code></pre></p>"},{"location":"eq_snapshot/#inner-snapshots","title":"inner snapshots","text":"<p>Snapshots can be used inside other snapshots in different use cases.</p>"},{"location":"eq_snapshot/#conditional-snapshots","title":"conditional snapshots","text":"<p>It is also possible to use snapshots inside snapshots.</p> <p>This is useful to describe version specific parts of snapshots by replacing the specific part with <code>snapshot() if some_condition else snapshot()</code>. The test has to be executed in each specific condition to fill the snapshots.</p> <p>The following example shows how this can be used to run a tests with two different library versions:</p> my_lib.py v1my_lib.py v2 <p> <pre><code>version = 1\n\n\ndef get_schema():\n    return [{\"name\": \"var_1\", \"type\": \"int\"}]\n</code></pre></p> <p> <pre><code>version = 2\n\n\ndef get_schema():\n    return [{\"name\": \"var_1\", \"type\": \"string\"}]\n</code></pre></p> <pre><code>from inline_snapshot import snapshot\nfrom my_lib import version, get_schema\n\n\ndef test_function():\n    assert get_schema() == snapshot(\n        [\n            {\n                \"name\": \"var_1\",\n                \"type\": snapshot(\"int\") if version &lt; 2 else snapshot(\"string\"),\n            }\n        ]\n    )\n</code></pre> <p>The advantage of this approach is that the test uses always the correct values for each library version.</p> <p>You can also extract the version logic into its own function.</p> <pre><code>from inline_snapshot import snapshot, Snapshot\nfrom my_lib import version, get_schema\n\n\ndef version_snapshot(v1: Snapshot, v2: Snapshot):\n    return v1 if version &lt; 2 else v2\n\n\ndef test_function():\n    assert get_schema() == snapshot(\n        [\n            {\n                \"name\": \"var_1\",\n                \"type\": version_snapshot(\n                    v1=snapshot(\"int\"), v2=snapshot(\"string\")\n                ),\n            }\n        ]\n    )\n</code></pre>"},{"location":"eq_snapshot/#common-snapshot-parts","title":"common snapshot parts","text":"<p>Another use case is the extraction of common snapshot parts into an extra snapshot:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef some_data(name):\n    return {\"header\": \"really long header\\n\" * 5, \"your name\": name}\n\n\ndef test_function():\n\n    header = snapshot(\n        \"\"\"\\\nreally long header\nreally long header\nreally long header\nreally long header\nreally long header\n\"\"\"\n    )\n\n    assert some_data(\"Tom\") == snapshot(\n        {\n            \"header\": header,\n            \"your name\": \"Tom\",\n        }\n    )\n\n    assert some_data(\"Bob\") == snapshot(\n        {\n            \"header\": header,\n            \"your name\": \"Bob\",\n        }\n    )\n</code></pre> <p>This simplifies test data and allows inline-snapshot to update your values if required. It makes also sure that the header is the same in both cases.</p>"},{"location":"eq_snapshot/#f-strings","title":"f-strings","text":"<p>f-strings are not generated by inline-snapshot, but they can be used in snapshots if you want to replace some dynamic part of a string value.</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef get_error():\n    # example code which generates an error message\n    return __file__ + \": error at line 5\"\n\n\ndef test_get_error():\n    assert get_error() == snapshot(f\"{__file__}: error at line 5\")\n</code></pre> <p>It is not required to wrap the changed value in <code>Is(f\"...\")</code>, because inline-snapshot knows that f-strings are only generated by the developer.</p> <p>Limitation</p> <p>inline-snapshot is currently not able to fix the string constants within f-strings.</p> <p><code>f\"...{var}...\"</code> works currently like <code>Is(f\"...{var}...\")</code> and issues a warning if the value changes, giving you the opportunity to fix your f-string.</p> <p><code>f\"...{var}...\"</code> will in the future work like <code>f\"...{Is(var)}\"</code>. inline-snapshot will then be able to fix the string parts within the f-string.</p>"},{"location":"eq_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the value parts and store them in the source code if it is different from the current one.</li> <li><code>update</code> update parts of the value if their representation has changed.   Parts which are replaced with dirty-equals expressions are not updated.</li> </ul>"},{"location":"extra/","title":"first-party (extra)","text":""},{"location":"extra/#inline_snapshot.extra","title":"<code>inline_snapshot.extra</code>","text":"<p>The following functions are build on top of inline-snapshot and could also be implemented in an extra library.</p> <p>They are part of inline-snapshot because they are general useful and do not depend on other libraries.</p>"},{"location":"extra/#inline_snapshot.extra.prints","title":"<code>prints(*, stdout='', stderr='')</code>","text":"<p>Uses <code>contextlib.redirect_stderr/stdout</code> to capture the output and compare it with the snapshots. <code>dirty_equals.IsStr</code> can be used to ignore the output if needed.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>Snapshot[str]</code> <p>snapshot which is compared to the recorded output</p> <code>''</code> <code>stderr</code> <code>Snapshot[str]</code> <p>snapshot which is compared to the recorded error output</p> <code>''</code> original--inline-snapshot=createignore stdout <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nimport sys\n\n\ndef test_prints():\n    with prints(stdout=snapshot(), stderr=snapshot()):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nimport sys\n\n\ndef test_prints():\n    with prints(\n        stdout=snapshot(\"hello world\\n\"), stderr=snapshot(\"some error\\n\")\n    ):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import prints\nfrom dirty_equals import IsStr\nimport sys\n\n\ndef test_prints():\n    with prints(\n        stdout=IsStr(),\n        stderr=snapshot(\"some error\\n\"),\n    ):\n        print(\"hello world\")\n        print(\"some error\", file=sys.stderr)\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef prints(*, stdout: Snapshot[str] = \"\", stderr: Snapshot[str] = \"\"):\n    \"\"\"Uses `contextlib.redirect_stderr/stdout` to capture the output and\n    compare it with the snapshots. `dirty_equals.IsStr` can be used to ignore\n    the output if needed.\n\n    Parameters:\n        stdout: snapshot which is compared to the recorded output\n        stderr: snapshot which is compared to the recorded error output\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        import sys\n\n\n        def test_prints():\n            with prints(stdout=snapshot(), stderr=snapshot()):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create outcome-passed=1 --&gt;\n        ``` python hl_lines=\"7 8 9\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        import sys\n\n\n        def test_prints():\n            with prints(\n                stdout=snapshot(\"hello world\\\\n\"), stderr=snapshot(\"some error\\\\n\")\n            ):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n\n    === \"ignore stdout\"\n\n        &lt;!-- inline-snapshot: outcome-passed=1 --&gt;\n        ``` python hl_lines=\"3 9 10\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import prints\n        from dirty_equals import IsStr\n        import sys\n\n\n        def test_prints():\n            with prints(\n                stdout=IsStr(),\n                stderr=snapshot(\"some error\\\\n\"),\n            ):\n                print(\"hello world\")\n                print(\"some error\", file=sys.stderr)\n        ```\n    \"\"\"\n\n    with redirect_stdout(io.StringIO()) as stdout_io:\n        with redirect_stderr(io.StringIO()) as stderr_io:\n            yield\n\n    assert stderr_io.getvalue() == stderr\n    assert stdout_io.getvalue() == stdout\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.raises","title":"<code>raises(exception)</code>","text":"<p>Check that an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Snapshot[str]</code> <p>snapshot which is compared with <code>f\"{type}: {message}\"</code> if an exception occured or <code>\"&lt;no exception&gt;\"</code> if no exception was raised.</p> required original--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import raises\n\n\ndef test_raises():\n    with raises(snapshot()):\n        1 / 0\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import raises\n\n\ndef test_raises():\n    with raises(snapshot(\"ZeroDivisionError: division by zero\")):\n        1 / 0\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef raises(exception: Snapshot[str]):\n    \"\"\"Check that an exception is raised.\n\n    Parameters:\n        exception: snapshot which is compared with `#!python f\"{type}: {message}\"` if an exception occured or `#!python \"&lt;no exception&gt;\"` if no exception was raised.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import raises\n\n\n        def test_raises():\n            with raises(snapshot()):\n                1 / 0\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create outcome-passed=1 --&gt;\n        ``` python hl_lines=\"6\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import raises\n\n\n        def test_raises():\n            with raises(snapshot(\"ZeroDivisionError: division by zero\")):\n                1 / 0\n        ```\n    \"\"\"\n\n    try:\n        yield\n    except Exception as ex:\n        msg = str(ex)\n        if \"\\n\" in msg:\n            assert f\"{type(ex).__name__}:\\n{ex}\" == exception\n        else:\n            assert f\"{type(ex).__name__}: {ex}\" == exception\n    else:\n        assert \"&lt;no exception&gt;\" == exception\n</code></pre>"},{"location":"extra/#inline_snapshot.extra.warns","title":"<code>warns(expected_warnings, /, include_line=False, include_file=False)</code>","text":"<p>Captures warnings with <code>warnings.catch_warnings</code> and compares them against expected warnings.</p> <p>Parameters:</p> Name Type Description Default <code>expected_warnings</code> <code>Snapshot[List[Warning]]</code> <p>Snapshot containing a list of expected warnings.</p> required <code>include_line</code> <code>bool</code> <p>If <code>True</code>, each expected warning is a tuple <code>(linenumber, message)</code>.</p> <code>False</code> <code>include_file</code> <code>bool</code> <p>If <code>True</code>, each expected warning is a tuple <code>(filename, message)</code>.</p> <code>False</code> <p>The format of the expected warning:</p> <ul> <li><code>(filename, linenumber, message)</code> if both <code>include_line</code> and <code>include_file</code> are <code>True</code>.</li> <li><code>(linenumber, message)</code> if only <code>include_line</code> is <code>True</code>.</li> <li><code>(filename, message)</code> if only <code>include_file</code> is <code>True</code>.</li> <li>A string <code>message</code> if both are <code>False</code>.</li> </ul> original--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import warns\nfrom warnings import warn\n\n\ndef test_warns():\n    with warns(snapshot(), include_line=True):\n        warn(\"some problem\")\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom inline_snapshot.extra import warns\nfrom warnings import warn\n\n\ndef test_warns():\n    with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n        warn(\"some problem\")\n</code></pre></p> Source code in <code>src/inline_snapshot/extra.py</code> <pre><code>@contextlib.contextmanager\ndef warns(\n    expected_warnings: Snapshot[List[Warning]],\n    /,\n    include_line: bool = False,\n    include_file: bool = False,\n):\n    \"\"\"\n    Captures warnings with `warnings.catch_warnings` and compares them against expected warnings.\n\n    Parameters:\n        expected_warnings: Snapshot containing a list of expected warnings.\n        include_line: If `True`, each expected warning is a tuple `(linenumber, message)`.\n        include_file: If `True`, each expected warning is a tuple `(filename, message)`.\n\n    The format of the expected warning:\n\n    - `(filename, linenumber, message)` if both `include_line` and `include_file` are `True`.\n    - `(linenumber, message)` if only `include_line` is `True`.\n    - `(filename, message)` if only `include_file` is `True`.\n    - A string `message` if both are `False`.\n\n    === \"original\"\n\n        &lt;!-- inline-snapshot: first_block outcome-passed=1 outcome-errors=1 --&gt;\n        ``` python\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import warns\n        from warnings import warn\n\n\n        def test_warns():\n            with warns(snapshot(), include_line=True):\n                warn(\"some problem\")\n        ```\n\n    === \"--inline-snapshot=create\"\n\n        &lt;!-- inline-snapshot: create fix outcome-passed=1 --&gt;\n        ``` python hl_lines=\"7\"\n        from inline_snapshot import snapshot\n        from inline_snapshot.extra import warns\n        from warnings import warn\n\n\n        def test_warns():\n            with warns(snapshot([(8, \"UserWarning: some problem\")]), include_line=True):\n                warn(\"some problem\")\n        ```\n    \"\"\"\n    with warnings.catch_warnings(record=True) as result:\n        warnings.simplefilter(\"always\")\n        yield\n\n    def make_warning(w):\n        message = f\"{w.category.__name__}: {w.message}\"\n        if not include_line and not include_file:\n            return message\n        message = (message,)\n\n        if include_line:\n            message = (w.lineno, *message)\n        if include_file:\n            message = (w.filename, *message)\n\n        return message\n\n    assert [make_warning(w) for w in result] == expected_warnings\n</code></pre>"},{"location":"getitem_snapshot/","title":"snapshot()[key]","text":""},{"location":"getitem_snapshot/#general","title":"General","text":"<p>It is possible to generate sub-snapshots during runtime. This sub-snapshots can be used like a normal snapshot.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot()\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot({\"a\": 4, \"b\": 5})\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p><code>s[key]</code> can be used with every normal snapshot operation including <code>s[key1][key2]</code>.</p>"},{"location":"getitem_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined or create a new sub-snapshot if one is missing.</li> <li><code>trim</code> remove sub-snapshots if they are not needed any more.</li> </ul> <p>The flags <code>fix</code> and <code>update</code> are applied recursive to all sub-snapshots.</p>"},{"location":"in_snapshot/","title":"x in snapshot()","text":""},{"location":"in_snapshot/#general","title":"General","text":"<p>It is possible to check if an value is in a snapshot. The value of the generated snapshot will be a list of all values which are tested.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot()\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    s = snapshot([5, 8, \"a\", \"b\"])\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p>"},{"location":"in_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> adds a value to the list if it is missing.</li> <li><code>trim</code> removes a value from the list if it is not necessary.</li> </ul>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#pytest-assert-rewriting-is-disabled","title":"pytest assert rewriting is disabled","text":"<p>inline-snapshot must disable pytest assert-rewriting if you use report/review/create/fix/trim/update flags.</p>"},{"location":"limitations/#xdist-is-not-supported","title":"xdist is not supported","text":"<p>You can not use inline-snapshot in combination with <code>pytest-xdist</code>. The use of <code>-n=...</code> implies <code>--inline-snapshot=disable</code>.</p>"},{"location":"limitations/#works-only-with-cpython","title":"works only with cpython","text":"<p>inline-snapshot works currently only with cpython. <code>--inline-snapshot=disable</code> is enforced for every other implementation.</p>"},{"location":"outsource/","title":"outsource(data)","text":""},{"location":"outsource/#general","title":"General","text":"<p>Storing snapshots in the source code is the main feature of inline snapshots. This has the advantage that you can easily see changes in code reviews. But it also has some problems:</p> <ul> <li>It is problematic to snapshot a lot of data, because it takes up a lot of space in your tests.</li> <li>Binary data or images are not readable in your tests.</li> </ul> <p>The <code>outsource()</code> function solves this problem and integrates itself nicely with the inline snapshot. It stores the data in a special <code>external()</code> object that can be compared in snapshots. The object is represented by the hash of the data. The actual data is stored in a separate file in your project.</p> <p>This allows the test to be renamed and moved around in your code without losing the connection to the stored data.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot, outsource\n\n\ndef test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, outsource\n\nfrom inline_snapshot import external\n\n\ndef test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot(\n        external(\"f5a956460453*.txt\")\n    )\n</code></pre></p> <p>The <code>external</code> object can be used inside other data structures.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot, outsource\n\n\ndef test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot, outsource\n\nfrom inline_snapshot import external\n\n\ndef test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot(\n        [\n            external(\"362ad8374ed6*.txt\"),\n            external(\"5755afea3f8d*.txt\"),\n            external(\"f5a956460453*.txt\"),\n        ]\n    )\n</code></pre></p>"},{"location":"outsource/#api","title":"API","text":""},{"location":"outsource/#inline_snapshot.outsource","title":"<code>inline_snapshot.outsource(data, *, suffix=None)</code>","text":"<p>Outsource some data into an external file.</p> <pre><code>&gt;&gt;&gt; png_data = b\"some_bytes\"  # should be the replaced with your actual data\n&gt;&gt;&gt; outsource(png_data, suffix=\".png\")\nexternal(\"212974ed1835*.png\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes]</code> <p>data which should be outsourced. strings are encoded with <code>\"utf-8\"</code>.</p> required <code>suffix</code> <code>Optional[str]</code> <p>overwrite file suffix. The default is <code>\".bin\"</code> if data is an instance of <code>bytes</code> and <code>\".txt\"</code> for <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>external</code> <p>The external data.</p> Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def outsource(data: Union[str, bytes], *, suffix: Optional[str] = None) -&gt; external:\n    \"\"\"Outsource some data into an external file.\n\n    ``` pycon\n    &gt;&gt;&gt; png_data = b\"some_bytes\"  # should be the replaced with your actual data\n    &gt;&gt;&gt; outsource(png_data, suffix=\".png\")\n    external(\"212974ed1835*.png\")\n\n    ```\n\n    Parameters:\n        data: data which should be outsourced. strings are encoded with `\"utf-8\"`.\n\n        suffix: overwrite file suffix. The default is `\".bin\"` if data is an instance of `#!python bytes` and `\".txt\"` for `#!python str`.\n\n    Returns:\n        The external data.\n    \"\"\"\n    if isinstance(data, str):\n        data = data.encode(\"utf-8\")\n        if suffix is None:\n            suffix = \".txt\"\n\n    elif isinstance(data, bytes):\n        if suffix is None:\n            suffix = \".bin\"\n    else:\n        raise TypeError(\"data has to be of type bytes | str\")\n\n    if not suffix or suffix[0] != \".\":\n        raise ValueError(\"suffix has to start with a '.' like '.png'\")\n\n    m = hashlib.sha256()\n    m.update(data)\n    hash = m.hexdigest()\n\n    assert storage is not None\n\n    name = hash + suffix\n\n    if not storage.lookup_all(name):\n        path = hash + \"-new\" + suffix\n        storage.save(path, data)\n\n    return external(name)\n</code></pre>"},{"location":"outsource/#inline_snapshot.external","title":"<code>inline_snapshot.external</code>","text":"Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>class external:\n    def __init__(self, name: str):\n        \"\"\"External objects are used as a representation for outsourced data.\n        You should not create them directly.\n\n        The external data is by default stored inside `&lt;pytest_config_dir&gt;/.inline-snapshot/external`,\n        where `&lt;pytest_config_dir&gt;` is replaced by the directory containing the Pytest configuration file, if any.\n        To store data in a different location, set the `storage-dir` option in pyproject.toml.\n        Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.\n\n        Parameters:\n            name: the name of the external stored object.\n        \"\"\"\n\n        m = re.fullmatch(r\"([0-9a-fA-F]*)\\*?(\\.[a-zA-Z0-9]*)\", name)\n\n        if m:\n            self._hash, self._suffix = m.groups()\n        else:\n            raise ValueError(\n                \"path has to be of the form &lt;hash&gt;.&lt;suffix&gt; or &lt;partial_hash&gt;*.&lt;suffix&gt;\"\n            )\n\n    @property\n    def _path(self):\n        return f\"{self._hash}*{self._suffix}\"\n\n    def __repr__(self):\n        \"\"\"Returns the representation of the external object.\n\n        The length of the hash can be specified in the\n        [config](configuration.md).\n        \"\"\"\n        hash = self._hash[: _config.config.hash_length]\n\n        if len(hash) == 64:\n            return f'external(\"{hash}{self._suffix}\")'\n        else:\n            return f'external(\"{hash}*{self._suffix}\")'\n\n    def __eq__(self, other):\n        \"\"\"Two external objects are equal if they have the same hash and\n        suffix.\"\"\"\n        if not isinstance(other, external):\n            return NotImplemented\n\n        min_hash_len = min(len(self._hash), len(other._hash))\n\n        if self._hash[:min_hash_len] != other._hash[:min_hash_len]:\n            return False\n\n        if self._suffix != other._suffix:\n            return False\n\n        return True\n\n    def _load_value(self):\n        assert storage is not None\n        return storage.read(self._path)\n</code></pre>"},{"location":"outsource/#inline_snapshot.external.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Two external objects are equal if they have the same hash and suffix.</p> Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Two external objects are equal if they have the same hash and\n    suffix.\"\"\"\n    if not isinstance(other, external):\n        return NotImplemented\n\n    min_hash_len = min(len(self._hash), len(other._hash))\n\n    if self._hash[:min_hash_len] != other._hash[:min_hash_len]:\n        return False\n\n    if self._suffix != other._suffix:\n        return False\n\n    return True\n</code></pre>"},{"location":"outsource/#inline_snapshot.external.__init__","title":"<code>__init__(name)</code>","text":"<p>External objects are used as a representation for outsourced data. You should not create them directly.</p> <p>The external data is by default stored inside <code>&lt;pytest_config_dir&gt;/.inline-snapshot/external</code>, where <code>&lt;pytest_config_dir&gt;</code> is replaced by the directory containing the Pytest configuration file, if any. To store data in a different location, set the <code>storage-dir</code> option in pyproject.toml. Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the external stored object.</p> required Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"External objects are used as a representation for outsourced data.\n    You should not create them directly.\n\n    The external data is by default stored inside `&lt;pytest_config_dir&gt;/.inline-snapshot/external`,\n    where `&lt;pytest_config_dir&gt;` is replaced by the directory containing the Pytest configuration file, if any.\n    To store data in a different location, set the `storage-dir` option in pyproject.toml.\n    Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.\n\n    Parameters:\n        name: the name of the external stored object.\n    \"\"\"\n\n    m = re.fullmatch(r\"([0-9a-fA-F]*)\\*?(\\.[a-zA-Z0-9]*)\", name)\n\n    if m:\n        self._hash, self._suffix = m.groups()\n    else:\n        raise ValueError(\n            \"path has to be of the form &lt;hash&gt;.&lt;suffix&gt; or &lt;partial_hash&gt;*.&lt;suffix&gt;\"\n        )\n</code></pre>"},{"location":"outsource/#inline_snapshot.external.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the representation of the external object.</p> <p>The length of the hash can be specified in the config.</p> Source code in <code>src/inline_snapshot/_external.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the representation of the external object.\n\n    The length of the hash can be specified in the\n    [config](configuration.md).\n    \"\"\"\n    hash = self._hash[: _config.config.hash_length]\n\n    if len(hash) == 64:\n        return f'external(\"{hash}{self._suffix}\")'\n    else:\n        return f'external(\"{hash}*{self._suffix}\")'\n</code></pre>"},{"location":"outsource/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>trim</code> removes every snapshots form the storage which is not referenced with <code>external(...)</code> in the code.</li> </ul>"},{"location":"pytest/","title":"pytest integration","text":"<p>inline-snapshot provides one pytest option with different flags (create, fix, trim, update, short-report, report, disable).</p> <p>Snapshot comparisons return always <code>True</code> if you use one of the flags create, fix or review. This is necessary because the whole test needs to be run to fix all snapshots like in this case:</p> <pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot(5)\n    assert 2 &lt;= snapshot(5)\n</code></pre> <p>Note</p> <p>Every flag with the exception of disable and short-report disables the pytest assert-rewriting.</p>"},{"location":"pytest/#-inline-snapshotcreatefixtrimupdate","title":"--inline-snapshot=create,fix,trim,update","text":"<p>Approve the changes of the given category. These flags can be combined with report and review.</p> test_something.py<pre><code>from inline_snapshot import snapshot\n\n\ndef test_something():\n    assert 1 == snapshot()\n    assert 2 &lt;= snapshot(5)\n</code></pre> <pre><code>&gt; pytest test_something.py --inline-snapshot=create,report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.3.4, pluggy-1.5.0\nrootdir: /tmp/tmp.uz2bl3BFih\nplugins: inline-snapshot-0.19.3\ncollected 1 item\n\ntest_something.py .                                                      [100%]\n=============================== inline snapshot ================================\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes will be applied, because you used --inline-snapshot=create\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot(1)                                                 \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=trim to apply them, or use the interactive mode with \n--inline-snapshot=review\n\n\n============================== 1 passed in 0.13s ===============================\n</code></pre>"},{"location":"pytest/#-inline-snapshotshort-report","title":"--inline-snapshot=short-report","text":"<p>give a short report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=short-report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.3.4, pluggy-1.5.0\nrootdir: /tmp/tmp.2x2jYcWPTx\nplugins: inline-snapshot-0.19.3\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\n=============================== inline snapshot ================================\nInfo: one snapshot can be trimmed (--inline-snapshot=trim)\nError: one snapshot is missing a value (--inline-snapshot=create)\n\nYou can also use --inline-snapshot=review to approve the changes interactively\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.09s ==========================\n</code></pre> <p>Info</p> <p>short-report exists mainly to show that snapshots have changed with enabled pytest assert-rewriting. This option will be replaced with report when this restriction is lifted.</p>"},{"location":"pytest/#-inline-snapshotreport","title":"--inline-snapshot=report","text":"<p>Shows a diff report over which changes can be made to the snapshots</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=report\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.3.4, pluggy-1.5.0\nrootdir: /tmp/tmp.vmi0r8RsHR\nplugins: inline-snapshot-0.19.3\ncollected 1 item\n\ntest_something.py .E                                                     [100%]\n\n==================================== ERRORS ====================================\n_____________________ ERROR at teardown of test_something ______________________\nyour snapshot is missing one value.\n=============================== inline snapshot ================================\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=create to apply them, or use the interactive mode with \n--inline-snapshot=review\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot()                                                  \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nThese changes are not applied.\nUse --inline-snapshot=trim to apply them, or use the interactive mode with \n--inline-snapshot=review\n\n=========================== short test summary info ============================\nERROR test_something.py::test_something - Failed: your snapshot is missing one value.\n========================== 1 passed, 1 error in 0.10s ==========================\n</code></pre>"},{"location":"pytest/#-inline-snapshotreview","title":"--inline-snapshot=review","text":"<p>Shows a diff report for each category and ask if you want to apply the changes</p> <pre><code>&gt; pytest test_something.py --inline-snapshot=review\n============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.3.4, pluggy-1.5.0\nrootdir: /tmp/tmp.SDN3Ui0AOJ\nplugins: inline-snapshot-0.19.3\ncollected 1 item\n\ntest_something.py .                                                      [100%]\n=============================== inline snapshot ================================\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Create snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -2,5 +2,5 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502 -    assert 1 == snapshot()                                                  \u2502\n\u2502 +    assert 1 == snapshot(1)                                                 \u2502\n\u2502      assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\ndo you want to create these snapshots? [y/n] (n): \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Trim snapshots \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 test_something.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 @@ -3,4 +3,4 @@                                                              \u2502\n\u2502                                                                              \u2502\n\u2502                                                                              \u2502\n\u2502  def test_something():                                                       \u2502\n\u2502      assert 1 == snapshot(1)                                                 \u2502\n\u2502 -    assert 2 &lt;= snapshot(5)                                                 \u2502\n\u2502 +    assert 2 &lt;= snapshot(2)                                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\ndo you want to trim these snapshots? [y/n] (n): \n\n============================== 1 passed in 0.11s ===============================\n</code></pre>"},{"location":"pytest/#-inline-snapshotdisable","title":"--inline-snapshot=disable","text":"<p>Disables all the snapshot logic. <code>snapshot(x)</code> will just return <code>x</code>. This can be used if you think exclude that snapshot logic causes a problem in your tests, or if you want to speedup your CI.</p> <p>deprecation</p> <p>This option was previously called <code>--inline-snapshot-disable</code></p>"},{"location":"testing/","title":"Testing","text":"<p><code>inline_snapshot.testing</code> provides tools which can be used to test inline-snapshot workflows. This might be useful if you want to build your own libraries based on inline-snapshot.</p> <p>The following example shows how you can use the <code>Example</code> class to test what inline-snapshot would do with given the source code. The snapshots in the argument are asserted inside the <code>run_*</code> methods, but only when they are provided.</p> original--inline-snapshot=create <p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n\"\"\"\n        }\n    ).run_inline(  # run without flags\n        reported_categories=snapshot(),\n    ).run_pytest(  # run without flags and check the pytest report\n        changed_files=snapshot(),\n        report=snapshot(),\n    ).run_pytest(  # run with create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(),\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot.testing import Example\nfrom inline_snapshot import snapshot\n\n\ndef test_something():\n\n    Example(\n        {\n            \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot()\n\"\"\"\n        }\n    ).run_inline(  # run without flags\n        reported_categories=snapshot([\"create\"]),\n    ).run_pytest(  # run without flags and check the pytest report\n        changed_files=snapshot({}),\n        report=snapshot(\n            \"\"\"\\\nError: one snapshot is missing a value (--inline-snapshot=create)\nYou can also use --inline-snapshot=review to approve the changes interactively\\\n\"\"\"\n        ),\n    ).run_pytest(  # run with create flag and check the changed files\n        [\"--inline-snapshot=create\"],\n        changed_files=snapshot(\n            {\n                \"test_a.py\": \"\"\"\\\nfrom inline_snapshot import snapshot\ndef test_a():\n    assert 1+1 == snapshot(2)\n\"\"\"\n            }\n        ),\n    )\n</code></pre></p>"},{"location":"testing/#api","title":"API","text":""},{"location":"testing/#inline_snapshot.testing.Example","title":"<code>Example</code>","text":""},{"location":"testing/#inline_snapshot.testing.Example.__init__","title":"<code>__init__(files)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>files</code> <code>str | dict[str, str]</code> <p>a collecton of files where inline-snapshot opperates on,    or just a string which will be saved as test_something.py.</p> required"},{"location":"testing/#inline_snapshot.testing.Example.run_inline","title":"<code>run_inline(args=[], *, reported_categories=None, changed_files=None, report=None, raises=None)</code>","text":"<p>Execute the example files in process and run every <code>test_*</code> function.</p> <p>This is useful for fast test execution.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>inline-snapshot arguments (supports only \"--inline-snapshot=fix|create|...\" ).</p> <code>[]</code> <code>reported_categories</code> <code>Snapshot[list[Category]] | None</code> <p>snapshot of categories which inline-snapshot thinks could be applied.</p> <code>None</code> <code>changed_files</code> <code>Snapshot[dict[str, str]] | None</code> <p>snapshot of files which are changed by this run.</p> <code>None</code> <code>raises</code> <code>Snapshot[str] | None</code> <p>snapshot of the exception which is raised during the test execution.     It is required if your code raises an exception.</p> <code>None</code> <p>Returns:</p> Type Description <code>Example</code> <p>A new Example instance which contains the changed files.</p>"},{"location":"testing/#inline_snapshot.testing.Example.run_pytest","title":"<code>run_pytest(args=[], *, term_columns=80, env={}, changed_files=None, report=None, stderr=None, returncode=None)</code>","text":"<p>Run pytest with the given args and env variables in an seperate process.</p> <p>It can be used to test the interaction between your code and pytest, but it is a bit slower than <code>run_inline</code></p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>pytest arguments like \"--inline-snapshot=fix\"</p> <code>[]</code> <code>env</code> <code>dict[str, str]</code> <p>dict of environment variables</p> <code>{}</code> <code>changed_files</code> <code>Snapshot[dict[str, str]] | None</code> <p>snapshot of files which are changed by this run.</p> <code>None</code> <code>report</code> <code>Snapshot[str] | None</code> <p>snapshot of the report at the end of the pytest run.</p> <code>None</code> <code>stderr</code> <code>Snapshot[str] | None</code> <p>pytest stderr output</p> <code>None</code> <code>returncode</code> <code>Snapshot[int] | None</code> <p>snapshot of the pytest returncode.</p> <code>None</code> <p>Returns:</p> Type Description <code>Example</code> <p>A new Example instance which contains the changed files.</p>"},{"location":"third_party/","title":"third-party","text":"<p>Third-party extensions can be used to enhance the testing experience with other frameworks. The goal of inline-snapshot is to provide the core functionality for many different use cases.</p> <p>List of current third-party extensions:</p> <ul> <li>inline-snapshot-pandas pandas integration for inline-snapshot (insider only)</li> </ul> <p>How to add your extension to this list?</p> <p>Your package name has to start with <code>inline-snapshot-</code> and has to be available on PyPI. The summary of your package will be used as description.</p> <p>I will update this list from time to time but you can accelerate this process by creating a new issue.</p>"},{"location":"types/","title":"types","text":""},{"location":"types/#inline_snapshot","title":"<code>inline_snapshot</code>","text":""},{"location":"types/#inline_snapshot.Category","title":"<code>Category = Literal['update', 'fix', 'create', 'trim']</code>  <code>module-attribute</code>","text":"<p>See categories</p>"},{"location":"types/#inline_snapshot.Snapshot","title":"<code>Snapshot</code>","text":"<p>Can be used to annotate function arguments which accept snapshot values.</p> <p>You can annotate function arguments with <code>Snapshot[T]</code> to declare that a snapshot-value can be passed as function argument. <code>Snapshot[T]</code> is a type alias for <code>T</code>, which allows you to pass <code>int</code> values instead of <code>int</code> snapshots.</p> <p>Example:</p> <pre><code>from typing import Optional\nfrom inline_snapshot import snapshot, Snapshot\n\n# required snapshots\n\n\ndef check_in_bounds(value, lower: Snapshot[int], upper: Snapshot[int]):\n    assert lower &lt;= value &lt;= upper\n\n\ndef test_numbers():\n    for c in \"hello world\":\n        check_in_bounds(ord(c), snapshot(32), snapshot(119))\n\n    # use with normal values\n    check_in_bounds(5, 0, 10)\n\n\n# optional snapshots\n\n\ndef check_container(\n    value,\n    *,\n    value_repr: Optional[Snapshot[str]] = None,\n    length: Optional[Snapshot[int]] = None\n):\n    if value_repr is not None:\n        assert repr(value) == value_repr\n\n    if length is not None:\n        assert len(value) == length\n\n\ndef test_container():\n    check_container([1, 2], value_repr=snapshot(\"[1, 2]\"), length=snapshot(2))\n\n    check_container({1, 1}, length=snapshot(1))\n</code></pre> Source code in <code>src/inline_snapshot/_types.py</code> <pre><code>class Snapshot(Generic[T]):\n    \"\"\"Can be used to annotate function arguments which accept snapshot\n    values.\n\n    You can annotate function arguments with `Snapshot[T]` to declare that a snapshot-value can be passed as function argument.\n    `Snapshot[T]` is a type alias for `T`, which allows you to pass `int` values instead of `int` snapshots.\n\n\n    Example:\n    &lt;!-- inline-snapshot: create fix trim first_block outcome-passed=2 --&gt;\n    ``` python\n    from typing import Optional\n    from inline_snapshot import snapshot, Snapshot\n\n    # required snapshots\n\n\n    def check_in_bounds(value, lower: Snapshot[int], upper: Snapshot[int]):\n        assert lower &lt;= value &lt;= upper\n\n\n    def test_numbers():\n        for c in \"hello world\":\n            check_in_bounds(ord(c), snapshot(32), snapshot(119))\n\n        # use with normal values\n        check_in_bounds(5, 0, 10)\n\n\n    # optional snapshots\n\n\n    def check_container(\n        value,\n        *,\n        value_repr: Optional[Snapshot[str]] = None,\n        length: Optional[Snapshot[int]] = None\n    ):\n        if value_repr is not None:\n            assert repr(value) == value_repr\n\n        if length is not None:\n            assert len(value) == length\n\n\n    def test_container():\n        check_container([1, 2], value_repr=snapshot(\"[1, 2]\"), length=snapshot(2))\n\n        check_container({1, 1}, length=snapshot(1))\n    ```\n    \"\"\"\n</code></pre>"}]}